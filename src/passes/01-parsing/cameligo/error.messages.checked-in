interactive_expr: Begin Fun WILD ARROW Bytes SEMI
##
## Ends in an error in state: 496.
##
## sequence -> Begin option(series) . End [ With Verbatim VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Mod MINUS Let Lang LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Constr CONS COMMA COLON CAT Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## Begin option(series)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 226, spurious reduction of production call_expr_level -> core_expr
## In state 233, spurious reduction of production unary_expr_level -> call_expr_level
## In state 220, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 223, spurious reduction of production add_expr_level -> mult_expr_level
## In state 313, spurious reduction of production cons_expr_level -> add_expr_level
## In state 303, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 335, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 342, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 349, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 476, spurious reduction of production seq_expr -> disj_expr_level
## In state 440, spurious reduction of production last_expr -> seq_expr
## In state 443, spurious reduction of production fun_expr(last_expr) -> Fun nseq(irrefutable) ARROW last_expr
## In state 444, spurious reduction of production last_expr -> fun_expr(last_expr)
## In state 480, spurious reduction of production series -> last_expr
## In state 495, spurious reduction of production option(series) -> series
##

Ill-formed sequence of expressions.

At this point, if the last expression is complete, the keyword 'end'
is expected.

interactive_expr: Begin Fun WILD ARROW With
##
## Ends in an error in state: 479.
##
## fun_expr(last_expr) -> Fun nseq(irrefutable) ARROW . last_expr [ End ]
##
## The known suffix of the stack is as follows:
## Fun nseq(irrefutable) ARROW
##
interactive_expr: Begin If Verbatim Then Fun WILD ARROW With
##
## Ends in an error in state: 466.
##
## fun_expr(closed_if) -> Fun nseq(irrefutable) ARROW . closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## Fun nseq(irrefutable) ARROW
##
interactive_expr: Begin Match Verbatim With WILD ARROW Fun WILD ARROW With
##
## Ends in an error in state: 439.
##
## fun_expr(base_cond) -> Fun nseq(irrefutable) ARROW . base_cond [ VBAR ]
## fun_expr(last_expr) -> Fun nseq(irrefutable) ARROW . last_expr [ End ]
##
## The known suffix of the stack is as follows:
## Fun nseq(irrefutable) ARROW
##
interactive_expr: If Verbatim Then Fun WILD ARROW With
##
## Ends in an error in state: 517.
##
## fun_expr(closed_if) -> Fun nseq(irrefutable) ARROW . closed_if [ Else ]
## fun_expr(expr) -> Fun nseq(irrefutable) ARROW . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun nseq(irrefutable) ARROW
##
interactive_expr: Fun WILD ARROW With
##
## Ends in an error in state: 194.
##
## fun_expr(expr) -> Fun nseq(irrefutable) ARROW . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun nseq(irrefutable) ARROW
##
interactive_expr: If Verbatim Then Match Verbatim With WILD ARROW Fun WILD ARROW With
##
## Ends in an error in state: 389.
##
## fun_expr(base_cond) -> Fun nseq(irrefutable) ARROW . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
## fun_expr(base_if_then_else) -> Fun nseq(irrefutable) ARROW . base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Fun nseq(irrefutable) ARROW
##
interactive_expr: Match Verbatim With WILD ARROW Fun WILD ARROW With
##
## Ends in an error in state: 428.
##
## fun_expr(base_cond) -> Fun nseq(irrefutable) ARROW . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun nseq(irrefutable) ARROW
##

Ill-formed function expression.

At this point, a function body is expected in the form of an expression.

interactive_expr: Begin If Verbatim Then If Verbatim Then Verbatim COMMA Bytes With
##
## Ends in an error in state: 469.
##
## if_then_else(closed_if) -> If expr Then closed_if . Else closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_if
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 226, spurious reduction of production call_expr_level -> core_expr
## In state 233, spurious reduction of production unary_expr_level -> call_expr_level
## In state 220, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 223, spurious reduction of production add_expr_level -> mult_expr_level
## In state 313, spurious reduction of production cons_expr_level -> add_expr_level
## In state 303, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 335, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 342, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 349, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 346, spurious reduction of production nsepseq(disj_expr_level,COMMA) -> disj_expr_level
## In state 345, spurious reduction of production tuple(disj_expr_level) -> disj_expr_level COMMA nsepseq(disj_expr_level,COMMA)
## In state 222, spurious reduction of production tuple_expr -> tuple(disj_expr_level)
## In state 467, spurious reduction of production base_expr(closed_if) -> tuple_expr
## In state 357, spurious reduction of production base_if_then_else__open(closed_if) -> base_expr(closed_if)
## In state 356, spurious reduction of production closed_if -> base_if_then_else__open(closed_if)
##
interactive_expr: Begin If Verbatim Then Verbatim COMMA Bytes With
##
## Ends in an error in state: 474.
##
## if_then_else(seq_expr) -> If expr Then closed_if . Else seq_expr [ SEMI End ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_if
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 226, spurious reduction of production call_expr_level -> core_expr
## In state 233, spurious reduction of production unary_expr_level -> call_expr_level
## In state 220, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 223, spurious reduction of production add_expr_level -> mult_expr_level
## In state 313, spurious reduction of production cons_expr_level -> add_expr_level
## In state 303, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 335, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 342, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 349, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 346, spurious reduction of production nsepseq(disj_expr_level,COMMA) -> disj_expr_level
## In state 345, spurious reduction of production tuple(disj_expr_level) -> disj_expr_level COMMA nsepseq(disj_expr_level,COMMA)
## In state 222, spurious reduction of production tuple_expr -> tuple(disj_expr_level)
## In state 467, spurious reduction of production base_expr(closed_if) -> tuple_expr
## In state 357, spurious reduction of production base_if_then_else__open(closed_if) -> base_expr(closed_if)
## In state 356, spurious reduction of production closed_if -> base_if_then_else__open(closed_if)
##

Ill-formed conditional expression.

At this point, if the expression of the branch 'then' is complete, the
branch 'else' is expected.

interactive_expr: Begin If Verbatim Then Verbatim With
##
## Ends in an error in state: 468.
##
## base_expr(closed_if) -> disj_expr_level . [ Else ]
## bin_op(disj_expr_level,BOOL_OR,conj_expr_level) -> disj_expr_level . BOOL_OR conj_expr_level [ Or Else COMMA BOOL_OR ]
## bin_op(disj_expr_level,Or,conj_expr_level) -> disj_expr_level . Or conj_expr_level [ Or Else COMMA BOOL_OR ]
## tuple(disj_expr_level) -> disj_expr_level . COMMA nsepseq(disj_expr_level,COMMA) [ Else ]
##
## The known suffix of the stack is as follows:
## disj_expr_level
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 226, spurious reduction of production call_expr_level -> core_expr
## In state 233, spurious reduction of production unary_expr_level -> call_expr_level
## In state 220, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 223, spurious reduction of production add_expr_level -> mult_expr_level
## In state 313, spurious reduction of production cons_expr_level -> add_expr_level
## In state 303, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 335, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 342, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 349, spurious reduction of production disj_expr_level -> conj_expr_level
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Begin If Verbatim Then If Verbatim With
##
## Ends in an error in state: 462.
##
## if_then_else(closed_if) -> If expr . Then closed_if Else closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## If expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 226, spurious reduction of production call_expr_level -> core_expr
## In state 233, spurious reduction of production unary_expr_level -> call_expr_level
## In state 220, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 223, spurious reduction of production add_expr_level -> mult_expr_level
## In state 313, spurious reduction of production cons_expr_level -> add_expr_level
## In state 303, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 335, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 342, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 349, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 370, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 372, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 373, spurious reduction of production expr -> base_cond__open(expr)
##
interactive_expr: Begin If Verbatim With
##
## Ends in an error in state: 454.
##
## if_then_else(seq_expr) -> If expr . Then closed_if Else seq_expr [ SEMI End ]
##
## The known suffix of the stack is as follows:
## If expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 226, spurious reduction of production call_expr_level -> core_expr
## In state 233, spurious reduction of production unary_expr_level -> call_expr_level
## In state 220, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 223, spurious reduction of production add_expr_level -> mult_expr_level
## In state 313, spurious reduction of production cons_expr_level -> add_expr_level
## In state 303, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 335, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 342, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 349, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 370, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 372, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 373, spurious reduction of production expr -> base_cond__open(expr)
##
interactive_expr: Begin Match Verbatim With WILD ARROW If Verbatim With
##
## Ends in an error in state: 265.
##
## if_then(base_cond) -> If expr . Then base_cond [ VBAR ]
## if_then_else(base_cond) -> If expr . Then closed_if Else base_cond [ VBAR ]
## if_then_else(seq_expr) -> If expr . Then closed_if Else seq_expr [ SEMI End ]
##
## The known suffix of the stack is as follows:
## If expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 226, spurious reduction of production call_expr_level -> core_expr
## In state 233, spurious reduction of production unary_expr_level -> call_expr_level
## In state 220, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 223, spurious reduction of production add_expr_level -> mult_expr_level
## In state 313, spurious reduction of production cons_expr_level -> add_expr_level
## In state 303, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 335, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 342, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 349, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 370, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 372, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 373, spurious reduction of production expr -> base_cond__open(expr)
##
interactive_expr: If Verbatim Then If Verbatim With
##
## Ends in an error in state: 513.
##
## if_then(expr) -> If expr . Then expr [ With Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
## if_then_else(closed_if) -> If expr . Then closed_if Else closed_if [ Else ]
## if_then_else(expr) -> If expr . Then closed_if Else expr [ With Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## If expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 226, spurious reduction of production call_expr_level -> core_expr
## In state 233, spurious reduction of production unary_expr_level -> call_expr_level
## In state 220, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 223, spurious reduction of production add_expr_level -> mult_expr_level
## In state 313, spurious reduction of production cons_expr_level -> add_expr_level
## In state 303, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 335, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 342, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 349, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 370, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 372, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 373, spurious reduction of production expr -> base_cond__open(expr)
##
interactive_expr: If Verbatim Then Match Verbatim With WILD ARROW If Verbatim With
##
## Ends in an error in state: 279.
##
## if_then(base_cond) -> If expr . Then base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
## if_then_else(base_cond) -> If expr . Then closed_if Else base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
## if_then_else(base_if_then_else) -> If expr . Then closed_if Else base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## If expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 226, spurious reduction of production call_expr_level -> core_expr
## In state 233, spurious reduction of production unary_expr_level -> call_expr_level
## In state 220, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 223, spurious reduction of production add_expr_level -> mult_expr_level
## In state 313, spurious reduction of production cons_expr_level -> add_expr_level
## In state 303, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 335, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 342, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 349, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 370, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 372, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 373, spurious reduction of production expr -> base_cond__open(expr)
##
interactive_expr: If Verbatim With
##
## Ends in an error in state: 500.
##
## if_then(expr) -> If expr . Then expr [ With Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
## if_then_else(expr) -> If expr . Then closed_if Else expr [ With Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## If expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 226, spurious reduction of production call_expr_level -> core_expr
## In state 233, spurious reduction of production unary_expr_level -> call_expr_level
## In state 220, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 223, spurious reduction of production add_expr_level -> mult_expr_level
## In state 313, spurious reduction of production cons_expr_level -> add_expr_level
## In state 303, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 335, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 342, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 349, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 370, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 372, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 373, spurious reduction of production expr -> base_cond__open(expr)
##
interactive_expr: Match Verbatim With WILD ARROW If Verbatim Then If Verbatim With
##
## Ends in an error in state: 287.
##
## if_then(base_cond) -> If expr . Then base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
## if_then_else(base_cond) -> If expr . Then closed_if Else base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
## if_then_else(closed_if) -> If expr . Then closed_if Else closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## If expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 226, spurious reduction of production call_expr_level -> core_expr
## In state 233, spurious reduction of production unary_expr_level -> call_expr_level
## In state 220, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 223, spurious reduction of production add_expr_level -> mult_expr_level
## In state 313, spurious reduction of production cons_expr_level -> add_expr_level
## In state 303, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 335, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 342, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 349, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 370, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 372, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 373, spurious reduction of production expr -> base_cond__open(expr)
##
interactive_expr: Match Verbatim With WILD ARROW If Verbatim With
##
## Ends in an error in state: 422.
##
## if_then(base_cond) -> If expr . Then base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
## if_then_else(base_cond) -> If expr . Then closed_if Else base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## If expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 226, spurious reduction of production call_expr_level -> core_expr
## In state 233, spurious reduction of production unary_expr_level -> call_expr_level
## In state 220, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 223, spurious reduction of production add_expr_level -> mult_expr_level
## In state 313, spurious reduction of production cons_expr_level -> add_expr_level
## In state 303, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 335, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 342, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 349, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 370, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 372, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 373, spurious reduction of production expr -> base_cond__open(expr)
##

Ill-formed conditional expression.

At this point, if the test expression is complete, the branch 'then' is 
expected.

interactive_expr: Begin If Verbatim Then Let Rec WILD EQ Bytes With
##
## Ends in an error in state: 458.
##
## let_expr(closed_if) -> Let Rec let_binding . seq(Attr) In closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 226, spurious reduction of production call_expr_level -> core_expr
## In state 233, spurious reduction of production unary_expr_level -> call_expr_level
## In state 220, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 223, spurious reduction of production add_expr_level -> mult_expr_level
## In state 313, spurious reduction of production cons_expr_level -> add_expr_level
## In state 303, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 335, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 342, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 349, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 370, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 372, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 373, spurious reduction of production expr -> base_cond__open(expr)
## In state 379, spurious reduction of production let_binding -> irrefutable option(type_annotation) EQ expr
##
interactive_expr: Begin Let Rec WILD EQ Bytes With
##
## Ends in an error in state: 450.
##
## let_in_sequence -> Let Rec let_binding . seq(Attr) In series [ End ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 226, spurious reduction of production call_expr_level -> core_expr
## In state 233, spurious reduction of production unary_expr_level -> call_expr_level
## In state 220, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 223, spurious reduction of production add_expr_level -> mult_expr_level
## In state 313, spurious reduction of production cons_expr_level -> add_expr_level
## In state 303, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 335, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 342, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 349, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 370, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 372, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 373, spurious reduction of production expr -> base_cond__open(expr)
## In state 379, spurious reduction of production let_binding -> irrefutable option(type_annotation) EQ expr
##
interactive_expr: Begin Match Verbatim With WILD ARROW Let Rec WILD EQ Bytes With
##
## Ends in an error in state: 261.
##
## let_expr(base_cond) -> Let Rec let_binding . seq(Attr) In base_cond [ VBAR ]
## let_in_sequence -> Let Rec let_binding . seq(Attr) In series [ End ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 226, spurious reduction of production call_expr_level -> core_expr
## In state 233, spurious reduction of production unary_expr_level -> call_expr_level
## In state 220, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 223, spurious reduction of production add_expr_level -> mult_expr_level
## In state 313, spurious reduction of production cons_expr_level -> add_expr_level
## In state 303, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 335, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 342, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 349, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 370, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 372, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 373, spurious reduction of production expr -> base_cond__open(expr)
## In state 379, spurious reduction of production let_binding -> irrefutable option(type_annotation) EQ expr
##
interactive_expr: If Verbatim Then Let Rec WILD EQ Bytes With
##
## Ends in an error in state: 509.
##
## let_expr(closed_if) -> Let Rec let_binding . seq(Attr) In closed_if [ Else ]
## let_expr(expr) -> Let Rec let_binding . seq(Attr) In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 226, spurious reduction of production call_expr_level -> core_expr
## In state 233, spurious reduction of production unary_expr_level -> call_expr_level
## In state 220, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 223, spurious reduction of production add_expr_level -> mult_expr_level
## In state 313, spurious reduction of production cons_expr_level -> add_expr_level
## In state 303, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 335, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 342, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 349, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 370, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 372, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 373, spurious reduction of production expr -> base_cond__open(expr)
## In state 379, spurious reduction of production let_binding -> irrefutable option(type_annotation) EQ expr
##
interactive_expr: If Verbatim Then Match Verbatim With WILD ARROW Let Rec WILD EQ Bytes With
##
## Ends in an error in state: 275.
##
## let_expr(base_cond) -> Let Rec let_binding . seq(Attr) In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
## let_expr(base_if_then_else) -> Let Rec let_binding . seq(Attr) In base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 226, spurious reduction of production call_expr_level -> core_expr
## In state 233, spurious reduction of production unary_expr_level -> call_expr_level
## In state 220, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 223, spurious reduction of production add_expr_level -> mult_expr_level
## In state 313, spurious reduction of production cons_expr_level -> add_expr_level
## In state 303, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 335, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 342, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 349, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 370, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 372, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 373, spurious reduction of production expr -> base_cond__open(expr)
## In state 379, spurious reduction of production let_binding -> irrefutable option(type_annotation) EQ expr
##
interactive_expr: Let Rec WILD EQ Bytes With
##
## Ends in an error in state: 173.
##
## let_expr(expr) -> Let Rec let_binding . seq(Attr) In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 226, spurious reduction of production call_expr_level -> core_expr
## In state 233, spurious reduction of production unary_expr_level -> call_expr_level
## In state 220, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 223, spurious reduction of production add_expr_level -> mult_expr_level
## In state 313, spurious reduction of production cons_expr_level -> add_expr_level
## In state 303, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 335, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 342, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 349, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 370, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 372, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 373, spurious reduction of production expr -> base_cond__open(expr)
## In state 379, spurious reduction of production let_binding -> irrefutable option(type_annotation) EQ expr
##
interactive_expr: Match Verbatim With WILD ARROW If Verbatim Then Let Rec WILD EQ Bytes With
##
## Ends in an error in state: 283.
##
## let_expr(base_cond) -> Let Rec let_binding . seq(Attr) In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
## let_expr(closed_if) -> Let Rec let_binding . seq(Attr) In closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 226, spurious reduction of production call_expr_level -> core_expr
## In state 233, spurious reduction of production unary_expr_level -> call_expr_level
## In state 220, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 223, spurious reduction of production add_expr_level -> mult_expr_level
## In state 313, spurious reduction of production cons_expr_level -> add_expr_level
## In state 303, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 335, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 342, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 349, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 370, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 372, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 373, spurious reduction of production expr -> base_cond__open(expr)
## In state 379, spurious reduction of production let_binding -> irrefutable option(type_annotation) EQ expr
##
interactive_expr: Match Verbatim With WILD ARROW Let Rec WILD EQ Bytes With
##
## Ends in an error in state: 418.
##
## let_expr(base_cond) -> Let Rec let_binding . seq(Attr) In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 226, spurious reduction of production call_expr_level -> core_expr
## In state 233, spurious reduction of production unary_expr_level -> call_expr_level
## In state 220, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 223, spurious reduction of production add_expr_level -> mult_expr_level
## In state 313, spurious reduction of production cons_expr_level -> add_expr_level
## In state 303, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 335, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 342, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 349, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 370, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 372, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 373, spurious reduction of production expr -> base_cond__open(expr)
## In state 379, spurious reduction of production let_binding -> irrefutable option(type_annotation) EQ expr
##

Ill-formed recursive let binding.

At this point, if the right-hand side of the let binding is a complete
expression, one of the following is expected:
  * a series of attributes;
  * the keyword 'in' followed by an expression.

interactive_expr: Begin If Verbatim Then Let Rec With
##
## Ends in an error in state: 457.
##
## let_expr(closed_if) -> Let Rec . let_binding seq(Attr) In closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## Let Rec
##
interactive_expr: Begin Match Verbatim With WILD ARROW Let Rec With
##
## Ends in an error in state: 260.
##
## let_expr(base_cond) -> Let Rec . let_binding seq(Attr) In base_cond [ VBAR ]
## let_in_sequence -> Let Rec . let_binding seq(Attr) In series [ End ]
##
## The known suffix of the stack is as follows:
## Let Rec
##
interactive_expr: Begin Let Rec With
##
## Ends in an error in state: 449.
##
## let_in_sequence -> Let Rec . let_binding seq(Attr) In series [ End ]
##
## The known suffix of the stack is as follows:
## Let Rec
##
interactive_expr: If Verbatim Then Let Rec With
##
## Ends in an error in state: 508.
##
## let_expr(closed_if) -> Let Rec . let_binding seq(Attr) In closed_if [ Else ]
## let_expr(expr) -> Let Rec . let_binding seq(Attr) In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let Rec
##
interactive_expr: If Verbatim Then Match Verbatim With WILD ARROW Let Rec With
##
## Ends in an error in state: 274.
##
## let_expr(base_cond) -> Let Rec . let_binding seq(Attr) In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
## let_expr(base_if_then_else) -> Let Rec . let_binding seq(Attr) In base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Let Rec
##
interactive_expr: Let Rec With
##
## Ends in an error in state: 172.
##
## let_expr(expr) -> Let Rec . let_binding seq(Attr) In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let Rec
##
interactive_expr: Match Verbatim With WILD ARROW If Verbatim Then Let Rec With
##
## Ends in an error in state: 282.
##
## let_expr(base_cond) -> Let Rec . let_binding seq(Attr) In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
## let_expr(closed_if) -> Let Rec . let_binding seq(Attr) In closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## Let Rec
##
interactive_expr: Match Verbatim With WILD ARROW Let Rec With
##
## Ends in an error in state: 417.
##
## let_expr(base_cond) -> Let Rec . let_binding seq(Attr) In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let Rec
##
contract: Let Rec With
##
## Ends in an error in state: 64.
##
## let_declaration -> Let Rec . let_binding seq(Attr) [ Type Let EOF ]
##
## The known suffix of the stack is as follows:
## Let Rec
##

Ill-formed recursive let binding.

At this point, an irrefutable pattern is expected, for instance an
identifier denoting the value being defined.

interactive_expr: Begin If Verbatim Then Let Rec WILD EQ Bytes Attr Type
##
## Ends in an error in state: 459.
##
## let_expr(closed_if) -> Let Rec let_binding seq(Attr) . In closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding seq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 174, spurious reduction of production seq(Attr) ->
## In state 175, spurious reduction of production seq(Attr) -> Attr seq(Attr)
##
interactive_expr: Begin Let Rec WILD EQ Bytes Attr Type
##
## Ends in an error in state: 451.
##
## let_in_sequence -> Let Rec let_binding seq(Attr) . In series [ End ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding seq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 174, spurious reduction of production seq(Attr) ->
## In state 175, spurious reduction of production seq(Attr) -> Attr seq(Attr)
##
interactive_expr: Begin Match Verbatim With WILD ARROW Let Rec WILD EQ Bytes Attr Type
##
## Ends in an error in state: 262.
##
## let_expr(base_cond) -> Let Rec let_binding seq(Attr) . In base_cond [ VBAR ]
## let_in_sequence -> Let Rec let_binding seq(Attr) . In series [ End ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding seq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 174, spurious reduction of production seq(Attr) ->
## In state 175, spurious reduction of production seq(Attr) -> Attr seq(Attr)
##
interactive_expr: If Verbatim Then Let Rec WILD EQ Bytes Attr Type
##
## Ends in an error in state: 510.
##
## let_expr(closed_if) -> Let Rec let_binding seq(Attr) . In closed_if [ Else ]
## let_expr(expr) -> Let Rec let_binding seq(Attr) . In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding seq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 174, spurious reduction of production seq(Attr) ->
## In state 175, spurious reduction of production seq(Attr) -> Attr seq(Attr)
##
interactive_expr: If Verbatim Then Match Verbatim With WILD ARROW Let Rec WILD EQ Bytes Attr Type
##
## Ends in an error in state: 276.
##
## let_expr(base_cond) -> Let Rec let_binding seq(Attr) . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
## let_expr(base_if_then_else) -> Let Rec let_binding seq(Attr) . In base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding seq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 174, spurious reduction of production seq(Attr) ->
## In state 175, spurious reduction of production seq(Attr) -> Attr seq(Attr)
##
interactive_expr: Let Rec WILD EQ Bytes Attr Type
##
## Ends in an error in state: 176.
##
## let_expr(expr) -> Let Rec let_binding seq(Attr) . In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding seq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 174, spurious reduction of production seq(Attr) ->
## In state 175, spurious reduction of production seq(Attr) -> Attr seq(Attr)
##
interactive_expr: Match Verbatim With WILD ARROW If Verbatim Then Let Rec WILD EQ Bytes Attr Type
##
## Ends in an error in state: 284.
##
## let_expr(base_cond) -> Let Rec let_binding seq(Attr) . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
## let_expr(closed_if) -> Let Rec let_binding seq(Attr) . In closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding seq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 174, spurious reduction of production seq(Attr) ->
## In state 175, spurious reduction of production seq(Attr) -> Attr seq(Attr)
##
interactive_expr: Match Verbatim With WILD ARROW Let Rec WILD EQ Bytes Attr Type
##
## Ends in an error in state: 419.
##
## let_expr(base_cond) -> Let Rec let_binding seq(Attr) . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding seq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 174, spurious reduction of production seq(Attr) ->
## In state 175, spurious reduction of production seq(Attr) -> Attr seq(Attr)
##
interactive_expr: Begin If Verbatim Then Let WILD EQ Bytes Attr Type
##
## Ends in an error in state: 472.
##
## let_expr(closed_if) -> Let let_binding seq(Attr) . In closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## Let let_binding seq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 174, spurious reduction of production seq(Attr) ->
## In state 175, spurious reduction of production seq(Attr) -> Attr seq(Attr)
##
interactive_expr: Begin Match Verbatim With WILD ARROW Let WILD EQ Bytes Attr Type
##
## Ends in an error in state: 487.
##
## let_expr(base_cond) -> Let let_binding seq(Attr) . In base_cond [ VBAR ]
## let_in_sequence -> Let let_binding seq(Attr) . In series [ End ]
##
## The known suffix of the stack is as follows:
## Let let_binding seq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 174, spurious reduction of production seq(Attr) ->
## In state 175, spurious reduction of production seq(Attr) -> Attr seq(Attr)
##
interactive_expr: Begin Let WILD EQ Bytes Attr Type
##
## Ends in an error in state: 482.
##
## let_in_sequence -> Let let_binding seq(Attr) . In series [ End ]
##
## The known suffix of the stack is as follows:
## Let let_binding seq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 174, spurious reduction of production seq(Attr) ->
## In state 175, spurious reduction of production seq(Attr) -> Attr seq(Attr)
##
interactive_expr: If Verbatim Then Let WILD EQ Bytes Attr Type
##
## Ends in an error in state: 526.
##
## let_expr(closed_if) -> Let let_binding seq(Attr) . In closed_if [ Else ]
## let_expr(expr) -> Let let_binding seq(Attr) . In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let let_binding seq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 174, spurious reduction of production seq(Attr) ->
## In state 175, spurious reduction of production seq(Attr) -> Attr seq(Attr)
##
interactive_expr: If Verbatim Then Match Verbatim With WILD ARROW Let WILD EQ Bytes Attr Type
##
## Ends in an error in state: 401.
##
## let_expr(base_cond) -> Let let_binding seq(Attr) . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
## let_expr(base_if_then_else) -> Let let_binding seq(Attr) . In base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Let let_binding seq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 174, spurious reduction of production seq(Attr) ->
## In state 175, spurious reduction of production seq(Attr) -> Attr seq(Attr)
##
interactive_expr: Let WILD EQ Bytes Attr Type
##
## Ends in an error in state: 578.
##
## let_expr(expr) -> Let let_binding seq(Attr) . In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let let_binding seq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 174, spurious reduction of production seq(Attr) ->
## In state 175, spurious reduction of production seq(Attr) -> Attr seq(Attr)
##
interactive_expr: Match Verbatim With WILD ARROW If Verbatim Then Let WILD EQ Bytes Attr Type
##
## Ends in an error in state: 381.
##
## let_expr(base_cond) -> Let let_binding seq(Attr) . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
## let_expr(closed_if) -> Let let_binding seq(Attr) . In closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## Let let_binding seq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 174, spurious reduction of production seq(Attr) ->
## In state 175, spurious reduction of production seq(Attr) -> Attr seq(Attr)
##
interactive_expr: Match Verbatim With WILD ARROW Let WILD EQ Bytes Attr Type
##
## Ends in an error in state: 432.
##
## let_expr(base_cond) -> Let let_binding seq(Attr) . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let let_binding seq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 174, spurious reduction of production seq(Attr) ->
## In state 175, spurious reduction of production seq(Attr) -> Attr seq(Attr)
##

Ill-formed let binding.

At this point, if the series of attributes is complete, the keyword
'in' is expected, followed by an expression.

interactive_expr: Begin If Verbatim Then Let WILD EQ Bytes With
##
## Ends in an error in state: 471.
##
## let_expr(closed_if) -> Let let_binding . seq(Attr) In closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 226, spurious reduction of production call_expr_level -> core_expr
## In state 233, spurious reduction of production unary_expr_level -> call_expr_level
## In state 220, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 223, spurious reduction of production add_expr_level -> mult_expr_level
## In state 313, spurious reduction of production cons_expr_level -> add_expr_level
## In state 303, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 335, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 342, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 349, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 370, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 372, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 373, spurious reduction of production expr -> base_cond__open(expr)
## In state 379, spurious reduction of production let_binding -> irrefutable option(type_annotation) EQ expr
##
interactive_expr: Begin Let WILD EQ Bytes With
##
## Ends in an error in state: 481.
##
## let_in_sequence -> Let let_binding . seq(Attr) In series [ End ]
##
## The known suffix of the stack is as follows:
## Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 226, spurious reduction of production call_expr_level -> core_expr
## In state 233, spurious reduction of production unary_expr_level -> call_expr_level
## In state 220, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 223, spurious reduction of production add_expr_level -> mult_expr_level
## In state 313, spurious reduction of production cons_expr_level -> add_expr_level
## In state 303, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 335, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 342, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 349, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 370, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 372, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 373, spurious reduction of production expr -> base_cond__open(expr)
## In state 379, spurious reduction of production let_binding -> irrefutable option(type_annotation) EQ expr
##
interactive_expr: Begin Match Verbatim With WILD ARROW Let WILD EQ Bytes With
##
## Ends in an error in state: 486.
##
## let_expr(base_cond) -> Let let_binding . seq(Attr) In base_cond [ VBAR ]
## let_in_sequence -> Let let_binding . seq(Attr) In series [ End ]
##
## The known suffix of the stack is as follows:
## Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 226, spurious reduction of production call_expr_level -> core_expr
## In state 233, spurious reduction of production unary_expr_level -> call_expr_level
## In state 220, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 223, spurious reduction of production add_expr_level -> mult_expr_level
## In state 313, spurious reduction of production cons_expr_level -> add_expr_level
## In state 303, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 335, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 342, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 349, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 370, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 372, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 373, spurious reduction of production expr -> base_cond__open(expr)
## In state 379, spurious reduction of production let_binding -> irrefutable option(type_annotation) EQ expr
##
interactive_expr: If Verbatim Then Match Verbatim With WILD ARROW Let WILD EQ Bytes With
##
## Ends in an error in state: 400.
##
## let_expr(base_cond) -> Let let_binding . seq(Attr) In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
## let_expr(base_if_then_else) -> Let let_binding . seq(Attr) In base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 226, spurious reduction of production call_expr_level -> core_expr
## In state 233, spurious reduction of production unary_expr_level -> call_expr_level
## In state 220, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 223, spurious reduction of production add_expr_level -> mult_expr_level
## In state 313, spurious reduction of production cons_expr_level -> add_expr_level
## In state 303, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 335, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 342, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 349, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 370, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 372, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 373, spurious reduction of production expr -> base_cond__open(expr)
## In state 379, spurious reduction of production let_binding -> irrefutable option(type_annotation) EQ expr
##
interactive_expr: If Verbatim Then Let WILD EQ Bytes With
##
## Ends in an error in state: 525.
##
## let_expr(closed_if) -> Let let_binding . seq(Attr) In closed_if [ Else ]
## let_expr(expr) -> Let let_binding . seq(Attr) In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 226, spurious reduction of production call_expr_level -> core_expr
## In state 233, spurious reduction of production unary_expr_level -> call_expr_level
## In state 220, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 223, spurious reduction of production add_expr_level -> mult_expr_level
## In state 313, spurious reduction of production cons_expr_level -> add_expr_level
## In state 303, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 335, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 342, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 349, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 370, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 372, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 373, spurious reduction of production expr -> base_cond__open(expr)
## In state 379, spurious reduction of production let_binding -> irrefutable option(type_annotation) EQ expr
##
interactive_expr: Let WILD EQ Bytes With
##
## Ends in an error in state: 577.
##
## let_expr(expr) -> Let let_binding . seq(Attr) In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 226, spurious reduction of production call_expr_level -> core_expr
## In state 233, spurious reduction of production unary_expr_level -> call_expr_level
## In state 220, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 223, spurious reduction of production add_expr_level -> mult_expr_level
## In state 313, spurious reduction of production cons_expr_level -> add_expr_level
## In state 303, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 335, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 342, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 349, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 370, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 372, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 373, spurious reduction of production expr -> base_cond__open(expr)
## In state 379, spurious reduction of production let_binding -> irrefutable option(type_annotation) EQ expr
##
interactive_expr: Match Verbatim With WILD ARROW If Verbatim Then Let WILD EQ Bytes With
##
## Ends in an error in state: 380.
##
## let_expr(base_cond) -> Let let_binding . seq(Attr) In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
## let_expr(closed_if) -> Let let_binding . seq(Attr) In closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 226, spurious reduction of production call_expr_level -> core_expr
## In state 233, spurious reduction of production unary_expr_level -> call_expr_level
## In state 220, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 223, spurious reduction of production add_expr_level -> mult_expr_level
## In state 313, spurious reduction of production cons_expr_level -> add_expr_level
## In state 303, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 335, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 342, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 349, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 370, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 372, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 373, spurious reduction of production expr -> base_cond__open(expr)
## In state 379, spurious reduction of production let_binding -> irrefutable option(type_annotation) EQ expr
##
interactive_expr: Match Verbatim With WILD ARROW Let WILD EQ Bytes With
##
## Ends in an error in state: 431.
##
## let_expr(base_cond) -> Let let_binding . seq(Attr) In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 226, spurious reduction of production call_expr_level -> core_expr
## In state 233, spurious reduction of production unary_expr_level -> call_expr_level
## In state 220, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 223, spurious reduction of production add_expr_level -> mult_expr_level
## In state 313, spurious reduction of production cons_expr_level -> add_expr_level
## In state 303, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 335, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 342, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 349, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 370, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 372, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 373, spurious reduction of production expr -> base_cond__open(expr)
## In state 379, spurious reduction of production let_binding -> irrefutable option(type_annotation) EQ expr
##

Ill-formed let binding.

At this point, if the right-hand side of the let binding is a complete
expression, one of the following is expected:
  * a series of attributes;
  * the keyword 'in', followed by an expression.

interactive_expr: Begin If Verbatim Then Let With
##
## Ends in an error in state: 456.
##
## let_expr(closed_if) -> Let . let_binding seq(Attr) In closed_if [ Else ]
## let_expr(closed_if) -> Let . Rec let_binding seq(Attr) In closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## Let
##
interactive_expr: Begin Let With
##
## Ends in an error in state: 448.
##
## let_in_sequence -> Let . let_binding seq(Attr) In series [ End ]
## let_in_sequence -> Let . Rec let_binding seq(Attr) In series [ End ]
##
## The known suffix of the stack is as follows:
## Let
##
interactive_expr: Begin Match Verbatim With WILD ARROW Let With
##
## Ends in an error in state: 259.
##
## let_expr(base_cond) -> Let . let_binding seq(Attr) In base_cond [ VBAR ]
## let_expr(base_cond) -> Let . Rec let_binding seq(Attr) In base_cond [ VBAR ]
## let_in_sequence -> Let . let_binding seq(Attr) In series [ End ]
## let_in_sequence -> Let . Rec let_binding seq(Attr) In series [ End ]
##
## The known suffix of the stack is as follows:
## Let
##
interactive_expr: If Verbatim Then Match Verbatim With WILD ARROW Let With
##
## Ends in an error in state: 273.
##
## let_expr(base_cond) -> Let . let_binding seq(Attr) In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
## let_expr(base_cond) -> Let . Rec let_binding seq(Attr) In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
## let_expr(base_if_then_else) -> Let . let_binding seq(Attr) In base_if_then_else [ Else ]
## let_expr(base_if_then_else) -> Let . Rec let_binding seq(Attr) In base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Let
##
interactive_expr: If Verbatim Then Let With
##
## Ends in an error in state: 507.
##
## let_expr(closed_if) -> Let . let_binding seq(Attr) In closed_if [ Else ]
## let_expr(closed_if) -> Let . Rec let_binding seq(Attr) In closed_if [ Else ]
## let_expr(expr) -> Let . let_binding seq(Attr) In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
## let_expr(expr) -> Let . Rec let_binding seq(Attr) In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let
##
interactive_expr: Let With
##
## Ends in an error in state: 171.
##
## let_expr(expr) -> Let . let_binding seq(Attr) In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
## let_expr(expr) -> Let . Rec let_binding seq(Attr) In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let
##
interactive_expr: Match Verbatim With WILD ARROW If Verbatim Then Let With
##
## Ends in an error in state: 281.
##
## let_expr(base_cond) -> Let . let_binding seq(Attr) In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
## let_expr(base_cond) -> Let . Rec let_binding seq(Attr) In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
## let_expr(closed_if) -> Let . let_binding seq(Attr) In closed_if [ Else ]
## let_expr(closed_if) -> Let . Rec let_binding seq(Attr) In closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## Let
##
interactive_expr: Match Verbatim With WILD ARROW Let With
##
## Ends in an error in state: 416.
##
## let_expr(base_cond) -> Let . let_binding seq(Attr) In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
## let_expr(base_cond) -> Let . Rec let_binding seq(Attr) In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let
##
contract: Let With
##
## Ends in an error in state: 62.
##
## let_declaration -> Let . let_binding seq(Attr) [ Type Let EOF ]
## let_declaration -> Let . Rec let_binding seq(Attr) [ Type Let EOF ]
##
## The known suffix of the stack is as follows:
## Let
##

Ill-formed let binding.

At this point, one of the following is expected:
  * an irrefutable pattern, for example: an identifier;
  * the 'rec' keyword if the let binding is recursive.

interactive_expr: Begin If Verbatim Then Match Verbatim Type
##
## Ends in an error in state: 268.
##
## match_expr(base_if_then_else) -> Match expr . With option(VBAR) cases(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## Match expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 226, spurious reduction of production call_expr_level -> core_expr
## In state 233, spurious reduction of production unary_expr_level -> call_expr_level
## In state 220, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 223, spurious reduction of production add_expr_level -> mult_expr_level
## In state 313, spurious reduction of production cons_expr_level -> add_expr_level
## In state 303, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 335, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 342, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 349, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 370, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 372, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 373, spurious reduction of production expr -> base_cond__open(expr)
##
interactive_expr: Begin Match Verbatim Type
##
## Ends in an error in state: 244.
##
## match_expr(last_expr) -> Match expr . With option(VBAR) cases(last_expr) [ End ]
##
## The known suffix of the stack is as follows:
## Match expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 226, spurious reduction of production call_expr_level -> core_expr
## In state 233, spurious reduction of production unary_expr_level -> call_expr_level
## In state 220, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 223, spurious reduction of production add_expr_level -> mult_expr_level
## In state 313, spurious reduction of production cons_expr_level -> add_expr_level
## In state 303, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 335, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 342, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 349, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 370, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 372, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 373, spurious reduction of production expr -> base_cond__open(expr)
##
interactive_expr: Match Verbatim Type
##
## Ends in an error in state: 587.
##
## match_expr(base_cond) -> Match expr . With option(VBAR) cases(base_cond) [ With Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## Match expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 226, spurious reduction of production call_expr_level -> core_expr
## In state 233, spurious reduction of production unary_expr_level -> call_expr_level
## In state 220, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 223, spurious reduction of production add_expr_level -> mult_expr_level
## In state 313, spurious reduction of production cons_expr_level -> add_expr_level
## In state 303, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 335, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 342, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 349, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 370, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 372, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 373, spurious reduction of production expr -> base_cond__open(expr)
##
interactive_expr: If Verbatim Then Match Verbatim Type
##
## Ends in an error in state: 503.
##
## match_expr(base_cond) -> Match expr . With option(VBAR) cases(base_cond) [ With Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
## match_expr(base_if_then_else) -> Match expr . With option(VBAR) cases(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## Match expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 226, spurious reduction of production call_expr_level -> core_expr
## In state 233, spurious reduction of production unary_expr_level -> call_expr_level
## In state 220, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 223, spurious reduction of production add_expr_level -> mult_expr_level
## In state 313, spurious reduction of production cons_expr_level -> add_expr_level
## In state 303, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 335, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 342, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 349, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 370, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 372, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 373, spurious reduction of production expr -> base_cond__open(expr)
##

Ill-formed pattern matching.

At this point, if the matched expression is complete, then the keyword
'with' is expected, followed by matching cases.

interactive_expr: Begin If Verbatim Then Match Verbatim With WILD ARROW Bytes With
##
## Ends in an error in state: 408.
##
## cases(base_cond) -> cases(base_cond) . VBAR case_clause(base_cond) [ VBAR ]
## cases(base_if_then_else) -> cases(base_cond) . VBAR case_clause(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## cases(base_cond)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 226, spurious reduction of production call_expr_level -> core_expr
## In state 233, spurious reduction of production unary_expr_level -> call_expr_level
## In state 220, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 223, spurious reduction of production add_expr_level -> mult_expr_level
## In state 313, spurious reduction of production cons_expr_level -> add_expr_level
## In state 303, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 335, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 342, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 349, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 394, spurious reduction of production base_expr(base_cond) -> disj_expr_level
## In state 358, spurious reduction of production base_cond__open(base_cond) -> base_expr(base_cond)
## In state 359, spurious reduction of production base_cond -> base_cond__open(base_cond)
## In state 405, spurious reduction of production case_clause(base_cond) -> pattern ARROW base_cond
## In state 413, spurious reduction of production cases(base_cond) -> case_clause(base_cond)
##
interactive_expr: Begin Match Verbatim With WILD ARROW Verbatim COMMA Bytes With
##
## Ends in an error in state: 491.
##
## cases(base_cond) -> cases(base_cond) . VBAR case_clause(base_cond) [ VBAR ]
## cases(last_expr) -> cases(base_cond) . VBAR case_clause(last_expr) [ End ]
##
## The known suffix of the stack is as follows:
## cases(base_cond)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 226, spurious reduction of production call_expr_level -> core_expr
## In state 233, spurious reduction of production unary_expr_level -> call_expr_level
## In state 220, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 223, spurious reduction of production add_expr_level -> mult_expr_level
## In state 313, spurious reduction of production cons_expr_level -> add_expr_level
## In state 303, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 335, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 342, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 349, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 346, spurious reduction of production nsepseq(disj_expr_level,COMMA) -> disj_expr_level
## In state 345, spurious reduction of production tuple(disj_expr_level) -> disj_expr_level COMMA nsepseq(disj_expr_level,COMMA)
## In state 222, spurious reduction of production tuple_expr -> tuple(disj_expr_level)
## In state 429, spurious reduction of production base_expr(base_cond) -> tuple_expr
## In state 358, spurious reduction of production base_cond__open(base_cond) -> base_expr(base_cond)
## In state 359, spurious reduction of production base_cond -> base_cond__open(base_cond)
## In state 405, spurious reduction of production case_clause(base_cond) -> pattern ARROW base_cond
## In state 413, spurious reduction of production cases(base_cond) -> case_clause(base_cond)
##

Ill-formed pattern matching.

At this point, if the case is complete, then a vertical bar '|' is
expected, followed by another case.

interactive_expr: Begin If Verbatim Then If With
##
## Ends in an error in state: 461.
##
## if_then_else(closed_if) -> If . expr Then closed_if Else closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## If
##
interactive_expr: Begin If With
##
## Ends in an error in state: 453.
##
## if_then_else(seq_expr) -> If . expr Then closed_if Else seq_expr [ SEMI End ]
##
## The known suffix of the stack is as follows:
## If
##
interactive_expr: If Verbatim Then If With
##
## Ends in an error in state: 512.
##
## if_then(expr) -> If . expr Then expr [ With Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
## if_then_else(closed_if) -> If . expr Then closed_if Else closed_if [ Else ]
## if_then_else(expr) -> If . expr Then closed_if Else expr [ With Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## If
##
interactive_expr: If Verbatim Then Match Verbatim With WILD ARROW If With
##
## Ends in an error in state: 278.
##
## if_then(base_cond) -> If . expr Then base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
## if_then_else(base_cond) -> If . expr Then closed_if Else base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
## if_then_else(base_if_then_else) -> If . expr Then closed_if Else base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## If
##
interactive_expr: If With
##
## Ends in an error in state: 183.
##
## if_then(expr) -> If . expr Then expr [ With Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
## if_then_else(expr) -> If . expr Then closed_if Else expr [ With Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## If
##
interactive_expr: Match Verbatim With WILD ARROW If With
##
## Ends in an error in state: 421.
##
## if_then(base_cond) -> If . expr Then base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
## if_then_else(base_cond) -> If . expr Then closed_if Else base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## If
##

Ill-formed conditional expression.

At this point, a test expression is expected.

interactive_expr: Begin Match Verbatim With WILD ARROW Verbatim With
##
## Ends in an error in state: 436.
##
## base_expr(base_cond) -> disj_expr_level . [ VBAR ]
## bin_op(disj_expr_level,BOOL_OR,conj_expr_level) -> disj_expr_level . BOOL_OR conj_expr_level [ VBAR SEMI Or End COMMA BOOL_OR ]
## bin_op(disj_expr_level,Or,conj_expr_level) -> disj_expr_level . Or conj_expr_level [ VBAR SEMI Or End COMMA BOOL_OR ]
## seq_expr -> disj_expr_level . [ SEMI End ]
## tuple(disj_expr_level) -> disj_expr_level . COMMA nsepseq(disj_expr_level,COMMA) [ VBAR ]
##
## The known suffix of the stack is as follows:
## disj_expr_level
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 226, spurious reduction of production call_expr_level -> core_expr
## In state 233, spurious reduction of production unary_expr_level -> call_expr_level
## In state 220, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 223, spurious reduction of production add_expr_level -> mult_expr_level
## In state 313, spurious reduction of production cons_expr_level -> add_expr_level
## In state 303, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 335, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 342, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 349, spurious reduction of production disj_expr_level -> conj_expr_level
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Begin Match Verbatim With WILD ARROW With
##
## Ends in an error in state: 258.
##
## case_clause(base_cond) -> pattern ARROW . base_cond [ VBAR ]
## case_clause(last_expr) -> pattern ARROW . last_expr [ End ]
##
## The known suffix of the stack is as follows:
## pattern ARROW
##
interactive_expr: If Verbatim Then Match Verbatim With WILD ARROW With
##
## Ends in an error in state: 272.
##
## case_clause(base_cond) -> pattern ARROW . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
## case_clause(base_if_then_else) -> pattern ARROW . base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## pattern ARROW
##
interactive_expr: Match Verbatim With WILD ARROW With
##
## Ends in an error in state: 591.
##
## case_clause(base_cond) -> pattern ARROW . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## pattern ARROW
##

Ill-formed pattern matching.

At this point, the right-hand side of the case is expected as an
expression.

interactive_expr: Begin Match Verbatim With WILD CONS Bytes SEMI
##
## Ends in an error in state: 257.
##
## case_clause(base_cond) -> pattern . ARROW base_cond [ VBAR ]
## case_clause(last_expr) -> pattern . ARROW last_expr [ End ]
##
## The known suffix of the stack is as follows:
## pattern
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 97, spurious reduction of production tail -> sub_pattern
## In state 251, spurious reduction of production pattern -> sub_pattern CONS tail
##
interactive_expr: If Verbatim Then Match Verbatim With WILD CONS Bytes SEMI
##
## Ends in an error in state: 271.
##
## case_clause(base_cond) -> pattern . ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
## case_clause(base_if_then_else) -> pattern . ARROW base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## pattern
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 97, spurious reduction of production tail -> sub_pattern
## In state 251, spurious reduction of production pattern -> sub_pattern CONS tail
##
interactive_expr: Match Verbatim With WILD CONS Bytes SEMI
##
## Ends in an error in state: 590.
##
## case_clause(base_cond) -> pattern . ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## pattern
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 97, spurious reduction of production tail -> sub_pattern
## In state 251, spurious reduction of production pattern -> sub_pattern CONS tail
##

Ill-formed pattern matching.

At this point, if the pattern is complete, then an arrow '->' is
expected, followed by the right-hand side of the case as an
expression.

interactive_expr: Begin If Verbatim Then Match Verbatim With With
##
## Ends in an error in state: 269.
##
## match_expr(base_if_then_else) -> Match expr With . option(VBAR) cases(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## Match expr With
##
interactive_expr: Begin Match Verbatim With WILD ARROW Bytes VBAR With
##
## Ends in an error in state: 492.
##
## cases(base_cond) -> cases(base_cond) VBAR . case_clause(base_cond) [ VBAR ]
## cases(last_expr) -> cases(base_cond) VBAR . case_clause(last_expr) [ End ]
##
## The known suffix of the stack is as follows:
## cases(base_cond) VBAR
##
interactive_expr: Begin If Verbatim Then Match Verbatim With VBAR Begin
##
## Ends in an error in state: 270.
##
## match_expr(base_if_then_else) -> Match expr With option(VBAR) . cases(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## Match expr With option(VBAR)
##
interactive_expr: Begin Match Verbatim With VBAR Begin
##
## Ends in an error in state: 247.
##
## match_expr(last_expr) -> Match expr With option(VBAR) . cases(last_expr) [ End ]
##
## The known suffix of the stack is as follows:
## Match expr With option(VBAR)
##
interactive_expr: Begin Match Verbatim With With
##
## Ends in an error in state: 245.
##
## match_expr(last_expr) -> Match expr With . option(VBAR) cases(last_expr) [ End ]
##
## The known suffix of the stack is as follows:
## Match expr With
##
interactive_expr: If Verbatim Then Match Verbatim With With
##
## Ends in an error in state: 504.
##
## match_expr(base_cond) -> Match expr With . option(VBAR) cases(base_cond) [ With Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
## match_expr(base_if_then_else) -> Match expr With . option(VBAR) cases(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## Match expr With
##
interactive_expr: If Verbatim Then Match Verbatim With VBAR Begin
##
## Ends in an error in state: 505.
##
## match_expr(base_cond) -> Match expr With option(VBAR) . cases(base_cond) [ With Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
## match_expr(base_if_then_else) -> Match expr With option(VBAR) . cases(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## Match expr With option(VBAR)
##
interactive_expr: If Verbatim Then Match Verbatim With WILD ARROW Bytes VBAR With
##
## Ends in an error in state: 409.
##
## cases(base_cond) -> cases(base_cond) VBAR . case_clause(base_cond) [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
## cases(base_if_then_else) -> cases(base_cond) VBAR . case_clause(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## cases(base_cond) VBAR
##
interactive_expr: Match Verbatim With VBAR Begin
##
## Ends in an error in state: 589.
##
## match_expr(base_cond) -> Match expr With option(VBAR) . cases(base_cond) [ With Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## Match expr With option(VBAR)
##
interactive_expr: Match Verbatim With WILD ARROW Bytes VBAR With
##
## Ends in an error in state: 593.
##
## cases(base_cond) -> cases(base_cond) VBAR . case_clause(base_cond) [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## cases(base_cond) VBAR
##
interactive_expr: Match Verbatim With With
##
## Ends in an error in state: 588.
##
## match_expr(base_cond) -> Match expr With . option(VBAR) cases(base_cond) [ With Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## Match expr With
##

Ill-formed pattern matching.

At this point, a case is expected to start with a pattern.

interactive_expr: Begin Match With
##
## Ends in an error in state: 206.
##
## match_expr(last_expr) -> Match . expr With option(VBAR) cases(last_expr) [ End ]
##
## The known suffix of the stack is as follows:
## Match
##
interactive_expr: Begin If Verbatim Then Match With
##
## Ends in an error in state: 267.
##
## match_expr(base_if_then_else) -> Match . expr With option(VBAR) cases(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## Match
##
interactive_expr: If Verbatim Then Match With
##
## Ends in an error in state: 502.
##
## match_expr(base_cond) -> Match . expr With option(VBAR) cases(base_cond) [ With Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
## match_expr(base_if_then_else) -> Match . expr With option(VBAR) cases(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## Match
##
interactive_expr: Match With
##
## Ends in an error in state: 168.
##
## match_expr(base_cond) -> Match . expr With option(VBAR) cases(base_cond) [ With Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## Match
##

Ill-formed pattern matching.

At this point, the expression to be matched is expected.

interactive_expr: Begin Verbatim SEMI With
##
## Ends in an error in state: 447.
##
## series -> seq_expr SEMI . series [ End ]
##
## The known suffix of the stack is as follows:
## seq_expr SEMI
##

Ill-formed sequence expression.

At this point, another expression is expected.

interactive_expr: Begin Verbatim With
##
## Ends in an error in state: 476.
##
## bin_op(disj_expr_level,BOOL_OR,conj_expr_level) -> disj_expr_level . BOOL_OR conj_expr_level [ SEMI Or End BOOL_OR ]
## bin_op(disj_expr_level,Or,conj_expr_level) -> disj_expr_level . Or conj_expr_level [ SEMI Or End BOOL_OR ]
## seq_expr -> disj_expr_level . [ SEMI End ]
##
## The known suffix of the stack is as follows:
## disj_expr_level
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 226, spurious reduction of production call_expr_level -> core_expr
## In state 233, spurious reduction of production unary_expr_level -> call_expr_level
## In state 220, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 223, spurious reduction of production add_expr_level -> mult_expr_level
## In state 313, spurious reduction of production cons_expr_level -> add_expr_level
## In state 303, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 335, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 342, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 349, spurious reduction of production disj_expr_level -> conj_expr_level
##

Ill-formed sequence of expressions.

At this point, if the expression is complete, one of the following is
expected:
  * an operator;
  * a semicolon ';', followed by another expression, if the expression
    has type unit;
  * the keyword 'end' if the sequence is complete.

interactive_expr: Begin With
##
## Ends in an error in state: 205.
##
## sequence -> Begin . option(series) End [ With Verbatim VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Mod MINUS Let Lang LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Constr CONS COMMA COLON CAT Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## Begin
##

Ill-formed sequence of expressions.

At this point, one of the following is expected:
  * the first expression;
  * the keyword 'end' if the sequence is empty.

interactive_expr: C_None WILD
##
## Ends in an error in state: 223.
##
## add_expr_level -> mult_expr_level . [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE PLUS Or NE MINUS Let LT LE In GT GE End Else EQ EOF CONS COMMA COLON CAT BOOL_OR BOOL_AND Attr ]
## bin_op(mult_expr_level,Mod,unary_expr_level) -> mult_expr_level . Mod unary_expr_level [ With VBAR Type Then TIMES SLASH SEMI RPAR RBRACKET RBRACE PLUS Or NE Mod MINUS Let LT LE In GT GE End Else EQ EOF CONS COMMA COLON CAT BOOL_OR BOOL_AND Attr ]
## bin_op(mult_expr_level,SLASH,unary_expr_level) -> mult_expr_level . SLASH unary_expr_level [ With VBAR Type Then TIMES SLASH SEMI RPAR RBRACKET RBRACE PLUS Or NE Mod MINUS Let LT LE In GT GE End Else EQ EOF CONS COMMA COLON CAT BOOL_OR BOOL_AND Attr ]
## bin_op(mult_expr_level,TIMES,unary_expr_level) -> mult_expr_level . TIMES unary_expr_level [ With VBAR Type Then TIMES SLASH SEMI RPAR RBRACKET RBRACE PLUS Or NE Mod MINUS Let LT LE In GT GE End Else EQ EOF CONS COMMA COLON CAT BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## mult_expr_level
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: C_Some With
##
## Ends in an error in state: 207.
##
## constr_expr -> C_Some . core_expr [ With VBAR Type Then TIMES SLASH SEMI RPAR RBRACKET RBRACE PLUS Or NE Mod MINUS Let LT LE In GT GE End Else EQ EOF CONS COMMA COLON CAT BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## C_Some
##

Ill-formed application of the data constructor 'Some'.

At this point, its argument is expected in the form of an expression.

interactive_expr: Constr DOT Ident WILD
##
## Ends in an error in state: 199.
##
## module_fun -> Ident . [ With Verbatim VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Mod MINUS Let Lang LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Constr CONS COMMA COLON CAT Bytes Begin BOOL_OR BOOL_AND Attr ]
## projection -> Constr DOT Ident . DOT nsepseq(selection,DOT) [ With Verbatim VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Mod MINUS Let Lang LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Constr CONS COMMA COLON CAT Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## Constr DOT Ident
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Constr DOT With
##
## Ends in an error in state: 197.
##
## module_field -> Constr DOT . module_fun [ With Verbatim VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Mod MINUS Let Lang LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Constr CONS COMMA COLON CAT Bytes Begin BOOL_OR BOOL_AND Attr ]
## projection -> Constr DOT . Ident DOT nsepseq(selection,DOT) [ With Verbatim VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Mod MINUS Let Lang LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Constr CONS COMMA COLON CAT Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## Constr DOT
##
interactive_expr: LBRACE Constr DOT With
##
## Ends in an error in state: 533.
##
## projection -> Constr DOT . Ident DOT nsepseq(selection,DOT) [ With EQ ]
##
## The known suffix of the stack is as follows:
## Constr DOT
##
contract: Type Ident EQ Constr DOT With
##
## Ends in an error in state: 14.
##
## core_type -> Constr DOT . Ident [ VBAR Type TIMES SEMI RPAR RBRACE Let Ident EQ EOF COMMA ARROW ]
##
## The known suffix of the stack is as follows:
## Constr DOT
##

Ill-formed selection in a module.

At this point, a field name is expected.

interactive_expr: Constr WILD
##
## Ends in an error in state: 196.
##
## constr_expr -> Constr . core_expr [ With VBAR Type Then TIMES SLASH SEMI RPAR RBRACKET RBRACE PLUS Or NE Mod MINUS Let LT LE In GT GE End Else EQ EOF CONS COMMA COLON CAT BOOL_OR BOOL_AND Attr ]
## constr_expr -> Constr . [ With VBAR Type Then TIMES SLASH SEMI RPAR RBRACKET RBRACE PLUS Or NE Mod MINUS Let LT LE In GT GE End Else EQ EOF CONS COMMA COLON CAT BOOL_OR BOOL_AND Attr ]
## module_field -> Constr . DOT module_fun [ With Verbatim VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Mod MINUS Let Lang LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Constr CONS COMMA COLON CAT Bytes Begin BOOL_OR BOOL_AND Attr ]
## projection -> Constr . DOT Ident DOT nsepseq(selection,DOT) [ With Verbatim VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Mod MINUS Let Lang LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Constr CONS COMMA COLON CAT Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## Constr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Fun WILD RPAR
##
## Ends in an error in state: 361.
##
## nseq(irrefutable) -> irrefutable . seq(irrefutable) [ ARROW ]
##
## The known suffix of the stack is as follows:
## irrefutable
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 136, spurious reduction of production irrefutable -> sub_irrefutable
##
interactive_expr: Fun WILD WILD RPAR
##
## Ends in an error in state: 363.
##
## seq(irrefutable) -> irrefutable . seq(irrefutable) [ ARROW ]
##
## The known suffix of the stack is as follows:
## irrefutable
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 136, spurious reduction of production irrefutable -> sub_irrefutable
##

Ill-formed function expression.

At this point, if the parameter is complete, one of the following is
expected:
  * another parameter as an irrefutable pattern, e.g. a variable;
  * an arrow '->', followed by the function body in the form of an expression.

interactive_expr: Constr DOT Ident DOT With
##
## Ends in an error in state: 200.
##
## projection -> Constr DOT Ident DOT . nsepseq(selection,DOT) [ With Verbatim VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Mod MINUS Let Lang LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Constr CONS COMMA COLON CAT Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## Constr DOT Ident DOT
##
interactive_expr: Ident DOT Int DOT With
##
## Ends in an error in state: 189.
##
## nsepseq(selection,DOT) -> selection DOT . nsepseq(selection,DOT) [ With Verbatim VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Mod MINUS Let Lang LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Constr CONS COMMA COLON CAT Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## selection DOT
##
interactive_expr: Ident DOT With
##
## Ends in an error in state: 185.
##
## projection -> Ident DOT . nsepseq(selection,DOT) [ With Verbatim VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Mod MINUS Let Lang LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Constr CONS COMMA COLON CAT Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## Ident DOT
##

Ill-formed selection in a record or a tuple.

At this point, one of the following is expected:
  * a record field name;
  * a tuple index as a literal integer greater than or equal to 0.

interactive_expr: Ident WILD
##
## Ends in an error in state: 184.
##
## core_expr -> Ident . [ With Verbatim VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Mod MINUS Let Lang LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Constr CONS COMMA COLON CAT Bytes Begin BOOL_OR BOOL_AND Attr ]
## projection -> Ident . DOT nsepseq(selection,DOT) [ With Verbatim VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Mod MINUS Let Lang LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Constr CONS COMMA COLON CAT Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## Ident
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Begin Fun With
##
## Ends in an error in state: 477.
##
## fun_expr(last_expr) -> Fun . nseq(irrefutable) ARROW last_expr [ End ]
##
## The known suffix of the stack is as follows:
## Fun
##
interactive_expr: Begin Match Verbatim With WILD ARROW Fun With
##
## Ends in an error in state: 437.
##
## fun_expr(base_cond) -> Fun . nseq(irrefutable) ARROW base_cond [ VBAR ]
## fun_expr(last_expr) -> Fun . nseq(irrefutable) ARROW last_expr [ End ]
##
## The known suffix of the stack is as follows:
## Fun
##
interactive_expr: Fun With
##
## Ends in an error in state: 192.
##
## fun_expr(expr) -> Fun . nseq(irrefutable) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun
##
interactive_expr: If Verbatim Then Fun With
##
## Ends in an error in state: 515.
##
## fun_expr(closed_if) -> Fun . nseq(irrefutable) ARROW closed_if [ Else ]
## fun_expr(expr) -> Fun . nseq(irrefutable) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun
##
interactive_expr: Begin If Verbatim Then Fun With
##
## Ends in an error in state: 464.
##
## fun_expr(closed_if) -> Fun . nseq(irrefutable) ARROW closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## Fun
##
interactive_expr: If Verbatim Then Match Verbatim With WILD ARROW Fun With
##
## Ends in an error in state: 387.
##
## fun_expr(base_cond) -> Fun . nseq(irrefutable) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
## fun_expr(base_if_then_else) -> Fun . nseq(irrefutable) ARROW base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Fun
##
interactive_expr: Match Verbatim With WILD ARROW Fun With
##
## Ends in an error in state: 426.
##
## fun_expr(base_cond) -> Fun . nseq(irrefutable) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun
##
interactive_expr: Match Verbatim With WILD ARROW If Verbatim Then Fun With
##
## Ends in an error in state: 289.
##
## fun_expr(base_cond) -> Fun . nseq(irrefutable) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
## fun_expr(closed_if) -> Fun . nseq(irrefutable) ARROW closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## Fun
##

Ill-formed function expression.

At this point, the first parameter is expected as an irrefutable
pattern, for example a variable.

interactive_expr: Begin If Verbatim Then If Verbatim Then Verbatim Else With
##
## Ends in an error in state: 470.
##
## if_then_else(closed_if) -> If expr Then closed_if Else . closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_if Else
##
interactive_expr: Begin If Verbatim Then Verbatim Else With
##
## Ends in an error in state: 475.
##
## if_then_else(seq_expr) -> If expr Then closed_if Else . seq_expr [ SEMI End ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_if Else
##
interactive_expr: Begin Match Verbatim With WILD ARROW If Verbatim Then Verbatim Else With
##
## Ends in an error in state: 415.
##
## if_then_else(base_cond) -> If expr Then closed_if Else . base_cond [ VBAR ]
## if_then_else(seq_expr) -> If expr Then closed_if Else . seq_expr [ SEMI End ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_if Else
##
interactive_expr: If Verbatim Then If Verbatim Then Verbatim Else With
##
## Ends in an error in state: 522.
##
## if_then_else(closed_if) -> If expr Then closed_if Else . closed_if [ Else ]
## if_then_else(expr) -> If expr Then closed_if Else . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_if Else
##
interactive_expr: If Verbatim Then Match Verbatim With WILD ARROW If Verbatim Then Verbatim Else With
##
## Ends in an error in state: 386.
##
## if_then_else(base_cond) -> If expr Then closed_if Else . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
## if_then_else(base_if_then_else) -> If expr Then closed_if Else . base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_if Else
##
interactive_expr: If Verbatim Then Verbatim Else With
##
## Ends in an error in state: 530.
##
## if_then_else(expr) -> If expr Then closed_if Else . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_if Else
##
interactive_expr: Match Verbatim With WILD ARROW If Verbatim Then If Verbatim Then Verbatim Else With
##
## Ends in an error in state: 366.
##
## if_then_else(base_cond) -> If expr Then closed_if Else . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
## if_then_else(closed_if) -> If expr Then closed_if Else . closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_if Else
##
interactive_expr: Match Verbatim With WILD ARROW If Verbatim Then Verbatim Else With
##
## Ends in an error in state: 425.
##
## if_then_else(base_cond) -> If expr Then closed_if Else . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_if Else
##

Ill-formed conditional expression.

At this point, the 'else' branch is expected in the form of an expression.

interactive_expr: Begin If Verbatim Then If Verbatim Then With
##
## Ends in an error in state: 463.
##
## if_then_else(closed_if) -> If expr Then . closed_if Else closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## If expr Then
##
interactive_expr: Begin If Verbatim Then With
##
## Ends in an error in state: 455.
##
## if_then_else(seq_expr) -> If expr Then . closed_if Else seq_expr [ SEMI End ]
##
## The known suffix of the stack is as follows:
## If expr Then
##
interactive_expr: Begin Match Verbatim With WILD ARROW If Verbatim Then With
##
## Ends in an error in state: 266.
##
## if_then(base_cond) -> If expr Then . base_cond [ VBAR ]
## if_then_else(base_cond) -> If expr Then . closed_if Else base_cond [ VBAR ]
## if_then_else(seq_expr) -> If expr Then . closed_if Else seq_expr [ SEMI End ]
##
## The known suffix of the stack is as follows:
## If expr Then
##
interactive_expr: If Verbatim Then If Verbatim Then With
##
## Ends in an error in state: 514.
##
## if_then(expr) -> If expr Then . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
## if_then_else(closed_if) -> If expr Then . closed_if Else closed_if [ Else ]
## if_then_else(expr) -> If expr Then . closed_if Else expr [ With Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## If expr Then
##
interactive_expr: If Verbatim Then Match Verbatim With WILD ARROW If Verbatim Then With
##
## Ends in an error in state: 280.
##
## if_then(base_cond) -> If expr Then . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
## if_then_else(base_cond) -> If expr Then . closed_if Else base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
## if_then_else(base_if_then_else) -> If expr Then . closed_if Else base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## If expr Then
##
interactive_expr: If Verbatim Then With
##
## Ends in an error in state: 501.
##
## if_then(expr) -> If expr Then . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
## if_then_else(expr) -> If expr Then . closed_if Else expr [ With Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## If expr Then
##
interactive_expr: Match Verbatim With WILD ARROW If Verbatim Then If Verbatim Then With
##
## Ends in an error in state: 288.
##
## if_then(base_cond) -> If expr Then . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
## if_then_else(base_cond) -> If expr Then . closed_if Else base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
## if_then_else(closed_if) -> If expr Then . closed_if Else closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## If expr Then
##
interactive_expr: Match Verbatim With WILD ARROW If Verbatim Then With
##
## Ends in an error in state: 423.
##
## if_then(base_cond) -> If expr Then . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
## if_then_else(base_cond) -> If expr Then . closed_if Else base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## If expr Then
##

Ill-formed conditional expression.

At this point, the 'then' branch is expected in the form of an expression.

interactive_expr: Begin Match Verbatim With WILD ARROW If With
##
## Ends in an error in state: 264.
##
## if_then(base_cond) -> If . expr Then base_cond [ VBAR ]
## if_then_else(base_cond) -> If . expr Then closed_if Else base_cond [ VBAR ]
## if_then_else(seq_expr) -> If . expr Then closed_if Else seq_expr [ SEMI End ]
##
## The known suffix of the stack is as follows:
## If
##
interactive_expr: Match Verbatim With WILD ARROW If Verbatim Then If With
##
## Ends in an error in state: 286.
##
## if_then(base_cond) -> If . expr Then base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
## if_then_else(base_cond) -> If . expr Then closed_if Else base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
## if_then_else(closed_if) -> If . expr Then closed_if Else closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## If
##

Ill-formed conditional expression.

At this point, a test expression is expected.

interactive_expr: Begin If Verbatim Then Let Rec WILD EQ Bytes In With
##
## Ends in an error in state: 460.
##
## let_expr(closed_if) -> Let Rec let_binding seq(Attr) In . closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding seq(Attr) In
##
interactive_expr: Begin Let Rec WILD EQ Bytes In With
##
## Ends in an error in state: 452.
##
## let_in_sequence -> Let Rec let_binding seq(Attr) In . series [ End ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding seq(Attr) In
##
interactive_expr: Begin Match Verbatim With WILD ARROW Let Rec WILD EQ Bytes In With
##
## Ends in an error in state: 263.
##
## let_expr(base_cond) -> Let Rec let_binding seq(Attr) In . base_cond [ VBAR ]
## let_in_sequence -> Let Rec let_binding seq(Attr) In . series [ End ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding seq(Attr) In
##
interactive_expr: If Verbatim Then Let Rec WILD EQ Bytes In With
##
## Ends in an error in state: 511.
##
## let_expr(closed_if) -> Let Rec let_binding seq(Attr) In . closed_if [ Else ]
## let_expr(expr) -> Let Rec let_binding seq(Attr) In . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding seq(Attr) In
##
interactive_expr: If Verbatim Then Match Verbatim With WILD ARROW Let Rec WILD EQ Bytes In With
##
## Ends in an error in state: 277.
##
## let_expr(base_cond) -> Let Rec let_binding seq(Attr) In . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
## let_expr(base_if_then_else) -> Let Rec let_binding seq(Attr) In . base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding seq(Attr) In
##
interactive_expr: Let Rec WILD EQ Bytes In With
##
## Ends in an error in state: 177.
##
## let_expr(expr) -> Let Rec let_binding seq(Attr) In . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding seq(Attr) In
##
interactive_expr: Match Verbatim With WILD ARROW If Verbatim Then Let Rec WILD EQ Bytes In With
##
## Ends in an error in state: 285.
##
## let_expr(base_cond) -> Let Rec let_binding seq(Attr) In . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
## let_expr(closed_if) -> Let Rec let_binding seq(Attr) In . closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding seq(Attr) In
##
interactive_expr: Match Verbatim With WILD ARROW Let Rec WILD EQ Bytes In With
##
## Ends in an error in state: 420.
##
## let_expr(base_cond) -> Let Rec let_binding seq(Attr) In . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding seq(Attr) In
##
interactive_expr: Begin If Verbatim Then Let WILD EQ Bytes In With
##
## Ends in an error in state: 473.
##
## let_expr(closed_if) -> Let let_binding seq(Attr) In . closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## Let let_binding seq(Attr) In
##
interactive_expr: Begin Let WILD EQ Bytes In With
##
## Ends in an error in state: 483.
##
## let_in_sequence -> Let let_binding seq(Attr) In . series [ End ]
##
## The known suffix of the stack is as follows:
## Let let_binding seq(Attr) In
##
interactive_expr: If Verbatim Then Let WILD EQ Bytes In With
##
## Ends in an error in state: 527.
##
## let_expr(closed_if) -> Let let_binding seq(Attr) In . closed_if [ Else ]
## let_expr(expr) -> Let let_binding seq(Attr) In . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let let_binding seq(Attr) In
##
interactive_expr: If Verbatim Then Match Verbatim With WILD ARROW Let WILD EQ Bytes In With
##
## Ends in an error in state: 402.
##
## let_expr(base_cond) -> Let let_binding seq(Attr) In . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
## let_expr(base_if_then_else) -> Let let_binding seq(Attr) In . base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Let let_binding seq(Attr) In
##
interactive_expr: Begin Match Verbatim With WILD ARROW Let WILD EQ Bytes In With
##
## Ends in an error in state: 488.
##
## let_expr(base_cond) -> Let let_binding seq(Attr) In . base_cond [ VBAR ]
## let_in_sequence -> Let let_binding seq(Attr) In . series [ End ]
##
## The known suffix of the stack is as follows:
## Let let_binding seq(Attr) In
##
interactive_expr: Let WILD EQ Bytes In With
##
## Ends in an error in state: 579.
##
## let_expr(expr) -> Let let_binding seq(Attr) In . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let let_binding seq(Attr) In
##
interactive_expr: Match Verbatim With WILD ARROW If Verbatim Then Let WILD EQ Bytes In With
##
## Ends in an error in state: 382.
##
## let_expr(base_cond) -> Let let_binding seq(Attr) In . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
## let_expr(closed_if) -> Let let_binding seq(Attr) In . closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## Let let_binding seq(Attr) In
##
interactive_expr: Match Verbatim With WILD ARROW Let WILD EQ Bytes In With
##
## Ends in an error in state: 433.
##
## let_expr(base_cond) -> Let let_binding seq(Attr) In . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let let_binding seq(Attr) In
##

Ill-formed let binding.

At this point, an expression is expected.

interactive_expr: If Verbatim Then Match Verbatim With WILD ARROW Verbatim End
##
## Ends in an error in state: 394.
##
## base_expr(base_cond) -> disj_expr_level . [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
## base_expr(base_if_then_else) -> disj_expr_level . [ Else ]
## bin_op(disj_expr_level,BOOL_OR,conj_expr_level) -> disj_expr_level . BOOL_OR conj_expr_level [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Or Let In Else EOF COMMA COLON BOOL_OR Attr ]
## bin_op(disj_expr_level,Or,conj_expr_level) -> disj_expr_level . Or conj_expr_level [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Or Let In Else EOF COMMA COLON BOOL_OR Attr ]
## tuple(disj_expr_level) -> disj_expr_level . COMMA nsepseq(disj_expr_level,COMMA) [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In Else EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## disj_expr_level
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 226, spurious reduction of production call_expr_level -> core_expr
## In state 233, spurious reduction of production unary_expr_level -> call_expr_level
## In state 220, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 223, spurious reduction of production add_expr_level -> mult_expr_level
## In state 313, spurious reduction of production cons_expr_level -> add_expr_level
## In state 303, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 335, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 342, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 349, spurious reduction of production disj_expr_level -> conj_expr_level
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: If Verbatim Then Verbatim COMMA Bytes VBAR
##
## Ends in an error in state: 518.
##
## base_expr(closed_if) -> tuple_expr . [ Else ]
## base_expr(expr) -> tuple_expr . [ With Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## tuple_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 226, spurious reduction of production call_expr_level -> core_expr
## In state 233, spurious reduction of production unary_expr_level -> call_expr_level
## In state 220, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 223, spurious reduction of production add_expr_level -> mult_expr_level
## In state 313, spurious reduction of production cons_expr_level -> add_expr_level
## In state 303, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 335, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 342, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 349, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 346, spurious reduction of production nsepseq(disj_expr_level,COMMA) -> disj_expr_level
## In state 345, spurious reduction of production tuple(disj_expr_level) -> disj_expr_level COMMA nsepseq(disj_expr_level,COMMA)
## In state 222, spurious reduction of production tuple_expr -> tuple(disj_expr_level)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: If Verbatim Then Verbatim VBAR
##
## Ends in an error in state: 519.
##
## base_expr(closed_if) -> disj_expr_level . [ Else ]
## base_expr(expr) -> disj_expr_level . [ With Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
## bin_op(disj_expr_level,BOOL_OR,conj_expr_level) -> disj_expr_level . BOOL_OR conj_expr_level [ With Type Then SEMI RPAR RBRACKET RBRACE Or Let In Else EOF COMMA COLON BOOL_OR Attr ]
## bin_op(disj_expr_level,Or,conj_expr_level) -> disj_expr_level . Or conj_expr_level [ With Type Then SEMI RPAR RBRACKET RBRACE Or Let In Else EOF COMMA COLON BOOL_OR Attr ]
## tuple(disj_expr_level) -> disj_expr_level . COMMA nsepseq(disj_expr_level,COMMA) [ With Type Then SEMI RPAR RBRACKET RBRACE Let In Else EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## disj_expr_level
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 226, spurious reduction of production call_expr_level -> core_expr
## In state 233, spurious reduction of production unary_expr_level -> call_expr_level
## In state 220, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 223, spurious reduction of production add_expr_level -> mult_expr_level
## In state 313, spurious reduction of production cons_expr_level -> add_expr_level
## In state 303, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 335, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 342, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 349, spurious reduction of production disj_expr_level -> conj_expr_level
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: LBRACE Constr DOT Ident With
##
## Ends in an error in state: 534.
##
## projection -> Constr DOT Ident . DOT nsepseq(selection,DOT) [ With EQ ]
##
## The known suffix of the stack is as follows:
## Constr DOT Ident
##

Ill-formed selection in a record or a tuple.

At this point, a dot '.' is expected,
  followed by a field name or tuple index.

interactive_expr: LBRACE Constr With
##
## Ends in an error in state: 532.
##
## projection -> Constr . DOT Ident DOT nsepseq(selection,DOT) [ With EQ ]
##
## The known suffix of the stack is as follows:
## Constr
##

Ill-formed selection in a module.

At this point, a dot '.' is expected, followed by a field name.

interactive_expr: LBRACE Ident DOT Ident Verbatim
##
## Ends in an error in state: 538.
##
## update_record -> LBRACE path . With sep_or_term_list(field_path_assignment,SEMI) RBRACE [ With Verbatim VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Mod MINUS Let Lang LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Constr CONS COMMA COLON CAT Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## LBRACE path
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 188, spurious reduction of production nsepseq(selection,DOT) -> selection
## In state 191, spurious reduction of production projection -> Ident DOT nsepseq(selection,DOT)
## In state 537, spurious reduction of production path -> projection
##

Ill-formed record update.

At this point, if the expression denoting the record to update is
complete, then the keyword 'with' is expected, followed by a field
update (assignment).

interactive_expr: LBRACE Ident EQ Bytes SEMI Ident EQ Bytes SEMI With
##
## Ends in an error in state: 563.
##
## nsepseq(field_assignment,SEMI) -> field_assignment SEMI . nsepseq(field_assignment,SEMI) [ RBRACE ]
## seq(__anonymous_0(field_assignment,SEMI)) -> field_assignment SEMI . seq(__anonymous_0(field_assignment,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_assignment SEMI
##
interactive_expr: LBRACE Ident EQ Bytes SEMI With
##
## Ends in an error in state: 558.
##
## nsepseq(field_assignment,SEMI) -> field_assignment SEMI . nsepseq(field_assignment,SEMI) [ RBRACE ]
## nseq(__anonymous_0(field_assignment,SEMI)) -> field_assignment SEMI . seq(__anonymous_0(field_assignment,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_assignment SEMI
##

Ill-formed record expression.

At this point, one of the following is expected:
  * another field assignment;
  * a closing brace '}' if the record is complete.

interactive_expr: LBRACE Ident EQ Bytes SEMI Ident EQ Bytes With
##
## Ends in an error in state: 562.
##
## nsepseq(field_assignment,SEMI) -> field_assignment . [ RBRACE ]
## nsepseq(field_assignment,SEMI) -> field_assignment . SEMI nsepseq(field_assignment,SEMI) [ RBRACE ]
## seq(__anonymous_0(field_assignment,SEMI)) -> field_assignment . SEMI seq(__anonymous_0(field_assignment,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_assignment
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 226, spurious reduction of production call_expr_level -> core_expr
## In state 233, spurious reduction of production unary_expr_level -> call_expr_level
## In state 220, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 223, spurious reduction of production add_expr_level -> mult_expr_level
## In state 313, spurious reduction of production cons_expr_level -> add_expr_level
## In state 303, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 335, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 342, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 349, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 370, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 372, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 373, spurious reduction of production expr -> base_cond__open(expr)
## In state 531, spurious reduction of production field_assignment -> Ident EQ expr
##
interactive_expr: LBRACE Ident EQ Bytes With
##
## Ends in an error in state: 557.
##
## nsepseq(field_assignment,SEMI) -> field_assignment . [ RBRACE ]
## nsepseq(field_assignment,SEMI) -> field_assignment . SEMI nsepseq(field_assignment,SEMI) [ RBRACE ]
## nseq(__anonymous_0(field_assignment,SEMI)) -> field_assignment . SEMI seq(__anonymous_0(field_assignment,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_assignment
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 226, spurious reduction of production call_expr_level -> core_expr
## In state 233, spurious reduction of production unary_expr_level -> call_expr_level
## In state 220, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 223, spurious reduction of production add_expr_level -> mult_expr_level
## In state 313, spurious reduction of production cons_expr_level -> add_expr_level
## In state 303, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 335, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 342, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 349, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 370, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 372, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 373, spurious reduction of production expr -> base_cond__open(expr)
## In state 531, spurious reduction of production field_assignment -> Ident EQ expr
##

Ill-formed record expression.

At this point, if the expression assigned to the field is complete,
one of the following is expected:
  * a semicolon ';', followed by another field assignment;
  * a closing brace '}' if the record is complete.

interactive_expr: LBRACE Ident EQ Bytes SEMI Ident With
##
## Ends in an error in state: 559.
##
## field_assignment -> Ident . EQ expr [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## Ident
##

Ill-formed field assignment in a record.

At this point, the assignment operator '=' is expected, followed by an
expression.

interactive_expr: LBRACE Ident EQ With
##
## Ends in an error in state: 181.
##
## field_assignment -> Ident EQ . expr [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## Ident EQ
##

Ill-formed field assignment in a record.

At this point, the expression to assign is expected.

interactive_expr: LBRACE Ident WILD
##
## Ends in an error in state: 180.
##
## field_assignment -> Ident . EQ expr [ SEMI RBRACE ]
## path -> Ident . [ With ]
## projection -> Ident . DOT nsepseq(selection,DOT) [ With ]
##
## The known suffix of the stack is as follows:
## Ident
##

Ill-formed record expression or update.

At this point, one of the following is expected:
  * the keyword 'with', followed by field updates (assignments);
  * the selection operator '.' if the record to update is not fully
    qualified;
  * the assignment operator '=' followed by an expression, if defining
    a record (as opposed to a record update.)

interactive_expr: LBRACE Ident With Ident DOT Ident With
##
## Ends in an error in state: 543.
##
## field_path_assignment -> path . EQ expr [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## path
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 188, spurious reduction of production nsepseq(selection,DOT) -> selection
## In state 191, spurious reduction of production projection -> Ident DOT nsepseq(selection,DOT)
## In state 537, spurious reduction of production path -> projection
##

Ill-formed record update.

At this point, the assignment operator '=' is expected, followed by an
expression.

interactive_expr: LBRACE Ident With Ident EQ Bytes SEMI Ident EQ Bytes SEMI With
##
## Ends in an error in state: 553.
##
## nsepseq(field_path_assignment,SEMI) -> field_path_assignment SEMI . nsepseq(field_path_assignment,SEMI) [ RBRACE ]
## seq(__anonymous_0(field_path_assignment,SEMI)) -> field_path_assignment SEMI . seq(__anonymous_0(field_path_assignment,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_path_assignment SEMI
##
interactive_expr: LBRACE Ident With Ident EQ Bytes SEMI With
##
## Ends in an error in state: 549.
##
## nsepseq(field_path_assignment,SEMI) -> field_path_assignment SEMI . nsepseq(field_path_assignment,SEMI) [ RBRACE ]
## nseq(__anonymous_0(field_path_assignment,SEMI)) -> field_path_assignment SEMI . seq(__anonymous_0(field_path_assignment,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_path_assignment SEMI
##

Ill-formed record update.

At this point, one of the following is expected:
  * another field assignment (update);
  * a closing brace '}' if the update is complete.

interactive_expr: LBRACE Ident With Ident EQ Bytes SEMI Ident EQ Bytes With
##
## Ends in an error in state: 552.
##
## nsepseq(field_path_assignment,SEMI) -> field_path_assignment . [ RBRACE ]
## nsepseq(field_path_assignment,SEMI) -> field_path_assignment . SEMI nsepseq(field_path_assignment,SEMI) [ RBRACE ]
## seq(__anonymous_0(field_path_assignment,SEMI)) -> field_path_assignment . SEMI seq(__anonymous_0(field_path_assignment,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_path_assignment
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 226, spurious reduction of production call_expr_level -> core_expr
## In state 233, spurious reduction of production unary_expr_level -> call_expr_level
## In state 220, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 223, spurious reduction of production add_expr_level -> mult_expr_level
## In state 313, spurious reduction of production cons_expr_level -> add_expr_level
## In state 303, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 335, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 342, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 349, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 370, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 372, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 373, spurious reduction of production expr -> base_cond__open(expr)
## In state 545, spurious reduction of production field_path_assignment -> path EQ expr
##
interactive_expr: LBRACE Ident With Ident EQ Bytes With
##
## Ends in an error in state: 548.
##
## nsepseq(field_path_assignment,SEMI) -> field_path_assignment . [ RBRACE ]
## nsepseq(field_path_assignment,SEMI) -> field_path_assignment . SEMI nsepseq(field_path_assignment,SEMI) [ RBRACE ]
## nseq(__anonymous_0(field_path_assignment,SEMI)) -> field_path_assignment . SEMI seq(__anonymous_0(field_path_assignment,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_path_assignment
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 226, spurious reduction of production call_expr_level -> core_expr
## In state 233, spurious reduction of production unary_expr_level -> call_expr_level
## In state 220, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 223, spurious reduction of production add_expr_level -> mult_expr_level
## In state 313, spurious reduction of production cons_expr_level -> add_expr_level
## In state 303, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 335, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 342, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 349, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 370, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 372, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 373, spurious reduction of production expr -> base_cond__open(expr)
## In state 545, spurious reduction of production field_path_assignment -> path EQ expr
##

Ill-formed record update.

At this point, if the field update is complete, one of the
following is expected:
  * a semicolon ';', followed by another field assignment;
  * a closing brace '}' if the update is complete.

interactive_expr: LBRACE Ident With Ident EQ With
##
## Ends in an error in state: 544.
##
## field_path_assignment -> path EQ . expr [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## path EQ
##

Ill-formed record update.

At this point, the right-hand side of a field assignment (update) is
expected as an expression.

interactive_expr: LBRACE Ident With Ident With
##
## Ends in an error in state: 540.
##
## path -> Ident . [ EQ ]
## projection -> Ident . DOT nsepseq(selection,DOT) [ EQ ]
##
## The known suffix of the stack is as follows:
## Ident
##

Ill-formed record update.

At this point, one of the following is expected:
  * the assignment operator '=', if the field to update is fully
    qualified;
  * the selection operator '.' to further qualify the field to update.

interactive_expr: LBRACE Ident With With
##
## Ends in an error in state: 539.
##
## update_record -> LBRACE path With . sep_or_term_list(field_path_assignment,SEMI) RBRACE [ With Verbatim VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Mod MINUS Let Lang LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Constr CONS COMMA COLON CAT Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## LBRACE path With
##

Ill-formed record update.

At this point, the first field update (assignment) is expected.

interactive_expr: LBRACE With
##
## Ends in an error in state: 179.
##
## record_expr -> LBRACE . sep_or_term_list(field_assignment,SEMI) RBRACE [ With Verbatim VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Mod MINUS Let Lang LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Constr CONS COMMA COLON CAT Bytes Begin BOOL_OR BOOL_AND Attr ]
## update_record -> LBRACE . path With sep_or_term_list(field_path_assignment,SEMI) RBRACE [ With Verbatim VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Mod MINUS Let Lang LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Constr CONS COMMA COLON CAT Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## LBRACE
##

Ill-formed record expression or update.

At this point, one of the following is expected:
  * the first field assignment, if defining a record;
  * the qualified name of the record to update.

interactive_expr: LBRACKET Verbatim SEMI Verbatim SEMI With
##
## Ends in an error in state: 575.
##
## nsepseq(expr,SEMI) -> expr SEMI . nsepseq(expr,SEMI) [ RBRACKET ]
## seq(__anonymous_0(expr,SEMI)) -> expr SEMI . seq(__anonymous_0(expr,SEMI)) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## expr SEMI
##
interactive_expr: LBRACKET Verbatim SEMI With
##
## Ends in an error in state: 571.
##
## nsepseq(expr,SEMI) -> expr SEMI . nsepseq(expr,SEMI) [ RBRACKET ]
## nseq(__anonymous_0(expr,SEMI)) -> expr SEMI . seq(__anonymous_0(expr,SEMI)) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## expr SEMI
##

Ill-formed list expression.

At this point, one of the following is expected:
  * another list element as an expression;
  * a closing bracket ']' if the list is complete.

interactive_expr: LBRACKET Verbatim SEMI Verbatim With
##
## Ends in an error in state: 574.
##
## nsepseq(expr,SEMI) -> expr . [ RBRACKET ]
## nsepseq(expr,SEMI) -> expr . SEMI nsepseq(expr,SEMI) [ RBRACKET ]
## seq(__anonymous_0(expr,SEMI)) -> expr . SEMI seq(__anonymous_0(expr,SEMI)) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 226, spurious reduction of production call_expr_level -> core_expr
## In state 233, spurious reduction of production unary_expr_level -> call_expr_level
## In state 220, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 223, spurious reduction of production add_expr_level -> mult_expr_level
## In state 313, spurious reduction of production cons_expr_level -> add_expr_level
## In state 303, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 335, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 342, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 349, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 370, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 372, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 373, spurious reduction of production expr -> base_cond__open(expr)
##
interactive_expr: LBRACKET Verbatim With
##
## Ends in an error in state: 570.
##
## nsepseq(expr,SEMI) -> expr . [ RBRACKET ]
## nsepseq(expr,SEMI) -> expr . SEMI nsepseq(expr,SEMI) [ RBRACKET ]
## nseq(__anonymous_0(expr,SEMI)) -> expr . SEMI seq(__anonymous_0(expr,SEMI)) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 226, spurious reduction of production call_expr_level -> core_expr
## In state 233, spurious reduction of production unary_expr_level -> call_expr_level
## In state 220, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 223, spurious reduction of production add_expr_level -> mult_expr_level
## In state 313, spurious reduction of production cons_expr_level -> add_expr_level
## In state 303, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 335, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 342, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 349, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 370, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 372, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 373, spurious reduction of production expr -> base_cond__open(expr)
##

Ill-formed list expression.

At this point, if the list element is complete, then one of the
following is expected:
  * a semicolon ';', followed by another element as an expression;
  * a closing bracket ']', if the list is complete.

interactive_expr: LBRACKET With
##
## Ends in an error in state: 178.
##
## list__(expr) -> LBRACKET . option(sep_or_term_list(expr,SEMI)) RBRACKET [ With Verbatim VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Mod MINUS Let Lang LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Constr CONS COMMA COLON CAT Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## LBRACKET
##
contract: Let LPAR Constr LBRACKET With
##
## Ends in an error in state: 76.
##
## list__(tail) -> LBRACKET . option(sep_or_term_list(tail,SEMI)) RBRACKET [ SEMI RPAR RBRACKET RBRACE CONS COMMA ARROW ]
##
## The known suffix of the stack is as follows:
## LBRACKET
##

Ill-formed list expression.

At this point, one of the following is expected:
  * the first element as an expression;
  * a closing bracket ']' if the list is empty.

interactive_expr: LPAR Verbatim COLON Ident VBAR
##
## Ends in an error in state: 584.
##
## par(annot_expr) -> LPAR annot_expr . RPAR [ With Verbatim VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Mod MINUS Let Lang LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Constr CONS COMMA COLON CAT Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## LPAR annot_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 28, spurious reduction of production cartesian -> core_type
## In state 36, spurious reduction of production fun_type -> cartesian
## In state 27, spurious reduction of production type_expr -> fun_type
## In state 583, spurious reduction of production annot_expr -> expr COLON type_expr
##

Ill-formed annotated expression.

At this point, if the type is complete, then a closing parenthesis ')'
is expected.

interactive_expr: LPAR Verbatim COLON With
##
## Ends in an error in state: 582.
##
## annot_expr -> expr COLON . type_expr [ RPAR ]
##
## The known suffix of the stack is as follows:
## expr COLON
##

Ill-formed annotated expression.

At this point, the type of the expression is expected.

interactive_expr: LPAR Verbatim With
##
## Ends in an error in state: 580.
##
## annot_expr -> expr . COLON type_expr [ RPAR ]
## par(expr) -> LPAR expr . RPAR [ With Verbatim VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Mod MINUS Let Lang LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Constr CONS COMMA COLON CAT Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## LPAR expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 226, spurious reduction of production call_expr_level -> core_expr
## In state 233, spurious reduction of production unary_expr_level -> call_expr_level
## In state 220, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 223, spurious reduction of production add_expr_level -> mult_expr_level
## In state 313, spurious reduction of production cons_expr_level -> add_expr_level
## In state 303, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 335, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 342, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 349, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 370, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 372, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 373, spurious reduction of production expr -> base_cond__open(expr)
##

Ill formed expression.

At this point, if the expression is complete, one of the following is
expected:
  * a colon ':' followed by a type annotating the expression;
  * a closing parenthesis ')'.

interactive_expr: LPAR With
##
## Ends in an error in state: 170.
##
## par(annot_expr) -> LPAR . annot_expr RPAR [ With Verbatim VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Mod MINUS Let Lang LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Constr CONS COMMA COLON CAT Bytes Begin BOOL_OR BOOL_AND Attr ]
## par(expr) -> LPAR . expr RPAR [ With Verbatim VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Mod MINUS Let Lang LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Constr CONS COMMA COLON CAT Bytes Begin BOOL_OR BOOL_AND Attr ]
## unit -> LPAR . RPAR [ With Verbatim VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Mod MINUS Let Lang LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Constr CONS COMMA COLON CAT Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed expression.

At this point, one of the following is expected:
  * a single expression, followed by a closing parenthesis ')';
  * an expression annotated by its type;
  * a closing parenthesis ')' if defining the unit value.

interactive_expr: Lang Verbatim With
##
## Ends in an error in state: 594.
##
## code_inj -> Lang expr . RBRACKET [ With Verbatim VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Mod MINUS Let Lang LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Constr CONS COMMA COLON CAT Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## Lang expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 226, spurious reduction of production call_expr_level -> core_expr
## In state 233, spurious reduction of production unary_expr_level -> call_expr_level
## In state 220, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 223, spurious reduction of production add_expr_level -> mult_expr_level
## In state 313, spurious reduction of production cons_expr_level -> add_expr_level
## In state 303, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 335, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 342, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 349, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 370, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 372, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 373, spurious reduction of production expr -> base_cond__open(expr)
##

Ill-formed language injection.

At this point, a closing bracket ']' is expected.

interactive_expr: Lang With
##
## Ends in an error in state: 167.
##
## code_inj -> Lang . expr RBRACKET [ With Verbatim VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Mod MINUS Let Lang LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Constr CONS COMMA COLON CAT Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## Lang
##

Ill-formed language injection.

At this point, a verbatim string containing the code to inject is
expected.

interactive_expr: MINUS With
##
## Ends in an error in state: 169.
##
## unary_expr_level -> MINUS . call_expr_level [ With VBAR Type Then TIMES SLASH SEMI RPAR RBRACKET RBRACE PLUS Or NE Mod MINUS Let LT LE In GT GE End Else EQ EOF CONS COMMA COLON CAT BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## MINUS
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match Verbatim With LPAR Bytes RPAR With
##
## Ends in an error in state: 249.
##
## pattern -> sub_pattern . CONS tail [ ARROW ]
## tuple(sub_pattern) -> sub_pattern . COMMA nsepseq(sub_pattern,COMMA) [ ARROW ]
##
## The known suffix of the stack is as follows:
## sub_pattern
##

Ill-formed pattern matching.

At this point, one of the following is expected:
  * the cons operator '::' followed by another pattern, if matching a
    non-empty list;
  * a comma ',' followed by another pattern, if matching a tuple.

interactive_expr: Match Verbatim With WILD ARROW If Verbatim Then Verbatim End
##
## Ends in an error in state: 301.
##
## base_expr(base_cond) -> disj_expr_level . [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
## base_expr(closed_if) -> disj_expr_level . [ Else ]
## bin_op(disj_expr_level,BOOL_OR,conj_expr_level) -> disj_expr_level . BOOL_OR conj_expr_level [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Or Let In Else EOF COMMA COLON BOOL_OR Attr ]
## bin_op(disj_expr_level,Or,conj_expr_level) -> disj_expr_level . Or conj_expr_level [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Or Let In Else EOF COMMA COLON BOOL_OR Attr ]
## tuple(disj_expr_level) -> disj_expr_level . COMMA nsepseq(disj_expr_level,COMMA) [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In Else EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## disj_expr_level
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 226, spurious reduction of production call_expr_level -> core_expr
## In state 233, spurious reduction of production unary_expr_level -> call_expr_level
## In state 220, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 223, spurious reduction of production add_expr_level -> mult_expr_level
## In state 313, spurious reduction of production cons_expr_level -> add_expr_level
## In state 303, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 335, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 342, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 349, spurious reduction of production disj_expr_level -> conj_expr_level
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match Verbatim With WILD ARROW Verbatim COMMA Bytes Else
##
## Ends in an error in state: 592.
##
## cases(base_cond) -> cases(base_cond) . VBAR case_clause(base_cond) [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
## match_expr(base_cond) -> Match expr With option(VBAR) cases(base_cond) . [ With Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## Match expr With option(VBAR) cases(base_cond)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 226, spurious reduction of production call_expr_level -> core_expr
## In state 233, spurious reduction of production unary_expr_level -> call_expr_level
## In state 220, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 223, spurious reduction of production add_expr_level -> mult_expr_level
## In state 313, spurious reduction of production cons_expr_level -> add_expr_level
## In state 303, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 335, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 342, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 349, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 346, spurious reduction of production nsepseq(disj_expr_level,COMMA) -> disj_expr_level
## In state 345, spurious reduction of production tuple(disj_expr_level) -> disj_expr_level COMMA nsepseq(disj_expr_level,COMMA)
## In state 222, spurious reduction of production tuple_expr -> tuple(disj_expr_level)
## In state 429, spurious reduction of production base_expr(base_cond) -> tuple_expr
## In state 358, spurious reduction of production base_cond__open(base_cond) -> base_expr(base_cond)
## In state 359, spurious reduction of production base_cond -> base_cond__open(base_cond)
## In state 405, spurious reduction of production case_clause(base_cond) -> pattern ARROW base_cond
## In state 413, spurious reduction of production cases(base_cond) -> case_clause(base_cond)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match Verbatim With WILD ARROW Verbatim End
##
## Ends in an error in state: 430.
##
## base_expr(base_cond) -> disj_expr_level . [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
## bin_op(disj_expr_level,BOOL_OR,conj_expr_level) -> disj_expr_level . BOOL_OR conj_expr_level [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Or Let In EOF COMMA COLON BOOL_OR Attr ]
## bin_op(disj_expr_level,Or,conj_expr_level) -> disj_expr_level . Or conj_expr_level [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Or Let In EOF COMMA COLON BOOL_OR Attr ]
## tuple(disj_expr_level) -> disj_expr_level . COMMA nsepseq(disj_expr_level,COMMA) [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## disj_expr_level
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 226, spurious reduction of production call_expr_level -> core_expr
## In state 233, spurious reduction of production unary_expr_level -> call_expr_level
## In state 220, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 223, spurious reduction of production add_expr_level -> mult_expr_level
## In state 313, spurious reduction of production cons_expr_level -> add_expr_level
## In state 303, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 335, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 342, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 349, spurious reduction of production disj_expr_level -> conj_expr_level
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match Verbatim With WILD COMMA WILD COMMA With
##
## Ends in an error in state: 254.
##
## nsepseq(sub_pattern,COMMA) -> sub_pattern COMMA . nsepseq(sub_pattern,COMMA) [ ARROW ]
##
## The known suffix of the stack is as follows:
## sub_pattern COMMA
##
interactive_expr: Match Verbatim With WILD COMMA With
##
## Ends in an error in state: 252.
##
## tuple(sub_pattern) -> sub_pattern COMMA . nsepseq(sub_pattern,COMMA) [ ARROW ]
##
## The known suffix of the stack is as follows:
## sub_pattern COMMA
##
contract: Let LPAR Constr LPAR WILD COMMA WILD COMMA With
##
## Ends in an error in state: 113.
##
## nsepseq(tail,COMMA) -> tail COMMA . nsepseq(tail,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## tail COMMA
##
contract: Let LPAR Constr LPAR WILD COMMA With
##
## Ends in an error in state: 111.
##
## tuple(tail) -> tail COMMA . nsepseq(tail,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## tail COMMA
##

Ill-formed tuple pattern.

At this point, another component of the tuple is expected as a pattern.

interactive_expr: Match Verbatim With WILD COMMA WILD With
##
## Ends in an error in state: 253.
##
## nsepseq(sub_pattern,COMMA) -> sub_pattern . [ ARROW ]
## nsepseq(sub_pattern,COMMA) -> sub_pattern . COMMA nsepseq(sub_pattern,COMMA) [ ARROW ]
##
## The known suffix of the stack is as follows:
## sub_pattern
##

Ill-formed pattern matching.

At this point, one of the following is expected:
  * an arrow '->' followed by the right-hand side of the case as an expression;
  * a comma ',' followed by another pattern, if you match a tuple.

interactive_expr: Match Verbatim With WILD CONS With
##
## Ends in an error in state: 250.
##
## pattern -> sub_pattern CONS . tail [ ARROW ]
##
## The known suffix of the stack is as follows:
## sub_pattern CONS
##

Ill-formed list pattern.

At this point, a pattern that matches a list is expected.

interactive_expr: Match Verbatim With WILD With
##
## Ends in an error in state: 406.
##
## pattern -> core_pattern . [ ARROW ]
## sub_pattern -> core_pattern . [ CONS COMMA ]
##
## The known suffix of the stack is as follows:
## core_pattern
##

Ill-formed pattern matching.

At this point, one of the following is expected:
  * an arrow '->' if the left-hand side of the case is complete;
  * a cons operator '::' if the pattern matches a list;
  * a comma ',' if the pattern matches a tuple.

interactive_expr: Not With
##
## Ends in an error in state: 164.
##
## unary_expr_level -> Not . call_expr_level [ With VBAR Type Then TIMES SLASH SEMI RPAR RBRACKET RBRACE PLUS Or NE Mod MINUS Let LT LE In GT GE End Else EQ EOF CONS COMMA COLON CAT BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## Not
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Verbatim BOOL_AND With
##
## Ends in an error in state: 321.
##
## bin_op(conj_expr_level,BOOL_AND,comp_expr_level) -> conj_expr_level BOOL_AND . comp_expr_level [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Or Let In End Else EOF COMMA COLON BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## conj_expr_level BOOL_AND
##
interactive_expr: Verbatim BOOL_OR With
##
## Ends in an error in state: 352.
##
## bin_op(disj_expr_level,BOOL_OR,conj_expr_level) -> disj_expr_level BOOL_OR . conj_expr_level [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Or Let In End Else EOF COMMA COLON BOOL_OR Attr ]
##
## The known suffix of the stack is as follows:
## disj_expr_level BOOL_OR
##
interactive_expr: Verbatim CAT With
##
## Ends in an error in state: 304.
##
## bin_op(cons_expr_level,CAT,cat_expr_level) -> cons_expr_level CAT . cat_expr_level [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Or NE Let LT LE In GT GE End Else EQ EOF COMMA COLON BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## cons_expr_level CAT
##

Ill-formed expression.

interactive_expr: Verbatim COMMA Verbatim COMMA With
##
## Ends in an error in state: 347.
##
## nsepseq(disj_expr_level,COMMA) -> disj_expr_level COMMA . nsepseq(disj_expr_level,COMMA) [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In Else EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## disj_expr_level COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Verbatim COMMA Verbatim End
##
## Ends in an error in state: 346.
##
## bin_op(disj_expr_level,BOOL_OR,conj_expr_level) -> disj_expr_level . BOOL_OR conj_expr_level [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Or Let In Else EOF COMMA COLON BOOL_OR Attr ]
## bin_op(disj_expr_level,Or,conj_expr_level) -> disj_expr_level . Or conj_expr_level [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Or Let In Else EOF COMMA COLON BOOL_OR Attr ]
## nsepseq(disj_expr_level,COMMA) -> disj_expr_level . [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In Else EOF COLON Attr ]
## nsepseq(disj_expr_level,COMMA) -> disj_expr_level . COMMA nsepseq(disj_expr_level,COMMA) [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In Else EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## disj_expr_level
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 226, spurious reduction of production call_expr_level -> core_expr
## In state 233, spurious reduction of production unary_expr_level -> call_expr_level
## In state 220, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 223, spurious reduction of production add_expr_level -> mult_expr_level
## In state 313, spurious reduction of production cons_expr_level -> add_expr_level
## In state 303, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 335, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 342, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 349, spurious reduction of production disj_expr_level -> conj_expr_level
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Verbatim COMMA With
##
## Ends in an error in state: 344.
##
## tuple(disj_expr_level) -> disj_expr_level COMMA . nsepseq(disj_expr_level,COMMA) [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In Else EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## disj_expr_level COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Verbatim CONS With
##
## Ends in an error in state: 318.
##
## bin_op(add_expr_level,CONS,cons_expr_level) -> add_expr_level CONS . cons_expr_level [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Or NE Let LT LE In GT GE End Else EQ EOF COMMA COLON CAT BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## add_expr_level CONS
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Verbatim Constr With
##
## Ends in an error in state: 203.
##
## module_field -> Constr . DOT module_fun [ With Verbatim VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Mod MINUS Let Lang LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Constr CONS COMMA COLON CAT Bytes Begin BOOL_OR BOOL_AND Attr ]
## projection -> Constr . DOT Ident DOT nsepseq(selection,DOT) [ With Verbatim VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Mod MINUS Let Lang LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Constr CONS COMMA COLON CAT Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## Constr
##

Ill-formed selection of a substructure.

At this point, the dot '.' operator is expected.

interactive_expr: Verbatim EQ With
##
## Ends in an error in state: 333.
##
## bin_op(comp_expr_level,EQ,cat_expr_level) -> comp_expr_level EQ . cat_expr_level [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Or NE Let LT LE In GT GE End Else EQ EOF COMMA COLON BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## comp_expr_level EQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Verbatim GE With
##
## Ends in an error in state: 331.
##
## bin_op(comp_expr_level,GE,cat_expr_level) -> comp_expr_level GE . cat_expr_level [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Or NE Let LT LE In GT GE End Else EQ EOF COMMA COLON BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## comp_expr_level GE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Verbatim GT With
##
## Ends in an error in state: 329.
##
## bin_op(comp_expr_level,GT,cat_expr_level) -> comp_expr_level GT . cat_expr_level [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Or NE Let LT LE In GT GE End Else EQ EOF COMMA COLON BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## comp_expr_level GT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Verbatim LE With
##
## Ends in an error in state: 327.
##
## bin_op(comp_expr_level,LE,cat_expr_level) -> comp_expr_level LE . cat_expr_level [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Or NE Let LT LE In GT GE End Else EQ EOF COMMA COLON BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## comp_expr_level LE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Verbatim LT With
##
## Ends in an error in state: 325.
##
## bin_op(comp_expr_level,LT,cat_expr_level) -> comp_expr_level LT . cat_expr_level [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Or NE Let LT LE In GT GE End Else EQ EOF COMMA COLON BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## comp_expr_level LT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Verbatim MINUS C_None WILD
##
## Ends in an error in state: 317.
##
## bin_op(add_expr_level,MINUS,mult_expr_level) -> add_expr_level MINUS mult_expr_level . [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE PLUS Or NE MINUS Let LT LE In GT GE End Else EQ EOF CONS COMMA COLON CAT BOOL_OR BOOL_AND Attr ]
## bin_op(mult_expr_level,Mod,unary_expr_level) -> mult_expr_level . Mod unary_expr_level [ With VBAR Type Then TIMES SLASH SEMI RPAR RBRACKET RBRACE PLUS Or NE Mod MINUS Let LT LE In GT GE End Else EQ EOF CONS COMMA COLON CAT BOOL_OR BOOL_AND Attr ]
## bin_op(mult_expr_level,SLASH,unary_expr_level) -> mult_expr_level . SLASH unary_expr_level [ With VBAR Type Then TIMES SLASH SEMI RPAR RBRACKET RBRACE PLUS Or NE Mod MINUS Let LT LE In GT GE End Else EQ EOF CONS COMMA COLON CAT BOOL_OR BOOL_AND Attr ]
## bin_op(mult_expr_level,TIMES,unary_expr_level) -> mult_expr_level . TIMES unary_expr_level [ With VBAR Type Then TIMES SLASH SEMI RPAR RBRACKET RBRACE PLUS Or NE Mod MINUS Let LT LE In GT GE End Else EQ EOF CONS COMMA COLON CAT BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## add_expr_level MINUS mult_expr_level
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Verbatim MINUS With
##
## Ends in an error in state: 316.
##
## bin_op(add_expr_level,MINUS,mult_expr_level) -> add_expr_level MINUS . mult_expr_level [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE PLUS Or NE MINUS Let LT LE In GT GE End Else EQ EOF CONS COMMA COLON CAT BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## add_expr_level MINUS
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Verbatim Mod With
##
## Ends in an error in state: 237.
##
## bin_op(mult_expr_level,Mod,unary_expr_level) -> mult_expr_level Mod . unary_expr_level [ With VBAR Type Then TIMES SLASH SEMI RPAR RBRACKET RBRACE PLUS Or NE Mod MINUS Let LT LE In GT GE End Else EQ EOF CONS COMMA COLON CAT BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## mult_expr_level Mod
##

Ill-formed arithmetic expression.

interactive_expr: Verbatim NE With
##
## Ends in an error in state: 323.
##
## bin_op(comp_expr_level,NE,cat_expr_level) -> comp_expr_level NE . cat_expr_level [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Or NE Let LT LE In GT GE End Else EQ EOF COMMA COLON BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## comp_expr_level NE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Verbatim Or With
##
## Ends in an error in state: 302.
##
## bin_op(disj_expr_level,Or,conj_expr_level) -> disj_expr_level Or . conj_expr_level [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Or Let In End Else EOF COMMA COLON BOOL_OR Attr ]
##
## The known suffix of the stack is as follows:
## disj_expr_level Or
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Verbatim PLUS C_None WILD
##
## Ends in an error in state: 315.
##
## bin_op(add_expr_level,PLUS,mult_expr_level) -> add_expr_level PLUS mult_expr_level . [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE PLUS Or NE MINUS Let LT LE In GT GE End Else EQ EOF CONS COMMA COLON CAT BOOL_OR BOOL_AND Attr ]
## bin_op(mult_expr_level,Mod,unary_expr_level) -> mult_expr_level . Mod unary_expr_level [ With VBAR Type Then TIMES SLASH SEMI RPAR RBRACKET RBRACE PLUS Or NE Mod MINUS Let LT LE In GT GE End Else EQ EOF CONS COMMA COLON CAT BOOL_OR BOOL_AND Attr ]
## bin_op(mult_expr_level,SLASH,unary_expr_level) -> mult_expr_level . SLASH unary_expr_level [ With VBAR Type Then TIMES SLASH SEMI RPAR RBRACKET RBRACE PLUS Or NE Mod MINUS Let LT LE In GT GE End Else EQ EOF CONS COMMA COLON CAT BOOL_OR BOOL_AND Attr ]
## bin_op(mult_expr_level,TIMES,unary_expr_level) -> mult_expr_level . TIMES unary_expr_level [ With VBAR Type Then TIMES SLASH SEMI RPAR RBRACKET RBRACE PLUS Or NE Mod MINUS Let LT LE In GT GE End Else EQ EOF CONS COMMA COLON CAT BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## add_expr_level PLUS mult_expr_level
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Verbatim PLUS With
##
## Ends in an error in state: 314.
##
## bin_op(add_expr_level,PLUS,mult_expr_level) -> add_expr_level PLUS . mult_expr_level [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE PLUS Or NE MINUS Let LT LE In GT GE End Else EQ EOF CONS COMMA COLON CAT BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## add_expr_level PLUS
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Verbatim SLASH With
##
## Ends in an error in state: 235.
##
## bin_op(mult_expr_level,SLASH,unary_expr_level) -> mult_expr_level SLASH . unary_expr_level [ With VBAR Type Then TIMES SLASH SEMI RPAR RBRACKET RBRACE PLUS Or NE Mod MINUS Let LT LE In GT GE End Else EQ EOF CONS COMMA COLON CAT BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## mult_expr_level SLASH
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Verbatim TIMES With
##
## Ends in an error in state: 224.
##
## bin_op(mult_expr_level,TIMES,unary_expr_level) -> mult_expr_level TIMES . unary_expr_level [ With VBAR Type Then TIMES SLASH SEMI RPAR RBRACKET RBRACE PLUS Or NE Mod MINUS Let LT LE In GT GE End Else EQ EOF CONS COMMA COLON CAT BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## mult_expr_level TIMES
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Verbatim VBAR
##
## Ends in an error in state: 370.
##
## base_expr(expr) -> disj_expr_level . [ With Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
## bin_op(disj_expr_level,BOOL_OR,conj_expr_level) -> disj_expr_level . BOOL_OR conj_expr_level [ With Type Then SEMI RPAR RBRACKET RBRACE Or Let In EOF COMMA COLON BOOL_OR Attr ]
## bin_op(disj_expr_level,Or,conj_expr_level) -> disj_expr_level . Or conj_expr_level [ With Type Then SEMI RPAR RBRACKET RBRACE Or Let In EOF COMMA COLON BOOL_OR Attr ]
## tuple(disj_expr_level) -> disj_expr_level . COMMA nsepseq(disj_expr_level,COMMA) [ With Type Then SEMI RPAR RBRACKET RBRACE Let In EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## disj_expr_level
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 226, spurious reduction of production call_expr_level -> core_expr
## In state 233, spurious reduction of production unary_expr_level -> call_expr_level
## In state 220, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 223, spurious reduction of production add_expr_level -> mult_expr_level
## In state 313, spurious reduction of production cons_expr_level -> add_expr_level
## In state 303, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 335, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 342, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 349, spurious reduction of production disj_expr_level -> conj_expr_level
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Verbatim Verbatim Verbatim WILD
##
## Ends in an error in state: 230.
##
## seq(core_expr) -> core_expr . seq(core_expr) [ With VBAR Type Then TIMES SLASH SEMI RPAR RBRACKET RBRACE PLUS Or NE Mod MINUS Let LT LE In GT GE End Else EQ EOF CONS COMMA COLON CAT BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## core_expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Verbatim Verbatim WILD
##
## Ends in an error in state: 228.
##
## nseq(core_expr) -> core_expr . seq(core_expr) [ With VBAR Type Then TIMES SLASH SEMI RPAR RBRACKET RBRACE PLUS Or NE Mod MINUS Let LT LE In GT GE End Else EQ EOF CONS COMMA COLON CAT BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## core_expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Verbatim WILD
##
## Ends in an error in state: 226.
##
## call_expr -> core_expr . nseq(core_expr) [ With VBAR Type Then TIMES SLASH SEMI RPAR RBRACKET RBRACE PLUS Or NE Mod MINUS Let LT LE In GT GE End Else EQ EOF CONS COMMA COLON CAT BOOL_OR BOOL_AND Attr ]
## call_expr_level -> core_expr . [ With VBAR Type Then TIMES SLASH SEMI RPAR RBRACKET RBRACE PLUS Or NE Mod MINUS Let LT LE In GT GE End Else EQ EOF CONS COMMA COLON CAT BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## core_expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Verbatim With
##
## Ends in an error in state: 611.
##
## interactive_expr -> expr . EOF [ # ]
##
## The known suffix of the stack is as follows:
## expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 226, spurious reduction of production call_expr_level -> core_expr
## In state 233, spurious reduction of production unary_expr_level -> call_expr_level
## In state 220, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 223, spurious reduction of production add_expr_level -> mult_expr_level
## In state 313, spurious reduction of production cons_expr_level -> add_expr_level
## In state 303, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 335, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 342, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 349, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 370, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 372, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 373, spurious reduction of production expr -> base_cond__open(expr)
##

Ill-formed interactive expression.

At this point, the end of file is expected.

interactive_expr: With
##
## Ends in an error in state: 609.
##
## interactive_expr' -> . interactive_expr [ # ]
##
## The known suffix of the stack is as follows:
##
##

Ill-formed expression.

contract: Let Ident WILD COLON String VBAR
##
## Ends in an error in state: 159.
##
## let_binding -> Ident nseq(sub_irrefutable) option(type_annotation) . EQ expr [ Type Let In EOF Attr ]
##
## The known suffix of the stack is as follows:
## Ident nseq(sub_irrefutable) option(type_annotation)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 28, spurious reduction of production cartesian -> core_type
## In state 36, spurious reduction of production fun_type -> cartesian
## In state 27, spurious reduction of production type_expr -> fun_type
## In state 157, spurious reduction of production type_annotation -> COLON type_expr
## In state 158, spurious reduction of production option(type_annotation) -> type_annotation
##

Ill-formed definition.

At this point, if the type annotation is complete, then the assignment
operator '=' is expected, followed by an expression.

contract: Let Ident WILD EQ With
##
## Ends in an error in state: 160.
##
## let_binding -> Ident nseq(sub_irrefutable) option(type_annotation) EQ . expr [ Type Let In EOF Attr ]
##
## The known suffix of the stack is as follows:
## Ident nseq(sub_irrefutable) option(type_annotation) EQ
##
contract: Let WILD EQ With
##
## Ends in an error in state: 378.
##
## let_binding -> irrefutable option(type_annotation) EQ . expr [ Type Let In EOF Attr ]
##
## The known suffix of the stack is as follows:
## irrefutable option(type_annotation) EQ
##

Ill-formed definition.

At this point, an expression is expected.

contract: Let Ident WILD WILD With
##
## Ends in an error in state: 152.
##
## seq(sub_irrefutable) -> sub_irrefutable . seq(sub_irrefutable) [ EQ COLON ]
##
## The known suffix of the stack is as follows:
## sub_irrefutable
##
contract: Let Ident WILD With
##
## Ends in an error in state: 151.
##
## nseq(sub_irrefutable) -> sub_irrefutable . seq(sub_irrefutable) [ EQ COLON ]
##
## The known suffix of the stack is as follows:
## sub_irrefutable
##

Ill-formed function definition.

At this point, one of the following is expected:
  * another parameter as a pattern, for instance and identifier;
  * the assignment operator '=', followed by the function body as an
    expression, if there are no more parameters;
  * a colon ':' followed by the type of the calls to the defined
    function.

contract: Let Ident With
##
## Ends in an error in state: 150.
##
## let_binding -> Ident . nseq(sub_irrefutable) option(type_annotation) EQ expr [ Type Let In EOF Attr ]
## sub_irrefutable -> Ident . [ EQ COMMA COLON ]
##
## The known suffix of the stack is as follows:
## Ident
##

Ill-formed function definition.

At this point, the first parameter is expected as a pattern.

contract: Let LBRACE Ident EQ Bytes SEMI Ident EQ Bytes SEMI With
##
## Ends in an error in state: 128.
##
## nsepseq(field_pattern,SEMI) -> field_pattern SEMI . nsepseq(field_pattern,SEMI) [ RBRACE ]
## seq(__anonymous_0(field_pattern,SEMI)) -> field_pattern SEMI . seq(__anonymous_0(field_pattern,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_pattern SEMI
##
contract: Let LBRACE Ident EQ Bytes SEMI With
##
## Ends in an error in state: 124.
##
## nsepseq(field_pattern,SEMI) -> field_pattern SEMI . nsepseq(field_pattern,SEMI) [ RBRACE ]
## nseq(__anonymous_0(field_pattern,SEMI)) -> field_pattern SEMI . seq(__anonymous_0(field_pattern,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_pattern SEMI
##

Ill-formed record pattern.

At this point, one of the following is expected:
  * another field pattern;
  * a closing brace '}', if the pattern is complete.

contract: Let LBRACE Ident EQ Bytes SEMI Ident EQ Bytes With
##
## Ends in an error in state: 127.
##
## nsepseq(field_pattern,SEMI) -> field_pattern . [ RBRACE ]
## nsepseq(field_pattern,SEMI) -> field_pattern . SEMI nsepseq(field_pattern,SEMI) [ RBRACE ]
## seq(__anonymous_0(field_pattern,SEMI)) -> field_pattern . SEMI seq(__anonymous_0(field_pattern,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_pattern
##
contract: Let LBRACE Ident EQ Bytes With
##
## Ends in an error in state: 123.
##
## nsepseq(field_pattern,SEMI) -> field_pattern . [ RBRACE ]
## nsepseq(field_pattern,SEMI) -> field_pattern . SEMI nsepseq(field_pattern,SEMI) [ RBRACE ]
## nseq(__anonymous_0(field_pattern,SEMI)) -> field_pattern . SEMI seq(__anonymous_0(field_pattern,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_pattern
##

Ill-formed record pattern.

At this point, one of the following is expected:
  * a semicolon ';' followed by another field pattern;
  * a closing brace '}', if the pattern is complete.

contract: Let LBRACE Ident EQ With
##
## Ends in an error in state: 69.
##
## field_pattern -> Ident EQ . sub_pattern [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## Ident EQ
##

Ill-formed record pattern.

At this point, the right-hand side of a field pattern is expected as a
pattern.

contract: Let LBRACE Ident With
##
## Ends in an error in state: 68.
##
## field_pattern -> Ident . EQ sub_pattern [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## Ident
##

Ill-formed record pattern.

At this point, the assignment operator '=' is expected, followed by
the right-hand side as a pattern.

contract: Let LBRACE With
##
## Ends in an error in state: 67.
##
## record_pattern -> LBRACE . sep_or_term_list(field_pattern,SEMI) RBRACE [ WILD SEMI RPAR RBRACKET RBRACE LPAR LBRACE Ident EQ Constr CONS COMMA COLON ARROW ]
##
## The known suffix of the stack is as follows:
## LBRACE
##

Ill-formed record pattern.

At this point, the first field pattern is expected.

contract: Let LPAR Constr C_Some With
##
## Ends in an error in state: 81.
##
## constr_pattern -> C_Some . sub_pattern [ SEMI RPAR RBRACKET RBRACE CONS COMMA ARROW ]
##
## The known suffix of the stack is as follows:
## C_Some
##

Ill-formed application of the 'Some' constructor in a pattern.

At this point, a pattern matching its argument is expected.

contract: Let LPAR Constr Constr With
##
## Ends in an error in state: 80.
##
## constr_pattern -> Constr . [ SEMI RPAR RBRACKET RBRACE CONS COMMA ARROW ]
## constr_pattern -> Constr . sub_pattern [ SEMI RPAR RBRACKET RBRACE CONS COMMA ARROW ]
##
## The known suffix of the stack is as follows:
## Constr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let LPAR Constr LBRACKET WILD RPAR
##
## Ends in an error in state: 93.
##
## nsepseq(tail,SEMI) -> tail . [ RBRACKET ]
## nsepseq(tail,SEMI) -> tail . SEMI nsepseq(tail,SEMI) [ RBRACKET ]
## nseq(__anonymous_0(tail,SEMI)) -> tail . SEMI seq(__anonymous_0(tail,SEMI)) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## tail
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 97, spurious reduction of production tail -> sub_pattern
##
contract: Let LPAR Constr LBRACKET WILD SEMI WILD RPAR
##
## Ends in an error in state: 95.
##
## nsepseq(tail,SEMI) -> tail . [ RBRACKET ]
## nsepseq(tail,SEMI) -> tail . SEMI nsepseq(tail,SEMI) [ RBRACKET ]
## seq(__anonymous_0(tail,SEMI)) -> tail . SEMI seq(__anonymous_0(tail,SEMI)) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## tail
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 97, spurious reduction of production tail -> sub_pattern
##

Ill-formed list pattern.

At this point, if the pattern matching a list element is complete,
then one of the following is expected:
  * a closing bracket ']', if the list pattern is complete;
  * a semicolon ';' followed by another list element as a pattern.

contract: Let LPAR Constr LBRACKET WILD SEMI With
##
## Ends in an error in state: 94.
##
## nsepseq(tail,SEMI) -> tail SEMI . nsepseq(tail,SEMI) [ RBRACKET ]
## nseq(__anonymous_0(tail,SEMI)) -> tail SEMI . seq(__anonymous_0(tail,SEMI)) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## tail SEMI
##
contract: Let LPAR Constr LBRACKET WILD SEMI WILD SEMI With
##
## Ends in an error in state: 96.
##
## nsepseq(tail,SEMI) -> tail SEMI . nsepseq(tail,SEMI) [ RBRACKET ]
## seq(__anonymous_0(tail,SEMI)) -> tail SEMI . seq(__anonymous_0(tail,SEMI)) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## tail SEMI
##

Ill-formed list pattern.

At this point, one of the following is expected:
  * another list element as a pattern;
  * a closing bracket ']' if the list pattern is complete.

contract: Let LPAR Constr LPAR WILD COMMA WILD SEMI
##
## Ends in an error in state: 112.
##
## nsepseq(tail,COMMA) -> tail . [ RPAR ]
## nsepseq(tail,COMMA) -> tail . COMMA nsepseq(tail,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## tail
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 97, spurious reduction of production tail -> sub_pattern
##

Ill-formed parenthises tuple pattern.

At this point, if the pattern matching the tuple component is
complete, then one of the following is expected:
  * a comma ',' followed by another component as a pattern;
  * a closing parenthesis ')', if the tuple is complete.

contract: Let LPAR Constr LPAR WILD CONS With
##
## Ends in an error in state: 98.
##
## tail -> sub_pattern CONS . tail [ SEMI RPAR RBRACKET COMMA ARROW ]
##
## The known suffix of the stack is as follows:
## sub_pattern CONS
##

Ill-formed list pattern.

At this point, one of the following is expected:
  * an identifier;
  * a list pattern;
  * a parenthesised pattern.

contract: Let LPAR Constr LPAR WILD SEMI
##
## Ends in an error in state: 109.
##
## par(tail) -> LPAR tail . RPAR [ SEMI RPAR RBRACKET RBRACE CONS COMMA ARROW ]
## tuple(tail) -> tail . COMMA nsepseq(tail,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## LPAR tail
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 97, spurious reduction of production tail -> sub_pattern
##

Ill-formed parenthesised pattern.

At this point, if the pattern inside is complete, then one of the
following is expected:
  * a closing parenthesis ')' if the pattern is complete;
  * a comma ',' followed by another pattern if matching a tuple.

contract: Let LPAR Constr LPAR WILD With
##
## Ends in an error in state: 97.
##
## tail -> sub_pattern . [ SEMI RPAR RBRACKET COMMA ARROW ]
## tail -> sub_pattern . CONS tail [ SEMI RPAR RBRACKET COMMA ARROW ]
##
## The known suffix of the stack is as follows:
## sub_pattern
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let LPAR Constr LPAR With
##
## Ends in an error in state: 75.
##
## par(ptuple) -> LPAR . ptuple RPAR [ SEMI RPAR RBRACKET RBRACE CONS COMMA ARROW ]
## par(tail) -> LPAR . tail RPAR [ SEMI RPAR RBRACKET RBRACE CONS COMMA ARROW ]
## unit -> LPAR . RPAR [ SEMI RPAR RBRACKET RBRACE CONS COMMA ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed pattern.

At this point, one of the following is expected:
  * a closing parenthesis ')' if matching the unit value;
  * a pattern.

contract: Let LPAR Constr WILD With
##
## Ends in an error in state: 148.
##
## par(closed_irrefutable) -> LPAR closed_irrefutable . RPAR [ WILD RPAR LPAR LBRACE Ident EQ Constr COMMA COLON ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR closed_irrefutable
##

Ill-formed parenthesised pattern.

At this point, a closing parenthesis ')' is expected.

contract: Let LPAR Constr With
##
## Ends in an error in state: 131.
##
## closed_irrefutable -> Constr . sub_pattern [ RPAR ]
## sub_irrefutable -> Constr . [ RPAR COMMA COLON ]
##
## The known suffix of the stack is as follows:
## Constr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let LPAR WILD COLON With
##
## Ends in an error in state: 146.
##
## typed_pattern -> irrefutable COLON . type_expr [ RPAR ]
##
## The known suffix of the stack is as follows:
## irrefutable COLON
##

Ill-formed typed pattern.

At this point, a type expression is expected.

contract: Let LPAR WILD WILD
##
## Ends in an error in state: 145.
##
## closed_irrefutable -> irrefutable . [ RPAR ]
## typed_pattern -> irrefutable . COLON type_expr [ RPAR ]
##
## The known suffix of the stack is as follows:
## irrefutable
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 136, spurious reduction of production irrefutable -> sub_irrefutable
##

Ill-formed parenthesised pattern.

At this point, if the pattern inside is complete, one of the following
is expected:
  * a type annotation, followed by a closing parenthesis ')';
  * a closing parenthesis ')'.

contract: Let LPAR With
##
## Ends in an error in state: 65.
##
## par(closed_irrefutable) -> LPAR . closed_irrefutable RPAR [ WILD RPAR LPAR LBRACE Ident EQ Constr COMMA COLON ARROW ]
## unit -> LPAR . RPAR [ WILD RPAR LPAR LBRACE Ident EQ Constr COMMA COLON ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed pattern.

At this point, one of the following is expected:
  * a closing parenthesis ')' if your pattern matches the unit value;
  * a pattern amongst the following: an identifier, a wildcard '_',
    the unit '()', a record pattern, a parenthesised pattern or a
    constructor application, or a typed pattern.

contract: Let WILD COLON Ident VBAR
##
## Ends in an error in state: 377.
##
## let_binding -> irrefutable option(type_annotation) . EQ expr [ Type Let In EOF Attr ]
##
## The known suffix of the stack is as follows:
## irrefutable option(type_annotation)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 28, spurious reduction of production cartesian -> core_type
## In state 36, spurious reduction of production fun_type -> cartesian
## In state 27, spurious reduction of production type_expr -> fun_type
## In state 157, spurious reduction of production type_annotation -> COLON type_expr
## In state 158, spurious reduction of production option(type_annotation) -> type_annotation
##

Ill-formed value definition.

At this point, if the type annotation is complete, the assignment
operator '=' is expected, followed by an expression.

contract: Let WILD COLON With
##
## Ends in an error in state: 156.
##
## type_annotation -> COLON . type_expr [ EQ ]
##
## The known suffix of the stack is as follows:
## COLON
##

Ill-formed type annotation.

At this point, a type expression is expected.

contract: Let WILD COMMA WILD With
##
## Ends in an error in state: 139.
##
## nsepseq(sub_irrefutable,COMMA) -> sub_irrefutable . [ WILD RPAR LPAR LBRACE Ident EQ Constr COLON ARROW ]
## nsepseq(sub_irrefutable,COMMA) -> sub_irrefutable . COMMA nsepseq(sub_irrefutable,COMMA) [ WILD RPAR LPAR LBRACE Ident EQ Constr COLON ARROW ]
##
## The known suffix of the stack is as follows:
## sub_irrefutable
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let WILD COMMA With
##
## Ends in an error in state: 137.
##
## tuple(sub_irrefutable) -> sub_irrefutable COMMA . nsepseq(sub_irrefutable,COMMA) [ WILD RPAR LPAR LBRACE Ident EQ Constr COLON ARROW ]
##
## The known suffix of the stack is as follows:
## sub_irrefutable COMMA
##
contract: Let WILD COMMA WILD COMMA With
##
## Ends in an error in state: 140.
##
## nsepseq(sub_irrefutable,COMMA) -> sub_irrefutable COMMA . nsepseq(sub_irrefutable,COMMA) [ WILD RPAR LPAR LBRACE Ident EQ Constr COLON ARROW ]
##
## The known suffix of the stack is as follows:
## sub_irrefutable COMMA
##

Ill-formed tuple pattern.

At this point, another component is expected as a pattern amongst the
following: an identifier, a wildcard '_', the unit '()', a record
pattern, a parenthesised pattern or a constant constructor (e.g., "K").

contract: Let WILD EQ Bytes Attr With
##
## Ends in an error in state: 174.
##
## seq(Attr) -> Attr . seq(Attr) [ Type Let In EOF ]
##
## The known suffix of the stack is as follows:
## Attr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let WILD EQ Bytes With
##
## Ends in an error in state: 600.
##
## let_declaration -> Let let_binding . seq(Attr) [ Type Let EOF ]
##
## The known suffix of the stack is as follows:
## Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 226, spurious reduction of production call_expr_level -> core_expr
## In state 233, spurious reduction of production unary_expr_level -> call_expr_level
## In state 220, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 223, spurious reduction of production add_expr_level -> mult_expr_level
## In state 313, spurious reduction of production cons_expr_level -> add_expr_level
## In state 303, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 335, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 342, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 349, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 370, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 372, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 373, spurious reduction of production expr -> base_cond__open(expr)
## In state 379, spurious reduction of production let_binding -> irrefutable option(type_annotation) EQ expr
##
contract: Let Rec WILD EQ Bytes With
##
## Ends in an error in state: 598.
##
## let_declaration -> Let Rec let_binding . seq(Attr) [ Type Let EOF ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 226, spurious reduction of production call_expr_level -> core_expr
## In state 233, spurious reduction of production unary_expr_level -> call_expr_level
## In state 220, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 223, spurious reduction of production add_expr_level -> mult_expr_level
## In state 313, spurious reduction of production cons_expr_level -> add_expr_level
## In state 303, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 335, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 342, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 349, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 370, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 372, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 373, spurious reduction of production expr -> base_cond__open(expr)
## In state 379, spurious reduction of production let_binding -> irrefutable option(type_annotation) EQ expr
##

Ill-formed definition.

At this point, if the value expression is complete, one of the
following is expected:
  * a series of attribute declarations;
  * a value or type declaration;
  * the end of the file (EOF) if the contract is complete.

contract: Let WILD WILD
##
## Ends in an error in state: 376.
##
## let_binding -> irrefutable . option(type_annotation) EQ expr [ Type Let In EOF Attr ]
##
## The known suffix of the stack is as follows:
## irrefutable
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 136, spurious reduction of production irrefutable -> sub_irrefutable
##

Ill-formed definition.

At this point, if the last pattern is complete, one of the following
is expected:
  * a type annotation for the value being defined;
  * the assignment operator '=', followed by an expression.

contract: Let WILD With
##
## Ends in an error in state: 136.
##
## irrefutable -> sub_irrefutable . [ WILD RPAR LPAR LBRACE Ident EQ Constr COLON ARROW ]
## tuple(sub_irrefutable) -> sub_irrefutable . COMMA nsepseq(sub_irrefutable,COMMA) [ WILD RPAR LPAR LBRACE Ident EQ Constr COLON ARROW ]
##
## The known suffix of the stack is as follows:
## sub_irrefutable
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Type Ident EQ Constr With
##
## Ends in an error in state: 13.
##
## core_type -> Constr . DOT Ident [ Type TIMES SEMI RPAR RBRACE Let Ident EQ EOF COMMA ARROW ]
## variant -> Constr . [ VBAR Type SEMI RPAR RBRACE Let EQ EOF COMMA ]
## variant -> Constr . Of fun_type [ VBAR Type SEMI RPAR RBRACE Let EQ EOF COMMA ]
##
## The known suffix of the stack is as follows:
## Constr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Type Ident EQ Ident VBAR
##
## Ends in an error in state: 606.
##
## declarations -> declaration . [ EOF ]
## declarations -> declaration . declarations [ EOF ]
##
## The known suffix of the stack is as follows:
## declaration
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 28, spurious reduction of production cartesian -> core_type
## In state 36, spurious reduction of production fun_type -> cartesian
## In state 27, spurious reduction of production type_expr -> fun_type
## In state 61, spurious reduction of production type_decl -> Type Ident EQ type_expr
## In state 602, spurious reduction of production declaration -> type_decl
##

Ill-formed top-level declaration.

At this point, if the type declaration is complete, one of the
following is expected:
  * another type or value declaration;
  * the end of the file (EOF) if the contract is complete.

contract: Type Ident EQ LBRACE Ident COLON Constr SEMI Ident COLON Ident VBAR
##
## Ends in an error in state: 47.
##
## nsepseq(field_decl,SEMI) -> field_decl . [ RBRACE ]
## nsepseq(field_decl,SEMI) -> field_decl . SEMI nsepseq(field_decl,SEMI) [ RBRACE ]
## seq(__anonymous_0(field_decl,SEMI)) -> field_decl . SEMI seq(__anonymous_0(field_decl,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_decl
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 28, spurious reduction of production cartesian -> core_type
## In state 36, spurious reduction of production fun_type -> cartesian
## In state 27, spurious reduction of production type_expr -> fun_type
## In state 21, spurious reduction of production field_decl -> Ident COLON type_expr
##
contract: Type Ident EQ LBRACE Ident COLON Ident VBAR
##
## Ends in an error in state: 43.
##
## nsepseq(field_decl,SEMI) -> field_decl . [ RBRACE ]
## nsepseq(field_decl,SEMI) -> field_decl . SEMI nsepseq(field_decl,SEMI) [ RBRACE ]
## nseq(__anonymous_0(field_decl,SEMI)) -> field_decl . SEMI seq(__anonymous_0(field_decl,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_decl
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 28, spurious reduction of production cartesian -> core_type
## In state 36, spurious reduction of production fun_type -> cartesian
## In state 27, spurious reduction of production type_expr -> fun_type
## In state 21, spurious reduction of production field_decl -> Ident COLON type_expr
##

Ill-formed record type.

At this point, if the type of the field is complete, one of the
following is expected:
  * a semicolon ';' followed by another field declaration;
  * a closing brace '}' if the record type is complete.

contract: Type Ident EQ LBRACE Ident COLON Constr SEMI With
##
## Ends in an error in state: 44.
##
## nsepseq(field_decl,SEMI) -> field_decl SEMI . nsepseq(field_decl,SEMI) [ RBRACE ]
## nseq(__anonymous_0(field_decl,SEMI)) -> field_decl SEMI . seq(__anonymous_0(field_decl,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_decl SEMI
##
contract: Type Ident EQ LBRACE Ident COLON Constr SEMI Ident COLON Constr SEMI With
##
## Ends in an error in state: 48.
##
## nsepseq(field_decl,SEMI) -> field_decl SEMI . nsepseq(field_decl,SEMI) [ RBRACE ]
## seq(__anonymous_0(field_decl,SEMI)) -> field_decl SEMI . seq(__anonymous_0(field_decl,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_decl SEMI
##

Ill-formed record type.

At this point, one of the following is expected:
  * another field declaration;
  * a closing brace '}' if the record type is complete.

contract: Type Ident EQ LBRACE Ident COLON With
##
## Ends in an error in state: 11.
##
## field_decl -> Ident COLON . type_expr [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## Ident COLON
##

Ill-formed record type.

At this point, a type expression is expected to conclude the field
declaration.

contract: Type Ident EQ LBRACE Ident With
##
## Ends in an error in state: 10.
##
## field_decl -> Ident . COLON type_expr [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## Ident
##

Ill-formed record type.

At this point, a colon ':' followed by the type of the field is
expected.

contract: Type Ident EQ LBRACE With
##
## Ends in an error in state: 9.
##
## record_type -> LBRACE . sep_or_term_list(field_decl,SEMI) RBRACE [ Type SEMI RPAR RBRACE Let EQ EOF COMMA ]
##
## The known suffix of the stack is as follows:
## LBRACE
##

Ill-formed record type.

At this point, the first field declaration is expected.

contract: Type Ident EQ LPAR String COMMA Constr RPAR With
##
## Ends in an error in state: 19.
##
## core_type -> type_tuple . Ident [ VBAR Type TIMES SEMI RPAR RBRACE Let Ident EQ EOF COMMA ARROW ]
##
## The known suffix of the stack is as follows:
## type_tuple
##

Ill-formed type expression.

At this point, a type constructor is expected, for example: 'map'.

contract: Type Ident EQ LPAR String COMMA String COMMA With
##
## Ends in an error in state: 54.
##
## nsepseq(type_expr,COMMA) -> type_expr COMMA . nsepseq(type_expr,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## type_expr COMMA
##
contract: Type Ident EQ LPAR String COMMA With
##
## Ends in an error in state: 52.
##
## tuple(type_expr) -> type_expr COMMA . nsepseq(type_expr,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## type_expr COMMA
##

Ill-formed type expression.

At this point, a tuple component is expected as a type expression.

contract: Type Ident EQ LPAR String COMMA String VBAR
##
## Ends in an error in state: 53.
##
## nsepseq(type_expr,COMMA) -> type_expr . [ RPAR ]
## nsepseq(type_expr,COMMA) -> type_expr . COMMA nsepseq(type_expr,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## type_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 28, spurious reduction of production cartesian -> core_type
## In state 36, spurious reduction of production fun_type -> cartesian
## In state 27, spurious reduction of production type_expr -> fun_type
##
contract: Type Ident EQ LPAR String VBAR
##
## Ends in an error in state: 50.
##
## par(type_expr) -> LPAR type_expr . RPAR [ VBAR Type TIMES SEMI RPAR RBRACE Let Ident EQ EOF COMMA ARROW ]
## tuple(type_expr) -> type_expr . COMMA nsepseq(type_expr,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## LPAR type_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 28, spurious reduction of production cartesian -> core_type
## In state 36, spurious reduction of production fun_type -> cartesian
## In state 27, spurious reduction of production type_expr -> fun_type
##

Ill-formed type expression.

At this point, if the type expression is complete, one of the
following is expected:
  * a closing parenthesis ')';
  * a comma ',' followed by another type expression, if you want a
    type tuple.

contract: Type Ident EQ LPAR With
##
## Ends in an error in state: 8.
##
## par(tuple(type_expr)) -> LPAR . tuple(type_expr) RPAR [ Ident ]
## par(type_expr) -> LPAR . type_expr RPAR [ VBAR Type TIMES SEMI RPAR RBRACE Let Ident EQ EOF COMMA ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed type expression.

contract: Type Ident EQ String ARROW With
##
## Ends in an error in state: 37.
##
## fun_type -> cartesian ARROW . fun_type [ VBAR Type SEMI RPAR RBRACE Let EQ EOF COMMA ]
##
## The known suffix of the stack is as follows:
## cartesian ARROW
##
contract: Type Ident EQ Constr Of With
##
## Ends in an error in state: 6.
##
## variant -> Constr Of . fun_type [ VBAR Type SEMI RPAR RBRACE Let EQ EOF COMMA ]
##
## The known suffix of the stack is as follows:
## Constr Of
##

Ill-formed type expression.

At this point, a type other than a sum type or a record is expected.

contract: Type Ident EQ String TIMES Constr With
##
## Ends in an error in state: 30.
##
## core_type -> Constr . DOT Ident [ VBAR Type TIMES SEMI RPAR RBRACE Let Ident EQ EOF COMMA ARROW ]
##
## The known suffix of the stack is as follows:
## Constr
##

Ill-formed type selection in a module.

At this point, the selection operator '.' is expected, followed by a
type name.

contract: Type Ident EQ String TIMES String TIMES With
##
## Ends in an error in state: 33.
##
## nsepseq(core_type,TIMES) -> core_type TIMES . nsepseq(core_type,TIMES) [ VBAR Type SEMI RPAR RBRACE Let EQ EOF COMMA ARROW ]
##
## The known suffix of the stack is as follows:
## core_type TIMES
##
contract: Type Ident EQ String TIMES With
##
## Ends in an error in state: 29.
##
## cartesian -> core_type TIMES . nsepseq(core_type,TIMES) [ VBAR Type SEMI RPAR RBRACE Let EQ EOF COMMA ARROW ]
##
## The known suffix of the stack is as follows:
## core_type TIMES
##

Ill-formed product type.

At this point, one of the following type expressions is expected:
  * a type name;
  * a type selection in a module, e.g., 'M.t';
  * an instantiation of a parametric type, e.g., 'int list' or '(int,
    string) map';
  * a parenthesised type expression.

contract: Type Ident EQ String TIMES String With
##
## Ends in an error in state: 32.
##
## core_type -> core_type . Ident [ VBAR Type TIMES SEMI RPAR RBRACE Let Ident EQ EOF COMMA ARROW ]
## nsepseq(core_type,TIMES) -> core_type . [ VBAR Type SEMI RPAR RBRACE Let EQ EOF COMMA ARROW ]
## nsepseq(core_type,TIMES) -> core_type . TIMES nsepseq(core_type,TIMES) [ VBAR Type SEMI RPAR RBRACE Let EQ EOF COMMA ARROW ]
##
## The known suffix of the stack is as follows:
## core_type
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Type Ident EQ String With
##
## Ends in an error in state: 28.
##
## cartesian -> core_type . [ VBAR Type SEMI RPAR RBRACE Let EQ EOF COMMA ARROW ]
## cartesian -> core_type . TIMES nsepseq(core_type,TIMES) [ VBAR Type SEMI RPAR RBRACE Let EQ EOF COMMA ARROW ]
## core_type -> core_type . Ident [ VBAR Type TIMES SEMI RPAR RBRACE Let Ident EQ EOF COMMA ARROW ]
##
## The known suffix of the stack is as follows:
## core_type
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Type Ident EQ VBAR Constr With
##
## Ends in an error in state: 5.
##
## variant -> Constr . [ VBAR Type SEMI RPAR RBRACE Let EQ EOF COMMA ]
## variant -> Constr . Of fun_type [ VBAR Type SEMI RPAR RBRACE Let EQ EOF COMMA ]
##
## The known suffix of the stack is as follows:
## Constr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Type Ident EQ VBAR With
##
## Ends in an error in state: 4.
##
## sum_type -> VBAR . nsepseq(variant,VBAR) [ Type SEMI RPAR RBRACE Let EQ EOF COMMA ]
##
## The known suffix of the stack is as follows:
## VBAR
##
contract: Type Ident EQ Constr VBAR With
##
## Ends in an error in state: 17.
##
## nsepseq(variant,VBAR) -> variant VBAR . nsepseq(variant,VBAR) [ Type SEMI RPAR RBRACE Let EQ EOF COMMA ]
##
## The known suffix of the stack is as follows:
## variant VBAR
##

Ill-formed variant of a sum type.

At this point, a data constructor is expected.

contract: Type Ident EQ With
##
## Ends in an error in state: 3.
##
## type_decl -> Type Ident EQ . type_expr [ Type Let EOF ]
##
## The known suffix of the stack is as follows:
## Type Ident EQ
##

Ill-formed type declaration.

At this point, a type expression is expected.

contract: Type Ident With
##
## Ends in an error in state: 2.
##
## type_decl -> Type Ident . EQ type_expr [ Type Let EOF ]
##
## The known suffix of the stack is as follows:
## Type Ident
##

Ill-formed type declaration.

At this point, the assignment operator '=' is expected, followed by a
type expression.

contract: Type With
##
## Ends in an error in state: 1.
##
## type_decl -> Type . Ident EQ type_expr [ Type Let EOF ]
##
## The known suffix of the stack is as follows:
## Type
##

Ill-formed type declaration.

At this point, a type name is expected.

contract: With
##
## Ends in an error in state: 0.
##
## contract' -> . contract [ # ]
##
## The known suffix of the stack is as follows:
##
##

Ill-formed contract.

At this point, a type or let declaration is expected.
