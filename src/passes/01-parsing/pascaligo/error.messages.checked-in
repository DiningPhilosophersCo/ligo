interactive_expr: Begin Case Verbatim Of LBRACKET WILD ARROW Skip With
##
## Ends in an error in state: 455.
##
## case(if_clause) -> Case expr Of LBRACKET option(VBAR) cases(if_clause) . RBRACKET [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## Case expr Of LBRACKET option(VBAR) cases(if_clause)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 457, spurious reduction of production nsepseq(case_clause(if_clause),VBAR) -> case_clause(if_clause)
## In state 454, spurious reduction of production cases(if_clause) -> nsepseq(case_clause(if_clause),VBAR)
##
Ill-formed case instruction.
At this point, if the case clause is complete, one of the following is
expected:
  * more clauses, separated by vertical bars '|';
  * a closing bracket ']' if the case is complete.

interactive_expr: Begin Case Verbatim Of LBRACKET With
##
## Ends in an error in state: 367.
##
## case(if_clause) -> Case expr Of LBRACKET option(VBAR) . cases(if_clause) RBRACKET [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## Case expr Of LBRACKET option(VBAR)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 366, spurious reduction of production option(VBAR) ->
##
interactive_expr: Begin Case Verbatim Of With
##
## Ends in an error in state: 460.
##
## case(if_clause) -> Case expr Of option(VBAR) . cases(if_clause) End [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## Case expr Of option(VBAR)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 365, spurious reduction of production option(VBAR) ->
##
interactive_expr: Begin Case Verbatim Of WILD ARROW Skip VBAR With
##
## Ends in an error in state: 458.
##
## nsepseq(case_clause(if_clause),VBAR) -> case_clause(if_clause) VBAR . nsepseq(case_clause(if_clause),VBAR) [ RBRACKET End ]
##
## The known suffix of the stack is as follows:
## case_clause(if_clause) VBAR
##
Ill-formed case instruction.
At this point, a case clause is expected, starting with a pattern.

interactive_expr: Begin Case Verbatim Of WILD ARROW Skip With
##
## Ends in an error in state: 461.
##
## case(if_clause) -> Case expr Of option(VBAR) cases(if_clause) . End [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## Case expr Of option(VBAR) cases(if_clause)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 457, spurious reduction of production nsepseq(case_clause(if_clause),VBAR) -> case_clause(if_clause)
## In state 454, spurious reduction of production cases(if_clause) -> nsepseq(case_clause(if_clause),VBAR)
##
Ill-formed case instruction.
At this point, if the clause is complete, one of the following is
expected:
  * more clauses starting by a pattern and separated by vertical bars
    '|';
  * the keyword 'end' if the case is complete.

interactive_expr: Begin Case Verbatim Of WILD ARROW With
##
## Ends in an error in state: 428.
##
## case_clause(if_clause) -> pattern ARROW . if_clause [ VBAR RBRACKET End ]
##
## The known suffix of the stack is as follows:
## pattern ARROW
##
Ill-formed clause of a case instruction.
At this point, one of the following is expected:
  * a single instruction;
  * a block of statements (instructions and declarations).

interactive_expr: Begin Case Verbatim Of WILD With
##
## Ends in an error in state: 427.
##
## case_clause(if_clause) -> pattern . ARROW if_clause [ VBAR RBRACKET End ]
##
## The known suffix of the stack is as follows:
## pattern
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 403, spurious reduction of production pattern -> core_pattern
##
Ill-formed clause of a case instruction.
At this point, if the pattern is complete, an arrow '->' is expected,
followed by one of the following:
  * a single instruction;
  * a block of statements (instructions and declarations).

interactive_expr: Begin Case Verbatim With
##
## Ends in an error in state: 364.
##
## case(if_clause) -> Case expr . Of option(VBAR) cases(if_clause) End [ VBAR SEMI RBRACKET RBRACE End Else ]
## case(if_clause) -> Case expr . Of LBRACKET option(VBAR) cases(if_clause) RBRACKET [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## Case expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 204, spurious reduction of production unary_expr -> core_expr
## In state 153, spurious reduction of production mult_expr -> unary_expr
## In state 180, spurious reduction of production add_expr -> mult_expr
## In state 210, spurious reduction of production cons_expr -> add_expr
## In state 207, spurious reduction of production cat_expr -> cons_expr
## In state 230, spurious reduction of production comp_expr -> cat_expr
## In state 217, spurious reduction of production set_membership -> comp_expr
## In state 155, spurious reduction of production conj_expr -> set_membership
## In state 234, spurious reduction of production disj_expr -> conj_expr
## In state 202, spurious reduction of production expr -> disj_expr
##
Ill-formed case instruction.
At this point, if the condition is complete, the keyword 'of' is
expected, followed with a series of case clauses separated by vertical
bars '|'.

interactive_expr: Begin Case With
##
## Ends in an error in state: 363.
##
## case(if_clause) -> Case . expr Of option(VBAR) cases(if_clause) End [ VBAR SEMI RBRACKET RBRACE End Else ]
## case(if_clause) -> Case . expr Of LBRACKET option(VBAR) cases(if_clause) RBRACKET [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## Case
##
Ill-formed case instruction.
At this point, the condition is expected as an expression, followed by
the keyword 'of'.

interactive_expr: Begin Constr DOT And With
##
## Ends in an error in state: 435.
##
## fun_call -> module_field . arguments [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## module_field
##
Ill-formed function call.
At this point, if the function name is fully qualified, its arguments
are expected between parentheses.

interactive_expr: Begin Constr With
##
## Ends in an error in state: 356.
##
## module_field -> Constr . DOT module_fun [ LPAR ]
## projection -> Constr . DOT Ident DOT nsepseq(selection,DOT) [ LBRACKET ASS ]
##
## The known suffix of the stack is as follows:
## Constr
##
Ill-formed selection from a module.
At this point, the selection operator '.' is expected, followed by the
name of a value declared in the module.

interactive_expr: Begin For Ident ARROW Ident With
##
## Ends in an error in state: 347.
##
## for_loop -> For Ident option(arrow_clause) . In collection expr block [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## For Ident option(arrow_clause)
##
Ill-formed bounded loop.
At this point, the keyword 'in' is expected, followed by the kind of
collection to be iterated as a keyword, and then the collection itself
as an expression.

interactive_expr: Begin For Ident ARROW With
##
## Ends in an error in state: 345.
##
## arrow_clause -> ARROW . Ident [ In ]
##
## The known suffix of the stack is as follows:
## ARROW
##
Ill-formed bounded loop over a map.
At this point, an identifier matching values (as opposed to keys) in a
map is expected.

interactive_expr: Begin For Ident ASS Verbatim To Verbatim Step Verbatim Attributes
##
## Ends in an error in state: 343.
##
## for_loop -> For Ident ASS expr To expr option(step_clause) . block [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## For Ident ASS expr To expr option(step_clause)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 204, spurious reduction of production unary_expr -> core_expr
## In state 153, spurious reduction of production mult_expr -> unary_expr
## In state 180, spurious reduction of production add_expr -> mult_expr
## In state 210, spurious reduction of production cons_expr -> add_expr
## In state 207, spurious reduction of production cat_expr -> cons_expr
## In state 230, spurious reduction of production comp_expr -> cat_expr
## In state 217, spurious reduction of production set_membership -> comp_expr
## In state 155, spurious reduction of production conj_expr -> set_membership
## In state 234, spurious reduction of production disj_expr -> conj_expr
## In state 202, spurious reduction of production expr -> disj_expr
## In state 341, spurious reduction of production step_clause -> Step expr
## In state 342, spurious reduction of production option(step_clause) -> step_clause
##
Ill-formed bounded loop over a numerical interval.
At this point, if the step clause is complete, the loop body is
expected as a block of instructions.

interactive_expr: Begin For Ident ASS Verbatim To Verbatim Step With
##
## Ends in an error in state: 340.
##
## step_clause -> Step . expr [ Block Begin ]
##
## The known suffix of the stack is as follows:
## Step
##
Ill-formed bounded loop over a numerical interval.
At this point, the index increment is expected as an expression.

interactive_expr: Begin For Ident ASS Verbatim To Verbatim With
##
## Ends in an error in state: 339.
##
## for_loop -> For Ident ASS expr To expr . option(step_clause) block [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## For Ident ASS expr To expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 204, spurious reduction of production unary_expr -> core_expr
## In state 153, spurious reduction of production mult_expr -> unary_expr
## In state 180, spurious reduction of production add_expr -> mult_expr
## In state 210, spurious reduction of production cons_expr -> add_expr
## In state 207, spurious reduction of production cat_expr -> cons_expr
## In state 230, spurious reduction of production comp_expr -> cat_expr
## In state 217, spurious reduction of production set_membership -> comp_expr
## In state 155, spurious reduction of production conj_expr -> set_membership
## In state 234, spurious reduction of production disj_expr -> conj_expr
## In state 202, spurious reduction of production expr -> disj_expr
##
Ill-formed bounded loop over a numerical interval.
At this point, if the final value of the index is complete, one of the
following is expected:
  * a step clause introduced by the keyword 'step' and followed by
    the index increment as an expression;
  * a loop body as a block of instructions.

interactive_expr: Begin For Ident ASS Verbatim To With
##
## Ends in an error in state: 338.
##
## for_loop -> For Ident ASS expr To . expr option(step_clause) block [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## For Ident ASS expr To
##
Ill-formed bounded loop over a numerical interval.
At this point, the final value of the index is expected as an
expression.

interactive_expr: Begin For Ident ASS Verbatim With
##
## Ends in an error in state: 337.
##
## for_loop -> For Ident ASS expr . To expr option(step_clause) block [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## For Ident ASS expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 204, spurious reduction of production unary_expr -> core_expr
## In state 153, spurious reduction of production mult_expr -> unary_expr
## In state 180, spurious reduction of production add_expr -> mult_expr
## In state 210, spurious reduction of production cons_expr -> add_expr
## In state 207, spurious reduction of production cat_expr -> cons_expr
## In state 230, spurious reduction of production comp_expr -> cat_expr
## In state 217, spurious reduction of production set_membership -> comp_expr
## In state 155, spurious reduction of production conj_expr -> set_membership
## In state 234, spurious reduction of production disj_expr -> conj_expr
## In state 202, spurious reduction of production expr -> disj_expr
##
Ill-formed bounded loop over a numerical interval.
At this point, if the initial value of the index is complete, the
keyword 'to' is expected, followed by an expression whose value is the
final value of the index.

interactive_expr: Begin For Ident ASS With
##
## Ends in an error in state: 336.
##
## for_loop -> For Ident ASS . expr To expr option(step_clause) block [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## For Ident ASS
##
Ill-formed bounded loop over a numerical interval.
At this point, an expression is expected, whose value is the initial
one for the index.

interactive_expr: Begin For Ident In Set Verbatim With
##
## Ends in an error in state: 353.
##
## for_loop -> For Ident option(arrow_clause) In collection expr . block [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## For Ident option(arrow_clause) In collection expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 204, spurious reduction of production unary_expr -> core_expr
## In state 153, spurious reduction of production mult_expr -> unary_expr
## In state 180, spurious reduction of production add_expr -> mult_expr
## In state 210, spurious reduction of production cons_expr -> add_expr
## In state 207, spurious reduction of production cat_expr -> cons_expr
## In state 230, spurious reduction of production comp_expr -> cat_expr
## In state 217, spurious reduction of production set_membership -> comp_expr
## In state 155, spurious reduction of production conj_expr -> set_membership
## In state 234, spurious reduction of production disj_expr -> conj_expr
## In state 202, spurious reduction of production expr -> disj_expr
##
Ill-formed bounded loop over a collection.
At this point, if the collection is complete, the body of the loop is
expected as a block of instructions.

interactive_expr: Begin For Ident In Set With
##
## Ends in an error in state: 352.
##
## for_loop -> For Ident option(arrow_clause) In collection . expr block [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## For Ident option(arrow_clause) In collection
##
Ill-formed bounded loop over a collection.
At this point, the collection is expected as an expression.

interactive_expr: Begin For Ident In With
##
## Ends in an error in state: 348.
##
## for_loop -> For Ident option(arrow_clause) In . collection expr block [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## For Ident option(arrow_clause) In
##
Ill-formed bounded loop over a collection.
At this point, the kind of the collection is expected ('map', 'set',
or 'list'), followed by the actual collection as an expression.

interactive_expr: Begin For Ident With
##
## Ends in an error in state: 335.
##
## for_loop -> For Ident . ASS expr To expr option(step_clause) block [ VBAR SEMI RBRACKET RBRACE End Else ]
## for_loop -> For Ident . option(arrow_clause) In collection expr block [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## For Ident
##
Ill-formed bounded loop.
At this point, one of the following is expected:
  * if iterating over a numerical interval, then the assignment
    operator ':=' is expected, followed by the initial value of the
    index as an expression;
  * if iterating over a list or a set, then the keyword 'in' is
    expected, followed by either the keyword 'list' or 'map';
  * if iterating over a map, then a binding arrow '->' followed by a
    variable matching the range of the map (that is, 'values', as
    opposed to 'keys').

interactive_expr: Begin For With
##
## Ends in an error in state: 334.
##
## for_loop -> For . Ident ASS expr To expr option(step_clause) block [ VBAR SEMI RBRACKET RBRACE End Else ]
## for_loop -> For . Ident option(arrow_clause) In collection expr block [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## For
##
Ill-formed bounded loop.
At this point, one of the following is expected:
  * if iterating over a numerical interval, then the index is expected
    as an identifier;
 * if iterating over a list or a set, then the element is expected as
   an identifier;
 * of iterating over a map, then the key (ranging over the domain of
   the map) is expected as an identifier.

interactive_expr: Begin Ident ASS With
##
## Ends in an error in state: 441.
##
## assignment -> lhs ASS . rhs [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## lhs ASS
##
Ill-formed assignment.
At this point, the right-hand side of the assignment is expected as an
expression.

interactive_expr: Begin Ident With
##
## Ends in an error in state: 440.
##
## assignment -> lhs . ASS rhs [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## lhs
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 325, spurious reduction of production path -> Ident
## In state 434, spurious reduction of production lhs -> path
##
Ill-formed assignment.
At this point, if the left-hand side of the assignment is complete,
the assignment operator ':=' is expected, followed by an expression.

interactive_expr: Begin If Verbatim Then LBRACE Skip With
##
## Ends in an error in state: 492.
##
## clause_block -> LBRACE sep_or_term_list(statement,SEMI) . RBRACE [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## LBRACE sep_or_term_list(statement,SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 478, spurious reduction of production nsepseq(statement,SEMI) -> statement
## In state 495, spurious reduction of production sep_or_term_list(statement,SEMI) -> nsepseq(statement,SEMI)
##
Ill-formed block of statements.
At this point, if the statement is complete, one of the following is
expected:
  * more statements (instructions or declarations) separated by
    semicolons ';' and followed by a closing brace '}';
  * a closing brace '}' if the block is complete.

interactive_expr: Begin If Verbatim Then LBRACE With
##
## Ends in an error in state: 324.
##
## clause_block -> LBRACE . sep_or_term_list(statement,SEMI) RBRACE [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## LBRACE
##
Ill-formed block of statements.
At this point, statements (instructions or declarations) separated by
semicolons ';' are expected and followed by a closing brace '}'.

interactive_expr: Begin If Verbatim Then Skip Else With
##
## Ends in an error in state: 498.
##
## conditional -> If expr Then if_clause option(SEMI) Else . if_clause [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## If expr Then if_clause option(SEMI) Else
##
Ill-formed conditional instruction.
At this point, one of the following is expected:
  * a single instruction;
  * a block of statements (instructions and declarations).

interactive_expr: Begin If Verbatim Then Skip With
##
## Ends in an error in state: 497.
##
## conditional -> If expr Then if_clause option(SEMI) . Else if_clause [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## If expr Then if_clause option(SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 496, spurious reduction of production option(SEMI) ->
##
Ill-formed conditional instruction.
At this point, if the 'then' branch is complete, the keyword 'else' is
expected, followed by one of the following:
  * a single instruction;
  * a block of statements (instructions and declarations).

interactive_expr: Begin If Verbatim Then With
##
## Ends in an error in state: 323.
##
## conditional -> If expr Then . if_clause option(SEMI) Else if_clause [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## If expr Then
##
Ill-formed conditional instruction.
At this point, one of the following is expected:
  * a single instruction;
  * a block of statements (instructions and declarations).

interactive_expr: Begin If Verbatim With
##
## Ends in an error in state: 322.
##
## conditional -> If expr . Then if_clause option(SEMI) Else if_clause [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## If expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 204, spurious reduction of production unary_expr -> core_expr
## In state 153, spurious reduction of production mult_expr -> unary_expr
## In state 180, spurious reduction of production add_expr -> mult_expr
## In state 210, spurious reduction of production cons_expr -> add_expr
## In state 207, spurious reduction of production cat_expr -> cons_expr
## In state 230, spurious reduction of production comp_expr -> cat_expr
## In state 217, spurious reduction of production set_membership -> comp_expr
## In state 155, spurious reduction of production conj_expr -> set_membership
## In state 234, spurious reduction of production disj_expr -> conj_expr
## In state 202, spurious reduction of production expr -> disj_expr
##
Ill-formed conditional instruction.
At this point, if the condition is complete, the keyword 'then' is
expected, followed by one of the following:
  * a single instruction;
  * a block of statements (instructions and declarations).

interactive_expr: Begin If With
##
## Ends in an error in state: 321.
##
## conditional -> If . expr Then if_clause option(SEMI) Else if_clause [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## If
##
Ill-formed conditional instruction.
At this point, a condition is expected as an expression.

interactive_expr: Begin Patch Constr DOT Ident With
##
## Ends in an error in state: 170.
##
## projection -> Constr DOT Ident . DOT nsepseq(selection,DOT) [ With VBAR SEMI RBRACKET RBRACE End Else EQ ]
##
## The known suffix of the stack is as follows:
## Constr DOT Ident
##
Ill-formed selection from a record or tuple.
At this a point, the selection operator '.' is expected, followed by
one of the following:
  * a record field name, if selecting from a record;
  * the index of a tuple component, '0' denoting the first component.

interactive_expr: Constr DOT Ident DOT With
##
## Ends in an error in state: 125.
##
## projection -> Constr DOT Ident DOT . nsepseq(selection,DOT) [ With VBAR Type To Then TIMES Step SLASH SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Mod MINUS LT LPAR LE LBRACKET GT GE Function From End Else EQ EOF Contains Const CONS COMMA COLON CAT Block Begin Attributes And ASS ARROW ]
##
## The known suffix of the stack is as follows:
## Constr DOT Ident DOT
##
interactive_expr: Ident DOT Int DOT With
##
## Ends in an error in state: 129.
##
## nsepseq(selection,DOT) -> selection DOT . nsepseq(selection,DOT) [ With VBAR Type To Then TIMES Step SLASH SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Mod MINUS LT LPAR LE LBRACKET GT GE Function From End Else EQ EOF Contains Const CONS COMMA COLON CAT Block Begin Attributes And ASS ARROW ]
##
## The known suffix of the stack is as follows:
## selection DOT
##
interactive_expr: Ident DOT With
##
## Ends in an error in state: 166.
##
## projection -> Ident DOT . nsepseq(selection,DOT) [ With VBAR Type To Then TIMES Step SLASH SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Mod MINUS LT LPAR LE LBRACKET GT GE Function From End Else EQ EOF Contains Const CONS COMMA COLON CAT Block Begin Attributes And ASS ARROW ]
##
## The known suffix of the stack is as follows:
## Ident DOT
##
Ill-formed selection from a record or a tuple.
At this point, one of the following is expected:
  * a record field name, if selecting from a record;
  * the index of a tuple component, '0' denoting the first component.

interactive_expr: Begin Patch Constr DOT With
##
## Ends in an error in state: 169.
##
## projection -> Constr DOT . Ident DOT nsepseq(selection,DOT) [ With VBAR SEMI RBRACKET RBRACE End Else EQ ]
##
## The known suffix of the stack is as follows:
## Constr DOT
##
Ill-formed selection from a module.
At this point, the name of a value declared in the module is expected.

interactive_expr: Begin Patch Constr With
##
## Ends in an error in state: 168.
##
## projection -> Constr . DOT Ident DOT nsepseq(selection,DOT) [ With VBAR SEMI RBRACKET RBRACE End Else EQ ]
##
## The known suffix of the stack is as follows:
## Constr
##
Ill-formed selection from a module.
At this point, the operator '.' is expected, followed by the name of a
value declared in the module.

interactive_expr: Begin Patch Ident While
##
## Ends in an error in state: 268.
##
## map_patch -> Patch path . With ne_injection(Map,binding) [ VBAR SEMI RBRACKET RBRACE End Else ]
## record_patch -> Patch path . With ne_injection(Record,field_assignment) [ VBAR SEMI RBRACKET RBRACE End Else ]
## set_patch -> Patch path . With ne_injection(Set,expr) [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## Patch path
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 165, spurious reduction of production path -> Ident
##
Ill-formed patch.
At this point, if the data structure (map, set or record) being
patched is fully qualified, the keyword 'with' is expected, followed
by the updates.

interactive_expr: Begin Patch Ident With Map LBRACKET Verbatim ARROW Bytes With
##
## Ends in an error in state: 302.
##
## ne_injection(Map,binding) -> Map LBRACKET sep_or_term_list(binding,SEMI) . RBRACKET [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## Map LBRACKET sep_or_term_list(binding,SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 204, spurious reduction of production unary_expr -> core_expr
## In state 153, spurious reduction of production mult_expr -> unary_expr
## In state 180, spurious reduction of production add_expr -> mult_expr
## In state 210, spurious reduction of production cons_expr -> add_expr
## In state 207, spurious reduction of production cat_expr -> cons_expr
## In state 230, spurious reduction of production comp_expr -> cat_expr
## In state 217, spurious reduction of production set_membership -> comp_expr
## In state 155, spurious reduction of production conj_expr -> set_membership
## In state 234, spurious reduction of production disj_expr -> conj_expr
## In state 202, spurious reduction of production expr -> disj_expr
## In state 308, spurious reduction of production binding -> expr ARROW expr
## In state 309, spurious reduction of production nsepseq(binding,SEMI) -> binding
## In state 305, spurious reduction of production sep_or_term_list(binding,SEMI) -> nsepseq(binding,SEMI)
##
Ill-formed map patch.
At this point, if the key/value binding is complete, one of the
following is expected:
  * more key/value bindings, separated by semicolons ';' and a closing
    bracket ']';
  * a closing bracket ']' if the map is complete.
Note: A binding is made of two expressions (a key and a value)
separated by an arrow '->'.

interactive_expr: Begin Patch Ident With Map LBRACKET With
##
## Ends in an error in state: 301.
##
## ne_injection(Map,binding) -> Map LBRACKET . sep_or_term_list(binding,SEMI) RBRACKET [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## Map LBRACKET
##
Ill-formed map patch.
At this point, key/value bindings are expected, separated by
semicolons ';' and followed by a closing bracket ']'.
Note: A binding is made of two expressions (a key and a value)
separated by an arrow '->'.

interactive_expr: Begin Patch Ident With Map Verbatim ARROW Bytes With
##
## Ends in an error in state: 316.
##
## ne_injection(Map,binding) -> Map sep_or_term_list(binding,SEMI) . End [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## Map sep_or_term_list(binding,SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 204, spurious reduction of production unary_expr -> core_expr
## In state 153, spurious reduction of production mult_expr -> unary_expr
## In state 180, spurious reduction of production add_expr -> mult_expr
## In state 210, spurious reduction of production cons_expr -> add_expr
## In state 207, spurious reduction of production cat_expr -> cons_expr
## In state 230, spurious reduction of production comp_expr -> cat_expr
## In state 217, spurious reduction of production set_membership -> comp_expr
## In state 155, spurious reduction of production conj_expr -> set_membership
## In state 234, spurious reduction of production disj_expr -> conj_expr
## In state 202, spurious reduction of production expr -> disj_expr
## In state 308, spurious reduction of production binding -> expr ARROW expr
## In state 309, spurious reduction of production nsepseq(binding,SEMI) -> binding
## In state 305, spurious reduction of production sep_or_term_list(binding,SEMI) -> nsepseq(binding,SEMI)
##
Ill-formed map patch.
At this point, if the key/value binding is complete, one of the following
is expected:
  * more key/value bindings (updates) separated by semicolons ';' and
    followed by the keyword 'end';
  * the keyword 'end' if the patch is complete.
Note: A binding is made of two expressions (a key and a value)
separated by an arrow '->'.

interactive_expr: Begin Patch Ident With Map With
##
## Ends in an error in state: 300.
##
## ne_injection(Map,binding) -> Map . sep_or_term_list(binding,SEMI) End [ VBAR SEMI RBRACKET RBRACE End Else ]
## ne_injection(Map,binding) -> Map . LBRACKET sep_or_term_list(binding,SEMI) RBRACKET [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## Map
##
Ill-formed map patch.
At this point, one of the following is expected:
  * key/value bindings (updates) separated by semicolons ';' and
    followed by the keyword 'end';
  * an opening bracket '[' followed by key/value bindings and a
    closing bracket ']'.
Note: A binding is made of two expressions (a key and a value)
separated by an arrow '->'.

interactive_expr: Begin Patch Ident With Record Ident EQ Bytes With
##
## Ends in an error in state: 298.
##
## ne_injection(Record,field_assignment) -> Record sep_or_term_list(field_assignment,SEMI) . End [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## Record sep_or_term_list(field_assignment,SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 204, spurious reduction of production unary_expr -> core_expr
## In state 153, spurious reduction of production mult_expr -> unary_expr
## In state 180, spurious reduction of production add_expr -> mult_expr
## In state 210, spurious reduction of production cons_expr -> add_expr
## In state 207, spurious reduction of production cat_expr -> cons_expr
## In state 230, spurious reduction of production comp_expr -> cat_expr
## In state 217, spurious reduction of production set_membership -> comp_expr
## In state 155, spurious reduction of production conj_expr -> set_membership
## In state 234, spurious reduction of production disj_expr -> conj_expr
## In state 202, spurious reduction of production expr -> disj_expr
## In state 568, spurious reduction of production field_assignment -> Ident EQ expr
## In state 291, spurious reduction of production nsepseq(field_assignment,SEMI) -> field_assignment
## In state 290, spurious reduction of production sep_or_term_list(field_assignment,SEMI) -> nsepseq(field_assignment,SEMI)
##
Ill-formed record patch.
At this point, if the field assignment (update) is complete, one of
the following is expected:
  * more field assignments (updates) separated by semicolons ';' and
    followed by the keyword 'end';
  * the keyword 'end' if the record is complete.

interactive_expr: Begin Patch Ident With Record LBRACKET Ident EQ Bytes With
##
## Ends in an error in state: 287.
##
## ne_injection(Record,field_assignment) -> Record LBRACKET sep_or_term_list(field_assignment,SEMI) . RBRACKET [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## Record LBRACKET sep_or_term_list(field_assignment,SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 204, spurious reduction of production unary_expr -> core_expr
## In state 153, spurious reduction of production mult_expr -> unary_expr
## In state 180, spurious reduction of production add_expr -> mult_expr
## In state 210, spurious reduction of production cons_expr -> add_expr
## In state 207, spurious reduction of production cat_expr -> cons_expr
## In state 230, spurious reduction of production comp_expr -> cat_expr
## In state 217, spurious reduction of production set_membership -> comp_expr
## In state 155, spurious reduction of production conj_expr -> set_membership
## In state 234, spurious reduction of production disj_expr -> conj_expr
## In state 202, spurious reduction of production expr -> disj_expr
## In state 568, spurious reduction of production field_assignment -> Ident EQ expr
## In state 291, spurious reduction of production nsepseq(field_assignment,SEMI) -> field_assignment
## In state 290, spurious reduction of production sep_or_term_list(field_assignment,SEMI) -> nsepseq(field_assignment,SEMI)
##
Ill-formed record patch.
At this point, if the field assignment (update) is complete, one of
the following is expected:
  * more field assignments (updates) separated by semicolons ';' and
    followed by a closing bracket ']';
  * a closing bracket ']' if the record is complete.

interactive_expr: Begin Patch Ident With Record LBRACKET With
##
## Ends in an error in state: 286.
##
## ne_injection(Record,field_assignment) -> Record LBRACKET . sep_or_term_list(field_assignment,SEMI) RBRACKET [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## Record LBRACKET
##
Ill-formed record patch.
At this point, assignments to record fields (updates) are expected,
separated by semicolons ';' and followed by a closing bracket ']'.

interactive_expr: Begin Patch Ident With Record With
##
## Ends in an error in state: 285.
##
## ne_injection(Record,field_assignment) -> Record . sep_or_term_list(field_assignment,SEMI) End [ VBAR SEMI RBRACKET RBRACE End Else ]
## ne_injection(Record,field_assignment) -> Record . LBRACKET sep_or_term_list(field_assignment,SEMI) RBRACKET [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## Record
##
Ill-formed record patch.
At this point, one of the following is expected:
  * assignments to record fields (updates), separated by semicolons
    ';' and followed by the keyword 'end';
  * an opening bracket '[' followed by assignments to record fields
    and a closing bracket ']'.

interactive_expr: Record With
##
## Ends in an error in state: 97.
##
## record_expr -> Record . sep_or_term_list(field_assignment,SEMI) End [ VBAR Type To Then TIMES Step SLASH SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Mod MINUS LT LE GT GE Function From End Else EQ EOF Contains Const CONS COMMA COLON CAT Block Begin Attributes And ARROW ]
## record_expr -> Record . LBRACKET sep_or_term_list(field_assignment,SEMI) RBRACKET [ VBAR Type To Then TIMES Step SLASH SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Mod MINUS LT LE GT GE Function From End Else EQ EOF Contains Const CONS COMMA COLON CAT Block Begin Attributes And ARROW ]
##
## The known suffix of the stack is as follows:
## Record
##
Ill-formed record expression.
At this point, assignments to record fields are expected and followed
by the keyword 'end'.

interactive_expr: Begin Patch Ident With Set LBRACKET Verbatim With
##
## Ends in an error in state: 272.
##
## ne_injection(Set,expr) -> Set LBRACKET sep_or_term_list(expr,SEMI) . RBRACKET [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## Set LBRACKET sep_or_term_list(expr,SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 204, spurious reduction of production unary_expr -> core_expr
## In state 153, spurious reduction of production mult_expr -> unary_expr
## In state 180, spurious reduction of production add_expr -> mult_expr
## In state 210, spurious reduction of production cons_expr -> add_expr
## In state 207, spurious reduction of production cat_expr -> cons_expr
## In state 230, spurious reduction of production comp_expr -> cat_expr
## In state 217, spurious reduction of production set_membership -> comp_expr
## In state 155, spurious reduction of production conj_expr -> set_membership
## In state 234, spurious reduction of production disj_expr -> conj_expr
## In state 202, spurious reduction of production expr -> disj_expr
## In state 276, spurious reduction of production nsepseq(expr,SEMI) -> expr
## In state 275, spurious reduction of production sep_or_term_list(expr,SEMI) -> nsepseq(expr,SEMI)
##
Ill-formed set patch.
At this point, if the set element (update) is complete, one of the
following is expected:
  * a semicolon ';' followed by more set elements (updates) and
    a closing bracket ']';
  * a closing bracket ']' if the set is complete.

interactive_expr: Begin Patch Ident With Set LBRACKET With
##
## Ends in an error in state: 271.
##
## ne_injection(Set,expr) -> Set LBRACKET . sep_or_term_list(expr,SEMI) RBRACKET [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## Set LBRACKET
##
Ill-formed set patch.
At this point, set elements (updates) separated by semicolons ';' are
expected and followed by a closing brace ']'.

interactive_expr: Begin Patch Ident With Set Verbatim With
##
## Ends in an error in state: 283.
##
## ne_injection(Set,expr) -> Set sep_or_term_list(expr,SEMI) . End [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## Set sep_or_term_list(expr,SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 204, spurious reduction of production unary_expr -> core_expr
## In state 153, spurious reduction of production mult_expr -> unary_expr
## In state 180, spurious reduction of production add_expr -> mult_expr
## In state 210, spurious reduction of production cons_expr -> add_expr
## In state 207, spurious reduction of production cat_expr -> cons_expr
## In state 230, spurious reduction of production comp_expr -> cat_expr
## In state 217, spurious reduction of production set_membership -> comp_expr
## In state 155, spurious reduction of production conj_expr -> set_membership
## In state 234, spurious reduction of production disj_expr -> conj_expr
## In state 202, spurious reduction of production expr -> disj_expr
## In state 276, spurious reduction of production nsepseq(expr,SEMI) -> expr
## In state 275, spurious reduction of production sep_or_term_list(expr,SEMI) -> nsepseq(expr,SEMI)
##
Ill-formed set patch.
At this point, if the set element (update) is complete, one of the
following is expected:
  * a semicolon ';' followed by more set elements (updates) and the
    keyword 'end';
  * the keyword 'end' if the patch is complete.

interactive_expr: Begin Patch Ident With Set With
##
## Ends in an error in state: 270.
##
## ne_injection(Set,expr) -> Set . sep_or_term_list(expr,SEMI) End [ VBAR SEMI RBRACKET RBRACE End Else ]
## ne_injection(Set,expr) -> Set . LBRACKET sep_or_term_list(expr,SEMI) RBRACKET [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## Set
##
Ill-formed set of expressions.
At this point, one of the following is expected:
  * set elements separated by semicolons ';' and followed by the
    keyword 'end';
  * an opening bracket '[', followed by set elements separated by
    semicolons ';' and followed by a closing bracket ']'.

interactive_expr: Begin Patch Ident With With
##
## Ends in an error in state: 269.
##
## map_patch -> Patch path With . ne_injection(Map,binding) [ VBAR SEMI RBRACKET RBRACE End Else ]
## record_patch -> Patch path With . ne_injection(Record,field_assignment) [ VBAR SEMI RBRACKET RBRACE End Else ]
## set_patch -> Patch path With . ne_injection(Set,expr) [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## Patch path With
##
Ill-formed patch.
At this point, one of the keywords 'map', 'record' or 'patch' is
expected, followed by the corresponding updates.

interactive_expr: Begin Patch With
##
## Ends in an error in state: 267.
##
## map_patch -> Patch . path With ne_injection(Map,binding) [ VBAR SEMI RBRACKET RBRACE End Else ]
## record_patch -> Patch . path With ne_injection(Record,field_assignment) [ VBAR SEMI RBRACKET RBRACE End Else ]
## set_patch -> Patch . path With ne_injection(Set,expr) [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## Patch
##
Ill-formed patch.
At this point, the fully qualified name of a record, a set or a map is
expected.

interactive_expr: Begin Remove Verbatim From Map With
##
## Ends in an error in state: 265.
##
## map_remove -> Remove expr From Map . path [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## Remove expr From Map
##
Ill-formed removal in a map.
At this point, the fully qualified name of a map is expected.

interactive_expr: Begin Remove Verbatim From Set With
##
## Ends in an error in state: 263.
##
## set_remove -> Remove expr From Set . path [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## Remove expr From Set
##
Ill-formed removal in a set.
At this point, the fully qualified name of a set is expected.

interactive_expr: Begin Remove Verbatim From With
##
## Ends in an error in state: 262.
##
## map_remove -> Remove expr From . Map path [ VBAR SEMI RBRACKET RBRACE End Else ]
## set_remove -> Remove expr From . Set path [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## Remove expr From
##
Ill-formed removal in a map or a set.
At this point, either the keyword 'map' or 'set' is expected.

interactive_expr: Begin Remove Verbatim With
##
## Ends in an error in state: 261.
##
## map_remove -> Remove expr . From Map path [ VBAR SEMI RBRACKET RBRACE End Else ]
## set_remove -> Remove expr . From Set path [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## Remove expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 204, spurious reduction of production unary_expr -> core_expr
## In state 153, spurious reduction of production mult_expr -> unary_expr
## In state 180, spurious reduction of production add_expr -> mult_expr
## In state 210, spurious reduction of production cons_expr -> add_expr
## In state 207, spurious reduction of production cat_expr -> cons_expr
## In state 230, spurious reduction of production comp_expr -> cat_expr
## In state 217, spurious reduction of production set_membership -> comp_expr
## In state 155, spurious reduction of production conj_expr -> set_membership
## In state 234, spurious reduction of production disj_expr -> conj_expr
## In state 202, spurious reduction of production expr -> disj_expr
##
Ill-formed removal in a map or a set.
At this point, if the expression denoting the collection is complete,
the keyword 'from' is expected, followed by the keyword 'map' or
'set'.

interactive_expr: Begin Remove With
##
## Ends in an error in state: 260.
##
## map_remove -> Remove . expr From Map path [ VBAR SEMI RBRACKET RBRACE End Else ]
## set_remove -> Remove . expr From Set path [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## Remove
##
Ill-formed removal in a map or a set.
At this point, one of the following is expected:
  * if removing an element from a set, that set element as an
    expression;
  * if removing a binding from a map, the key of that binding as an
    expression.
Note: A binding is made of two expressions (a key and a value)
separated by an arrow '->'.

interactive_expr: Begin Skip End While
##
## Ends in an error in state: 238.
##
## block_with -> block . With expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Function From End Else EOF Const COMMA Block Begin Attributes ARROW ]
##
## The known suffix of the stack is as follows:
## block
##
Ill-formed block of instructions.
At this point, the keyword 'with' is expected, followed by an
expression whose value is that of the whole block.

interactive_expr: Begin Skip End With With
##
## Ends in an error in state: 239.
##
## block_with -> block With . expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Function From End Else EOF Const COMMA Block Begin Attributes ARROW ]
##
## The known suffix of the stack is as follows:
## block With
##
Ill-formed block of instructions.
At this point, an expression is expected, whose value is that of the
block.

interactive_expr: Begin Skip With
##
## Ends in an error in state: 500.
##
## block -> Begin sep_or_term_list(statement,SEMI) . End [ With VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## Begin sep_or_term_list(statement,SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 478, spurious reduction of production nsepseq(statement,SEMI) -> statement
## In state 495, spurious reduction of production sep_or_term_list(statement,SEMI) -> nsepseq(statement,SEMI)
##
Ill-formed block of statements.
At this point, if the statement is complete, one of the following is
expected:
  * a semicolon ';' followed by more statements (instructions and
    declarations) and concluded by the keyword 'end';
  * the keyword 'end' if the block is complete.

interactive_expr: Begin Var Ident ASS With
##
## Ends in an error in state: 151.
##
## unqualified_decl(ASS) -> Ident option(type_annot) ASS . expr [ SEMI RBRACE End ]
##
## The known suffix of the stack is as follows:
## Ident option(type_annot) ASS
##
Ill-formed variable declaration.
At this point, an expression is expected, whose value is the initial
value of the variable being defined.

interactive_expr: Begin Var Ident COLON Constr ARROW
##
## Ends in an error in state: 150.
##
## unqualified_decl(ASS) -> Ident option(type_annot) . ASS expr [ SEMI RBRACE End ]
##
## The known suffix of the stack is as follows:
## Ident option(type_annot)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 27, spurious reduction of production variant -> Constr
## In state 39, spurious reduction of production nsepseq(variant,VBAR) -> variant
## In state 42, spurious reduction of production sum_type -> option(VBAR) nsepseq(variant,VBAR)
## In state 23, spurious reduction of production type_expr -> sum_type
## In state 88, spurious reduction of production type_annot -> COLON type_expr
## In state 89, spurious reduction of production option(type_annot) -> type_annot
##
Ill-formed variable declaration.
At this point, if the type annotation is complete, the assignment
operator ':=' is expected, followed by the expression whose value is
the initial value of the variable being defined.

interactive_expr: Begin Var Ident With
##
## Ends in an error in state: 149.
##
## unqualified_decl(ASS) -> Ident . option(type_annot) ASS expr [ SEMI RBRACE End ]
##
## The known suffix of the stack is as follows:
## Ident
##
Ill-formed variable declaration.
At this point, one of the following is expected:
  * a type annotation introduced by a colon ':';
  * the assignment operator ':=' followed by an expression whose
    value is the initial value of the variable being defined.

interactive_expr: Begin Var With
##
## Ends in an error in state: 148.
##
## open_var_decl -> Var . unqualified_decl(ASS) [ SEMI RBRACE End ]
##
## The known suffix of the stack is as follows:
## Var
##
Ill-formed variable declaration.
At this point, a variable name is expected.

interactive_expr: Begin While Verbatim With
##
## Ends in an error in state: 507.
##
## while_loop -> While expr . block [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## While expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 204, spurious reduction of production unary_expr -> core_expr
## In state 153, spurious reduction of production mult_expr -> unary_expr
## In state 180, spurious reduction of production add_expr -> mult_expr
## In state 210, spurious reduction of production cons_expr -> add_expr
## In state 207, spurious reduction of production cat_expr -> cons_expr
## In state 230, spurious reduction of production comp_expr -> cat_expr
## In state 217, spurious reduction of production set_membership -> comp_expr
## In state 155, spurious reduction of production conj_expr -> set_membership
## In state 234, spurious reduction of production disj_expr -> conj_expr
## In state 202, spurious reduction of production expr -> disj_expr
##
Ill-formed general loop.
At this point, if the condition is complete, the body of the loop is
expected as a block of instructions.

interactive_expr: Begin While With
##
## Ends in an error in state: 143.
##
## while_loop -> While . expr block [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## While
##
Ill-formed general loop.
At this point, the condition is expected as an expression.

interactive_expr: Begin With
##
## Ends in an error in state: 147.
##
## block -> Begin . sep_or_term_list(statement,SEMI) End [ With VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## Begin
##
Ill-formed block of statements.
At this point, one of the following statements is expected:
  * the declaration of a variable, a constant or a function;
  * an instruction (conditional, case, assignment, loop, patch,
    removal, skip).

interactive_expr: BigMap LBRACKET Verbatim ARROW Bytes With
##
## Ends in an error in state: 502.
##
## injection(BigMap,binding) -> BigMap LBRACKET sep_or_term_list(binding,SEMI) . RBRACKET [ VBAR Type To Then TIMES Step SLASH SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Mod MINUS LT LE GT GE Function From End Else EQ EOF Contains Const CONS COMMA COLON CAT Block Begin Attributes And ARROW ]
##
## The known suffix of the stack is as follows:
## BigMap LBRACKET sep_or_term_list(binding,SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 204, spurious reduction of production unary_expr -> core_expr
## In state 153, spurious reduction of production mult_expr -> unary_expr
## In state 180, spurious reduction of production add_expr -> mult_expr
## In state 210, spurious reduction of production cons_expr -> add_expr
## In state 207, spurious reduction of production cat_expr -> cons_expr
## In state 230, spurious reduction of production comp_expr -> cat_expr
## In state 217, spurious reduction of production set_membership -> comp_expr
## In state 155, spurious reduction of production conj_expr -> set_membership
## In state 234, spurious reduction of production disj_expr -> conj_expr
## In state 202, spurious reduction of production expr -> disj_expr
## In state 308, spurious reduction of production binding -> expr ARROW expr
## In state 309, spurious reduction of production nsepseq(binding,SEMI) -> binding
## In state 305, spurious reduction of production sep_or_term_list(binding,SEMI) -> nsepseq(binding,SEMI)
##
Ill-formed big_map expression.
At this point, if the key/value binding is complete, one of the
following is expected:
  * a semicolon ';' followed by more bindings and a closing bracket
    ']';
  * a closing bracket ']' if the big_map is complete.
Note: A binding is made of two expressions (a key and a value)
separated by an arrow '->'.

interactive_expr: BigMap LBRACKET With
##
## Ends in an error in state: 145.
##
## injection(BigMap,binding) -> BigMap LBRACKET . sep_or_term_list(binding,SEMI) RBRACKET [ VBAR Type To Then TIMES Step SLASH SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Mod MINUS LT LE GT GE Function From End Else EQ EOF Contains Const CONS COMMA COLON CAT Block Begin Attributes And ARROW ]
## injection(BigMap,binding) -> BigMap LBRACKET . RBRACKET [ VBAR Type To Then TIMES Step SLASH SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Mod MINUS LT LE GT GE Function From End Else EQ EOF Contains Const CONS COMMA COLON CAT Block Begin Attributes And ARROW ]
##
## The known suffix of the stack is as follows:
## BigMap LBRACKET
##
Ill-formed big_map expression.
At this point, one of the following is expected:
  * key/value bindings separated by semicolons ';' and concluded by a
    closing bracket ']';
  * a closing bracket ']' if the big_map is empty.
Note: A binding is made of two expressions (a key and a value)
separated by an arrow '->'.

interactive_expr: BigMap Verbatim ARROW Bytes With
##
## Ends in an error in state: 505.
##
## injection(BigMap,binding) -> BigMap sep_or_term_list(binding,SEMI) . End [ VBAR Type To Then TIMES Step SLASH SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Mod MINUS LT LE GT GE Function From End Else EQ EOF Contains Const CONS COMMA COLON CAT Block Begin Attributes And ARROW ]
##
## The known suffix of the stack is as follows:
## BigMap sep_or_term_list(binding,SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 204, spurious reduction of production unary_expr -> core_expr
## In state 153, spurious reduction of production mult_expr -> unary_expr
## In state 180, spurious reduction of production add_expr -> mult_expr
## In state 210, spurious reduction of production cons_expr -> add_expr
## In state 207, spurious reduction of production cat_expr -> cons_expr
## In state 230, spurious reduction of production comp_expr -> cat_expr
## In state 217, spurious reduction of production set_membership -> comp_expr
## In state 155, spurious reduction of production conj_expr -> set_membership
## In state 234, spurious reduction of production disj_expr -> conj_expr
## In state 202, spurious reduction of production expr -> disj_expr
## In state 308, spurious reduction of production binding -> expr ARROW expr
## In state 309, spurious reduction of production nsepseq(binding,SEMI) -> binding
## In state 305, spurious reduction of production sep_or_term_list(binding,SEMI) -> nsepseq(binding,SEMI)
##
Ill-formed big_map expression.
At this point, if the key/value binding is complete, one of the
following is expected:
  * a semicolon ';' followed by more bindings and concluded by the
    keyword 'end';
    * the keyword 'end' if the big_map is complete.
Note: A binding is made of two expressions (a key and a value)
separated by an arrow '->'.

interactive_expr: BigMap With
##
## Ends in an error in state: 144.
##
## injection(BigMap,binding) -> BigMap . sep_or_term_list(binding,SEMI) End [ VBAR Type To Then TIMES Step SLASH SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Mod MINUS LT LE GT GE Function From End Else EQ EOF Contains Const CONS COMMA COLON CAT Block Begin Attributes And ARROW ]
## injection(BigMap,binding) -> BigMap . End [ VBAR Type To Then TIMES Step SLASH SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Mod MINUS LT LE GT GE Function From End Else EQ EOF Contains Const CONS COMMA COLON CAT Block Begin Attributes And ARROW ]
## injection(BigMap,binding) -> BigMap . LBRACKET sep_or_term_list(binding,SEMI) RBRACKET [ VBAR Type To Then TIMES Step SLASH SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Mod MINUS LT LE GT GE Function From End Else EQ EOF Contains Const CONS COMMA COLON CAT Block Begin Attributes And ARROW ]
## injection(BigMap,binding) -> BigMap . LBRACKET RBRACKET [ VBAR Type To Then TIMES Step SLASH SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Mod MINUS LT LE GT GE Function From End Else EQ EOF Contains Const CONS COMMA COLON CAT Block Begin Attributes And ARROW ]
##
## The known suffix of the stack is as follows:
## BigMap
##
Ill-formed big_map expression.
At this point, one of the following is expected:
  * key/value bindings separated by semicolons ';' and concluded by
    the keyword 'end';
  * an opening bracket '[' followed by key/value bindings,
    or none (empty big_map), and a closing bracket ']';
  * the keyword 'end' if the big_map is empty.
Note: A binding is made of two expressions (a key and a value)
separated by an arrow '->'.

interactive_expr: Block LBRACE Skip With
##
## Ends in an error in state: 509.
##
## block -> Block LBRACE sep_or_term_list(statement,SEMI) . RBRACE [ With VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## Block LBRACE sep_or_term_list(statement,SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 478, spurious reduction of production nsepseq(statement,SEMI) -> statement
## In state 495, spurious reduction of production sep_or_term_list(statement,SEMI) -> nsepseq(statement,SEMI)
##
Ill-formed block of statements.
At this point, if the statement is complete, a closing brace '}' is
expected.

interactive_expr: Block LBRACE With
##
## Ends in an error in state: 142.
##
## block -> Block LBRACE . sep_or_term_list(statement,SEMI) RBRACE [ With VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## Block LBRACE
##
Ill-formed block of statements.
At this point, statements (instructions and declarations) are
expected, separated or terminated by semicolons ';', and concluded by
a closing brace '}'.

interactive_expr: Block With
##
## Ends in an error in state: 141.
##
## block -> Block . LBRACE sep_or_term_list(statement,SEMI) RBRACE [ With VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## Block
##
Ill-formed block of statements.
At this point, an opening brace '{' is expected, followed by
statements (instructions and declarations) separated or terminated by
semicolons ';', and concluded by a closing brace '}'.

interactive_expr: C_Some With
##
## Ends in an error in state: 137.
##
## core_expr -> C_Some . arguments [ VBAR Type To Then TIMES Step SLASH SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Mod MINUS LT LE GT GE Function From End Else EQ EOF Contains Const CONS COMMA COLON CAT Block Begin Attributes And ARROW ]
##
## The known suffix of the stack is as follows:
## C_Some
##
Ill-formed application of the constructor 'Some'.
At this point, its arguments are expected as a tuple of expressions.

interactive_expr: Case Verbatim Of C_Some LPAR WILD With
##
## Ends in an error in state: 390.
##
## par(core_pattern) -> LPAR core_pattern . RPAR [ SEMI RPAR RBRACKET End CONS COMMA ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR core_pattern
##
Ill-formed application of the constructor 'Some' in a pattern.
At this point, if the pattern is complete, a closing parenthesis ')'
is expected

interactive_expr: Case Verbatim Of C_Some LPAR With
##
## Ends in an error in state: 382.
##
## par(core_pattern) -> LPAR . core_pattern RPAR [ SEMI RPAR RBRACKET End CONS COMMA ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR
##
Ill-formed application of the constructor 'Some' in a pattern.
At this point, its parameter is expected as a pattern.

interactive_expr: Case Verbatim Of C_Some With
##
## Ends in an error in state: 381.
##
## constr_pattern -> C_Some . par(core_pattern) [ SEMI RPAR RBRACKET End CONS COMMA ARROW ]
##
## The known suffix of the stack is as follows:
## C_Some
##
Ill-formed application of the constructor 'Some' in a pattern.
At this point, its parameters are expected in a tuple of patterns.

interactive_expr: Case Verbatim Of Constr LPAR With
##
## Ends in an error in state: 380.
##
## par(nsepseq(core_pattern,COMMA)) -> LPAR . nsepseq(core_pattern,COMMA) RPAR [ SEMI RPAR RBRACKET End CONS COMMA ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR
##
Ill-formed tuple of patterns.
At this point, the first component is expected as a pattern.

interactive_expr: Case Verbatim Of LBRACKET WILD ARROW Bytes With
##
## Ends in an error in state: 519.
##
## case(expr) -> Case expr Of LBRACKET option(VBAR) cases(expr) . RBRACKET [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Function From End Else EOF Const COMMA Block Begin Attributes ARROW ]
##
## The known suffix of the stack is as follows:
## Case expr Of LBRACKET option(VBAR) cases(expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 204, spurious reduction of production unary_expr -> core_expr
## In state 153, spurious reduction of production mult_expr -> unary_expr
## In state 180, spurious reduction of production add_expr -> mult_expr
## In state 210, spurious reduction of production cons_expr -> add_expr
## In state 207, spurious reduction of production cat_expr -> cons_expr
## In state 230, spurious reduction of production comp_expr -> cat_expr
## In state 217, spurious reduction of production set_membership -> comp_expr
## In state 155, spurious reduction of production conj_expr -> set_membership
## In state 234, spurious reduction of production disj_expr -> conj_expr
## In state 202, spurious reduction of production expr -> disj_expr
## In state 517, spurious reduction of production case_clause(expr) -> pattern ARROW expr
## In state 521, spurious reduction of production nsepseq(case_clause(expr),VBAR) -> case_clause(expr)
## In state 518, spurious reduction of production cases(expr) -> nsepseq(case_clause(expr),VBAR)
##
Ill-formed case expression.
At this point, if the case clause is complete, one of the following is
expected:
  * more clauses, separated by vertical bars '|';
  * a closing bracket ']' if the case is complete.

interactive_expr: Case Verbatim Of LBRACKET With
##
## Ends in an error in state: 514.
##
## case(expr) -> Case expr Of LBRACKET option(VBAR) . cases(expr) RBRACKET [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Function From End Else EOF Const COMMA Block Begin Attributes ARROW ]
##
## The known suffix of the stack is as follows:
## Case expr Of LBRACKET option(VBAR)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 513, spurious reduction of production option(VBAR) ->
##
interactive_expr: Case Verbatim Of With
##
## Ends in an error in state: 524.
##
## case(expr) -> Case expr Of option(VBAR) . cases(expr) End [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Function From End Else EOF Const COMMA Block Begin Attributes ARROW ]
##
## The known suffix of the stack is as follows:
## Case expr Of option(VBAR)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 512, spurious reduction of production option(VBAR) ->
##
interactive_expr: Case Verbatim Of WILD ARROW Bytes VBAR With
##
## Ends in an error in state: 522.
##
## nsepseq(case_clause(expr),VBAR) -> case_clause(expr) VBAR . nsepseq(case_clause(expr),VBAR) [ RBRACKET End ]
##
## The known suffix of the stack is as follows:
## case_clause(expr) VBAR
##
Ill-formed case expression.
At this point, a case clause is expected, starting with a pattern.

interactive_expr: Case Verbatim Of LPAR WILD COMMA With
##
## Ends in an error in state: 397.
##
## nsepseq(core_pattern,COMMA) -> core_pattern COMMA . nsepseq(core_pattern,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## core_pattern COMMA
##
Ill-formed tuple of patterns in a case expression.
At this point, a tuple component is expected as a pattern.

interactive_expr: Case Verbatim Of LPAR WILD CONS Bytes With
##
## Ends in an error in state: 409.
##
## par(cons_pattern) -> LPAR cons_pattern . RPAR [ SEMI RPAR RBRACKET End CONS COMMA ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR cons_pattern
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 403, spurious reduction of production pattern -> core_pattern
## In state 402, spurious reduction of production cons_pattern -> core_pattern CONS pattern
##
Ill-formed case expression.
At this point, if the list pattern is complete, a closing parenthesis
')' is expected.

interactive_expr: Case Verbatim Of LPAR WILD CONS With
##
## Ends in an error in state: 401.
##
## cons_pattern -> core_pattern CONS . pattern [ RPAR ]
##
## The known suffix of the stack is as follows:
## core_pattern CONS
##
Ill-formed list pattern.
At this point, a pattern matching a list is expected.

interactive_expr: Case Verbatim Of LPAR WILD With
##
## Ends in an error in state: 394.
##
## par(nsepseq(core_pattern,COMMA)) -> LPAR nsepseq(core_pattern,COMMA) . RPAR [ SEMI RPAR RBRACKET End CONS COMMA ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR nsepseq(core_pattern,COMMA)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 400, spurious reduction of production nsepseq(core_pattern,COMMA) -> core_pattern
##
Ill-formed tuple of patterns.
At this point, if the tuple component is complete, one of the
following is expected:
  * a comma ',' followed by another component as a pattern;
  * a closing parenthesis ')' if the tuple is complete

interactive_expr: Case Verbatim Of LPAR With
##
## Ends in an error in state: 375.
##
## par(cons_pattern) -> LPAR . cons_pattern RPAR [ SEMI RPAR RBRACKET End CONS COMMA ARROW ]
## par(nsepseq(core_pattern,COMMA)) -> LPAR . nsepseq(core_pattern,COMMA) RPAR [ SEMI RPAR RBRACKET End CONS COMMA ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR
##
Ill-formed list pattern.
At this point, a pattern matching non-empty lists is expected.

interactive_expr: Case Verbatim Of List LBRACKET WILD With
##
## Ends in an error in state: 413.
##
## injection(List,core_pattern) -> List LBRACKET sep_or_term_list(core_pattern,SEMI) . RBRACKET [ SEMI RPAR RBRACKET End CONS COMMA ARROW ]
##
## The known suffix of the stack is as follows:
## List LBRACKET sep_or_term_list(core_pattern,SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 417, spurious reduction of production nsepseq(core_pattern,SEMI) -> core_pattern
## In state 416, spurious reduction of production sep_or_term_list(core_pattern,SEMI) -> nsepseq(core_pattern,SEMI)
##
Ill-formed list of patterns.
At this point, if pattern matching a list element is complete, one of
the following is expected:
  * a semicolon ';' followed by another pattern;
  * a closing bracket ']' if the list is complete.

interactive_expr: Case Verbatim Of List LBRACKET With
##
## Ends in an error in state: 411.
##
## injection(List,core_pattern) -> List LBRACKET . sep_or_term_list(core_pattern,SEMI) RBRACKET [ SEMI RPAR RBRACKET End CONS COMMA ARROW ]
## injection(List,core_pattern) -> List LBRACKET . RBRACKET [ SEMI RPAR RBRACKET End CONS COMMA ARROW ]
##
## The known suffix of the stack is as follows:
## List LBRACKET
##
Ill-formed list of patterns.
At this point, one of the following is expected:
  * patterns matching list elements and separated by semicolons ';';
  * a closing bracket ']' if matching the empty list.

interactive_expr: Case Verbatim Of List WILD With
##
## Ends in an error in state: 425.
##
## injection(List,core_pattern) -> List sep_or_term_list(core_pattern,SEMI) . End [ SEMI RPAR RBRACKET End CONS COMMA ARROW ]
##
## The known suffix of the stack is as follows:
## List sep_or_term_list(core_pattern,SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 417, spurious reduction of production nsepseq(core_pattern,SEMI) -> core_pattern
## In state 416, spurious reduction of production sep_or_term_list(core_pattern,SEMI) -> nsepseq(core_pattern,SEMI)
##
Ill-formed list of patterns.
At this point, if pattern matching a list element is complete, one of
the following is expected:
  * a semicolon ';' followed by another pattern;
  * the keyword 'end' if the list is complete.

interactive_expr: Case Verbatim Of List With
##
## Ends in an error in state: 374.
##
## injection(List,core_pattern) -> List . sep_or_term_list(core_pattern,SEMI) End [ SEMI RPAR RBRACKET End CONS COMMA ARROW ]
## injection(List,core_pattern) -> List . End [ SEMI RPAR RBRACKET End CONS COMMA ARROW ]
## injection(List,core_pattern) -> List . LBRACKET sep_or_term_list(core_pattern,SEMI) RBRACKET [ SEMI RPAR RBRACKET End CONS COMMA ARROW ]
## injection(List,core_pattern) -> List . LBRACKET RBRACKET [ SEMI RPAR RBRACKET End CONS COMMA ARROW ]
##
## The known suffix of the stack is as follows:
## List
##
Ill-formed list of patterns.
At this point, one of the following is expected:
  * patterns matching list elements, separated by semicolons ';';
  * an opening bracket '[' followed by patterns separated by
    semicolons ';', and a closing bracket ']';
  * the brackets '[]' or the keyword 'end' if matching the empty list.

interactive_expr: Case Verbatim Of WILD ARROW Bytes With
##
## Ends in an error in state: 525.
##
## case(expr) -> Case expr Of option(VBAR) cases(expr) . End [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Function From End Else EOF Const COMMA Block Begin Attributes ARROW ]
##
## The known suffix of the stack is as follows:
## Case expr Of option(VBAR) cases(expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 204, spurious reduction of production unary_expr -> core_expr
## In state 153, spurious reduction of production mult_expr -> unary_expr
## In state 180, spurious reduction of production add_expr -> mult_expr
## In state 210, spurious reduction of production cons_expr -> add_expr
## In state 207, spurious reduction of production cat_expr -> cons_expr
## In state 230, spurious reduction of production comp_expr -> cat_expr
## In state 217, spurious reduction of production set_membership -> comp_expr
## In state 155, spurious reduction of production conj_expr -> set_membership
## In state 234, spurious reduction of production disj_expr -> conj_expr
## In state 202, spurious reduction of production expr -> disj_expr
## In state 517, spurious reduction of production case_clause(expr) -> pattern ARROW expr
## In state 521, spurious reduction of production nsepseq(case_clause(expr),VBAR) -> case_clause(expr)
## In state 518, spurious reduction of production cases(expr) -> nsepseq(case_clause(expr),VBAR)
##
Ill-formed case expression
At this point, if the clause is complete, one of the following is
expected:
  * more clauses starting by a pattern and separated by vertical bars
    '|';
  * the keyword 'end' if the case is complete.

interactive_expr: Case Verbatim Of WILD ARROW With
##
## Ends in an error in state: 516.
##
## case_clause(expr) -> pattern ARROW . expr [ VBAR RBRACKET End ]
##
## The known suffix of the stack is as follows:
## pattern ARROW
##
Ill-formed clause of a case expression.
At this point, the right-hand side of the clause is expected as an
expression.

interactive_expr: Case Verbatim Of WILD CONS WILD CONS With
##
## Ends in an error in state: 407.
##
## nsepseq(core_pattern,CONS) -> core_pattern CONS . nsepseq(core_pattern,CONS) [ RPAR ARROW ]
##
## The known suffix of the stack is as follows:
## core_pattern CONS
##
interactive_expr: Case Verbatim Of WILD CONS With
##
## Ends in an error in state: 404.
##
## pattern -> core_pattern CONS . nsepseq(core_pattern,CONS) [ RPAR ARROW ]
##
## The known suffix of the stack is as follows:
## core_pattern CONS
##
Ill-formed list of patterns.
At this point, a pattern matching a non-empty list is expected.

interactive_expr: Case Verbatim Of WILD With
##
## Ends in an error in state: 515.
##
## case_clause(expr) -> pattern . ARROW expr [ VBAR RBRACKET End ]
##
## The known suffix of the stack is as follows:
## pattern
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 403, spurious reduction of production pattern -> core_pattern
##
Ill-formed case clause.
At this point, if the pattern is complete, an arrow '->' is expected,
followed by the right-hand side as an expression.

interactive_expr: Case Verbatim With
##
## Ends in an error in state: 511.
##
## case(expr) -> Case expr . Of option(VBAR) cases(expr) End [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Function From End Else EOF Const COMMA Block Begin Attributes ARROW ]
## case(expr) -> Case expr . Of LBRACKET option(VBAR) cases(expr) RBRACKET [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Function From End Else EOF Const COMMA Block Begin Attributes ARROW ]
##
## The known suffix of the stack is as follows:
## Case expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 204, spurious reduction of production unary_expr -> core_expr
## In state 153, spurious reduction of production mult_expr -> unary_expr
## In state 180, spurious reduction of production add_expr -> mult_expr
## In state 210, spurious reduction of production cons_expr -> add_expr
## In state 207, spurious reduction of production cat_expr -> cons_expr
## In state 230, spurious reduction of production comp_expr -> cat_expr
## In state 217, spurious reduction of production set_membership -> comp_expr
## In state 155, spurious reduction of production conj_expr -> set_membership
## In state 234, spurious reduction of production disj_expr -> conj_expr
## In state 202, spurious reduction of production expr -> disj_expr
##
Ill-formed case expression.
At this point, if the condition is complete, the keyword 'of' is
expected, followed by case clauses separated by vertical bars '|'.

interactive_expr: Case With
##
## Ends in an error in state: 136.
##
## case(expr) -> Case . expr Of option(VBAR) cases(expr) End [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Function From End Else EOF Const COMMA Block Begin Attributes ARROW ]
## case(expr) -> Case . expr Of LBRACKET option(VBAR) cases(expr) RBRACKET [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Function From End Else EOF Const COMMA Block Begin Attributes ARROW ]
##
## The known suffix of the stack is as follows:
## Case
##
Ill-formed case expression.
At this point, the condition is expected as an expression.

interactive_expr: Constr DOT With
##
## Ends in an error in state: 120.
##
## module_field -> Constr DOT . module_fun [ VBAR Type To Then TIMES Step SLASH SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Mod MINUS LT LPAR LE GT GE Function From End Else EQ EOF Contains Const CONS COMMA COLON CAT Block Begin Attributes And ARROW ]
## projection -> Constr DOT . Ident DOT nsepseq(selection,DOT) [ With VBAR Type To Then TIMES Step SLASH SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Mod MINUS LT LPAR LE LBRACKET GT GE Function From End Else EQ EOF Contains Const CONS COMMA COLON CAT Block Begin Attributes And ASS ARROW ]
##
## The known suffix of the stack is as follows:
## Constr DOT
##
Ill-formed selection from a module.
At this point, a function name is expected.

interactive_expr: Function LPAR Const Ident RPAR COLON Ident With
##
## Ends in an error in state: 116.
##
## fun_expr -> Function parameters option(type_annot) . Is expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Function From End Else EOF Const COMMA Block Begin Attributes ARROW ]
##
## The known suffix of the stack is as follows:
## Function parameters option(type_annot)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 16, spurious reduction of production core_type -> Ident
## In state 30, spurious reduction of production cartesian -> core_type
## In state 36, spurious reduction of production fun_type -> cartesian
## In state 44, spurious reduction of production type_expr -> fun_type
## In state 88, spurious reduction of production type_annot -> COLON type_expr
## In state 89, spurious reduction of production option(type_annot) -> type_annot
##
Ill-formed function expression.
At this point, the keyword 'is' keyword is expected, followed with the
function body as an expression or a block of statements (instructions
or declarations) ending with an expression.

interactive_expr: Function LPAR Const Ident RPAR Is With
##
## Ends in an error in state: 117.
##
## fun_expr -> Function parameters option(type_annot) Is . expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Function From End Else EOF Const COMMA Block Begin Attributes ARROW ]
##
## The known suffix of the stack is as follows:
## Function parameters option(type_annot) Is
##
Ill-formed function expression.
At this point, the function body is expected as an expression.

interactive_expr: Function LPAR Const Ident RPAR With
##
## Ends in an error in state: 115.
##
## fun_expr -> Function parameters . option(type_annot) Is expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Function From End Else EOF Const COMMA Block Begin Attributes ARROW ]
##
## The known suffix of the stack is as follows:
## Function parameters
##
Ill-formed function expression.
At this point, one of the following is expected:
  * a type annotation for the returned value;
  * the keyword 'is' followed by the function body as an expression.

interactive_expr: Function LPAR Const Ident With
##
## Ends in an error in state: 79.
##
## param_decl -> Const Ident . option(param_type) [ SEMI RPAR ]
##
## The known suffix of the stack is as follows:
## Const Ident
##
interactive_expr: Function LPAR Var Ident With
##
## Ends in an error in state: 73.
##
## param_decl -> Var Ident . option(param_type) [ SEMI RPAR ]
##
## The known suffix of the stack is as follows:
## Var Ident
##
Ill-formed function parameter declaration.
At this point, one of the following is expected:
  * a type annotation starting with a colon ':';
  * a semicolon ';' followed with another parameter declaration;
  * a closing parenthesis ')' if no more parameters.

interactive_expr: Function LPAR Const With
##
## Ends in an error in state: 78.
##
## param_decl -> Const . Ident option(param_type) [ SEMI RPAR ]
##
## The known suffix of the stack is as follows:
## Const
##
Ill-formed function parameter declaration.
At this point, the name of the constant parameter is expected.

interactive_expr: Function LPAR Var Ident COLON String With
##
## Ends in an error in state: 84.
##
## par(nsepseq(param_decl,SEMI)) -> LPAR nsepseq(param_decl,SEMI) . RPAR [ Is COLON ]
##
## The known suffix of the stack is as follows:
## LPAR nsepseq(param_decl,SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 30, spurious reduction of production cartesian -> core_type
## In state 36, spurious reduction of production fun_type -> cartesian
## In state 75, spurious reduction of production param_type -> COLON fun_type
## In state 76, spurious reduction of production option(param_type) -> param_type
## In state 77, spurious reduction of production param_decl -> Var Ident option(param_type)
## In state 81, spurious reduction of production nsepseq(param_decl,SEMI) -> param_decl
##
Ill-formed function parameter declaration.
At this point, if the parameter declaration is complete, a closing
parenthesis ')' is expected.

interactive_expr: Function LPAR Var Ident COLON With
##
## Ends in an error in state: 74.
##
## param_type -> COLON . fun_type [ SEMI RPAR ]
##
## The known suffix of the stack is as follows:
## COLON
##
Ill-formed function parameter type.
At this point, a type is expected.

interactive_expr: Function LPAR Var Ident SEMI With
##
## Ends in an error in state: 82.
##
## nsepseq(param_decl,SEMI) -> param_decl SEMI . nsepseq(param_decl,SEMI) [ RPAR ]
##
## The known suffix of the stack is as follows:
## param_decl SEMI
##
Ill-formed function parameters.
At this point, a function parameter declaration is expected.

interactive_expr: Function LPAR Var With
##
## Ends in an error in state: 72.
##
## param_decl -> Var . Ident option(param_type) [ SEMI RPAR ]
##
## The known suffix of the stack is as follows:
## Var
##
Ill-formed function parameter declaration.
At this point, the name of the variable parameter is expected.

interactive_expr: Function LPAR With
##
## Ends in an error in state: 71.
##
## par(nsepseq(param_decl,SEMI)) -> LPAR . nsepseq(param_decl,SEMI) RPAR [ Is COLON ]
##
## The known suffix of the stack is as follows:
## LPAR
##
Ill-formed function parameter declaration.
At this point, a parameter declaration is expected.

interactive_expr: Function With
##
## Ends in an error in state: 114.
##
## fun_expr -> Function . parameters option(type_annot) Is expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Function From End Else EOF Const COMMA Block Begin Attributes ARROW ]
##
## The known suffix of the stack is as follows:
## Function
##
Ill-formed function expression.
At this point, parameter declarations between parentheses are expected.

interactive_expr: Ident DOT Ident While
##
## Ends in an error in state: 158.
##
## fun_call_or_par_or_projection -> projection . option(arguments) [ VBAR Type To Then TIMES Step SLASH SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Mod MINUS LT LE GT GE Function From End Else EQ EOF Contains Const CONS COMMA COLON CAT Block Begin Attributes And ARROW ]
## path -> projection . [ With LBRACKET ]
##
## The known suffix of the stack is as follows:
## projection
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 128, spurious reduction of production nsepseq(selection,DOT) -> selection
## In state 167, spurious reduction of production projection -> Ident DOT nsepseq(selection,DOT)
##
<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Ident LBRACKET Verbatim With
##
## Ends in an error in state: 254.
##
## brackets(expr) -> LBRACKET expr . RBRACKET [ VBAR Type To Then TIMES Step SLASH SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Mod MINUS LT LE GT GE Function From End Else EQ EOF Contains Const CONS COMMA COLON CAT Block Begin Attributes And ASS ARROW ]
##
## The known suffix of the stack is as follows:
## LBRACKET expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 204, spurious reduction of production unary_expr -> core_expr
## In state 153, spurious reduction of production mult_expr -> unary_expr
## In state 180, spurious reduction of production add_expr -> mult_expr
## In state 210, spurious reduction of production cons_expr -> add_expr
## In state 207, spurious reduction of production cat_expr -> cons_expr
## In state 230, spurious reduction of production comp_expr -> cat_expr
## In state 217, spurious reduction of production set_membership -> comp_expr
## In state 155, spurious reduction of production conj_expr -> set_membership
## In state 234, spurious reduction of production disj_expr -> conj_expr
## In state 202, spurious reduction of production expr -> disj_expr
##
Ill-formed map lookup.
At this point, if the key is complete, a closing bracket ']' is
expected.

interactive_expr: Ident LBRACKET With
##
## Ends in an error in state: 253.
##
## brackets(expr) -> LBRACKET . expr RBRACKET [ VBAR Type To Then TIMES Step SLASH SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Mod MINUS LT LE GT GE Function From End Else EQ EOF Contains Const CONS COMMA COLON CAT Block Begin Attributes And ASS ARROW ]
##
## The known suffix of the stack is as follows:
## LBRACKET
##
Ill-formed map lookup.
At this point, a key is expected as an expression.

interactive_expr: Ident LPAR Verbatim COMMA With
##
## Ends in an error in state: 531.
##
## nsepseq(expr,COMMA) -> expr COMMA . nsepseq(expr,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## expr COMMA
##
Ill-formed tuple expression.
At this point, another component is expected as an expression.

interactive_expr: Ident LPAR Verbatim With
##
## Ends in an error in state: 528.
##
## par(nsepseq(expr,COMMA)) -> LPAR nsepseq(expr,COMMA) . RPAR [ VBAR Type To Then TIMES Step SLASH SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Mod MINUS LT LE GT GE Function From End Else EQ EOF Contains Const CONS COMMA COLON CAT Block Begin Attributes And ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR nsepseq(expr,COMMA)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 204, spurious reduction of production unary_expr -> core_expr
## In state 153, spurious reduction of production mult_expr -> unary_expr
## In state 180, spurious reduction of production add_expr -> mult_expr
## In state 210, spurious reduction of production cons_expr -> add_expr
## In state 207, spurious reduction of production cat_expr -> cons_expr
## In state 230, spurious reduction of production comp_expr -> cat_expr
## In state 217, spurious reduction of production set_membership -> comp_expr
## In state 155, spurious reduction of production conj_expr -> set_membership
## In state 234, spurious reduction of production disj_expr -> conj_expr
## In state 202, spurious reduction of production expr -> disj_expr
## In state 530, spurious reduction of production nsepseq(expr,COMMA) -> expr
##
Ill-formed function call.
At this point, if the argument is complete, a closing parenthesis ')'
is expected.

interactive_expr: Ident LPAR With
##
## Ends in an error in state: 113.
##
## par(nsepseq(expr,COMMA)) -> LPAR . nsepseq(expr,COMMA) RPAR [ VBAR Type To Then TIMES Step SLASH SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Mod MINUS LT LE GT GE Function From End Else EQ EOF Contains Const CONS COMMA COLON CAT Block Begin Attributes And ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR
##
Ill-formed function call.
At this point, an argument is expected as an expression.

interactive_expr: Ident While
##
## Ends in an error in state: 112.
##
## core_expr -> Ident . [ VBAR Type To Then TIMES Step SLASH SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Mod MINUS LT LE GT GE Function From End Else EQ EOF Contains Const CONS COMMA COLON CAT Block Begin Attributes And ARROW ]
## fun_call -> Ident . arguments [ VBAR Type To Then TIMES Step SLASH SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Mod MINUS LT LE GT GE Function From End Else EQ EOF Contains Const CONS COMMA COLON CAT Block Begin Attributes And ARROW ]
## path -> Ident . [ With LBRACKET ]
## projection -> Ident . DOT nsepseq(selection,DOT) [ With VBAR Type To Then TIMES Step SLASH SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Mod MINUS LT LPAR LE LBRACKET GT GE Function From End Else EQ EOF Contains Const CONS COMMA COLON CAT Block Begin Attributes And ARROW ]
##
## The known suffix of the stack is as follows:
## Ident
##
<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Ident With Record Ident EQ Bytes With
##
## Ends in an error in state: 250.
##
## ne_injection(Record,field_path_assignment) -> Record sep_or_term_list(field_path_assignment,SEMI) . End [ VBAR Type To Then TIMES Step SLASH SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Mod MINUS LT LE GT GE Function From End Else EQ EOF Contains Const CONS COMMA COLON CAT Block Begin Attributes And ARROW ]
##
## The known suffix of the stack is as follows:
## Record sep_or_term_list(field_path_assignment,SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 204, spurious reduction of production unary_expr -> core_expr
## In state 153, spurious reduction of production mult_expr -> unary_expr
## In state 180, spurious reduction of production add_expr -> mult_expr
## In state 210, spurious reduction of production cons_expr -> add_expr
## In state 207, spurious reduction of production cat_expr -> cons_expr
## In state 230, spurious reduction of production comp_expr -> cat_expr
## In state 217, spurious reduction of production set_membership -> comp_expr
## In state 155, spurious reduction of production conj_expr -> set_membership
## In state 234, spurious reduction of production disj_expr -> conj_expr
## In state 202, spurious reduction of production expr -> disj_expr
## In state 201, spurious reduction of production field_path_assignment -> path EQ expr
## In state 243, spurious reduction of production nsepseq(field_path_assignment,SEMI) -> field_path_assignment
## In state 242, spurious reduction of production sep_or_term_list(field_path_assignment,SEMI) -> nsepseq(field_path_assignment,SEMI)
##
Ill-formed record update.
At this point, if the field update is complete, one of the following is expected:
  * more field updates (assignments) separated by semicolons ';';
  * the keyword 'end' if the record update is complete.

interactive_expr: Ident With Record Ident With
##
## Ends in an error in state: 174.
##
## field_path_assignment -> path . EQ expr [ SEMI RBRACKET End ]
##
## The known suffix of the stack is as follows:
## path
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 165, spurious reduction of production path -> Ident
##
Ill-formed record update.
At this point, if the field to update is fully qualified, the
defitional equality '=' is expected, followed by an expression whose
value is the new value of the field.

interactive_expr: Ident With Record LBRACKET Ident EQ Bytes With
##
## Ends in an error in state: 171.
##
## ne_injection(Record,field_path_assignment) -> Record LBRACKET sep_or_term_list(field_path_assignment,SEMI) . RBRACKET [ VBAR Type To Then TIMES Step SLASH SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Mod MINUS LT LE GT GE Function From End Else EQ EOF Contains Const CONS COMMA COLON CAT Block Begin Attributes And ARROW ]
##
## The known suffix of the stack is as follows:
## Record LBRACKET sep_or_term_list(field_path_assignment,SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 204, spurious reduction of production unary_expr -> core_expr
## In state 153, spurious reduction of production mult_expr -> unary_expr
## In state 180, spurious reduction of production add_expr -> mult_expr
## In state 210, spurious reduction of production cons_expr -> add_expr
## In state 207, spurious reduction of production cat_expr -> cons_expr
## In state 230, spurious reduction of production comp_expr -> cat_expr
## In state 217, spurious reduction of production set_membership -> comp_expr
## In state 155, spurious reduction of production conj_expr -> set_membership
## In state 234, spurious reduction of production disj_expr -> conj_expr
## In state 202, spurious reduction of production expr -> disj_expr
## In state 201, spurious reduction of production field_path_assignment -> path EQ expr
## In state 243, spurious reduction of production nsepseq(field_path_assignment,SEMI) -> field_path_assignment
## In state 242, spurious reduction of production sep_or_term_list(field_path_assignment,SEMI) -> nsepseq(field_path_assignment,SEMI)
##
Ill-formed record update.
At this point, if the field assignment is complete, one of the
following is expected:
  * another field assignment (update);
  * a closing brace '}' if the update is complete.

interactive_expr: Ident With Record LBRACKET With
##
## Ends in an error in state: 164.
##
## ne_injection(Record,field_path_assignment) -> Record LBRACKET . sep_or_term_list(field_path_assignment,SEMI) RBRACKET [ VBAR Type To Then TIMES Step SLASH SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Mod MINUS LT LE GT GE Function From End Else EQ EOF Contains Const CONS COMMA COLON CAT Block Begin Attributes And ARROW ]
##
## The known suffix of the stack is as follows:
## Record LBRACKET
##
Ill-formed record update.
At this point, a field assignment (update) is expected.

interactive_expr: Ident With Record With
##
## Ends in an error in state: 163.
##
## ne_injection(Record,field_path_assignment) -> Record . sep_or_term_list(field_path_assignment,SEMI) End [ VBAR Type To Then TIMES Step SLASH SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Mod MINUS LT LE GT GE Function From End Else EQ EOF Contains Const CONS COMMA COLON CAT Block Begin Attributes And ARROW ]
## ne_injection(Record,field_path_assignment) -> Record . LBRACKET sep_or_term_list(field_path_assignment,SEMI) RBRACKET [ VBAR Type To Then TIMES Step SLASH SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Mod MINUS LT LE GT GE Function From End Else EQ EOF Contains Const CONS COMMA COLON CAT Block Begin Attributes And ARROW ]
##
## The known suffix of the stack is as follows:
## Record
##
Ill-formed record update.
At this point, one of the following is expected:
  * a series of field assignments (updates), separated by semicolons ';';
  * an opening bracket '[' followed by field assignments and a closing
    bracket ']'.

interactive_expr: Ident With With
##
## Ends in an error in state: 162.
##
## record_update -> path With . ne_injection(Record,field_path_assignment) [ VBAR Type To Then TIMES Step SLASH SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Mod MINUS LT LE GT GE Function From End Else EQ EOF Contains Const CONS COMMA COLON CAT Block Begin Attributes And ARROW ]
##
## The known suffix of the stack is as follows:
## path With
##
Ill-formed record update.
At this point, the keyword 'record' is expected, followed by field
assignments (updates) separated by semicolons ';'.

interactive_expr: If Verbatim Then Verbatim With
##
## Ends in an error in state: 536.
##
## cond_expr -> If expr Then expr option(SEMI) . Else expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Function From End Else EOF Const COMMA Block Begin Attributes ARROW ]
##
## The known suffix of the stack is as follows:
## If expr Then expr option(SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 204, spurious reduction of production unary_expr -> core_expr
## In state 153, spurious reduction of production mult_expr -> unary_expr
## In state 180, spurious reduction of production add_expr -> mult_expr
## In state 210, spurious reduction of production cons_expr -> add_expr
## In state 207, spurious reduction of production cat_expr -> cons_expr
## In state 230, spurious reduction of production comp_expr -> cat_expr
## In state 217, spurious reduction of production set_membership -> comp_expr
## In state 155, spurious reduction of production conj_expr -> set_membership
## In state 234, spurious reduction of production disj_expr -> conj_expr
## In state 202, spurious reduction of production expr -> disj_expr
## In state 535, spurious reduction of production option(SEMI) ->
##
Ill-formed conditional expression.
At this point, if the expression of the 'then' branch is complete, the
keyword 'else' is expected, followed by an expression.

interactive_expr: If Verbatim Then Verbatim Else With
##
## Ends in an error in state: 537.
##
## cond_expr -> If expr Then expr option(SEMI) Else . expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Function From End Else EOF Const COMMA Block Begin Attributes ARROW ]
##
## The known suffix of the stack is as follows:
## If expr Then expr option(SEMI) Else
##
Ill-formed conditional expression.
At this point, the keyword 'else' is expected, followed by an expression.

interactive_expr: If Verbatim Then With
##
## Ends in an error in state: 534.
##
## cond_expr -> If expr Then . expr option(SEMI) Else expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Function From End Else EOF Const COMMA Block Begin Attributes ARROW ]
##
## The known suffix of the stack is as follows:
## If expr Then
##
Ill-formed conditional expression.
At this point, the contents of the 'then' branch is expected as an
expression.

interactive_expr: If Verbatim With
##
## Ends in an error in state: 533.
##
## cond_expr -> If expr . Then expr option(SEMI) Else expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Function From End Else EOF Const COMMA Block Begin Attributes ARROW ]
##
## The known suffix of the stack is as follows:
## If expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 204, spurious reduction of production unary_expr -> core_expr
## In state 153, spurious reduction of production mult_expr -> unary_expr
## In state 180, spurious reduction of production add_expr -> mult_expr
## In state 210, spurious reduction of production cons_expr -> add_expr
## In state 207, spurious reduction of production cat_expr -> cons_expr
## In state 230, spurious reduction of production comp_expr -> cat_expr
## In state 217, spurious reduction of production set_membership -> comp_expr
## In state 155, spurious reduction of production conj_expr -> set_membership
## In state 234, spurious reduction of production disj_expr -> conj_expr
## In state 202, spurious reduction of production expr -> disj_expr
##
Ill-formed conditional expression.
At this point, if the condition is complete, the keyword 'then' is
expected, followed by an expression.

interactive_expr: If With
##
## Ends in an error in state: 111.
##
## cond_expr -> If . expr Then expr option(SEMI) Else expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Function From End Else EOF Const COMMA Block Begin Attributes ARROW ]
##
## The known suffix of the stack is as follows:
## If
##
Ill-formed if conditional expression.
At this point, the condition is expected as an expression.

interactive_expr: LPAR Verbatim COLON Ident With
##
## Ends in an error in state: 548.
##
## par(annot_expr) -> LPAR annot_expr . RPAR [ VBAR Type To Then TIMES Step SLASH SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Mod MINUS LT LE GT GE Function From End Else EQ EOF Contains Const CONS COMMA COLON CAT Block Begin Attributes And ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR annot_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 16, spurious reduction of production core_type -> Ident
## In state 30, spurious reduction of production cartesian -> core_type
## In state 36, spurious reduction of production fun_type -> cartesian
## In state 44, spurious reduction of production type_expr -> fun_type
## In state 547, spurious reduction of production annot_expr -> disj_expr COLON type_expr
##
Ill-formed annotated expression.
At this point, if the type annotation is complete, a closing
parenthesis ')' is expected.

interactive_expr: LPAR Verbatim COMMA Bytes With
##
## Ends in an error in state: 539.
##
## par(tuple_comp) -> LPAR tuple_comp . RPAR [ VBAR Type To Then TIMES Step SLASH SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Mod MINUS LT LE GT GE Function From End Else EQ EOF Contains Const CONS COMMA COLON CAT Block Begin Attributes And ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR tuple_comp
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 204, spurious reduction of production unary_expr -> core_expr
## In state 153, spurious reduction of production mult_expr -> unary_expr
## In state 180, spurious reduction of production add_expr -> mult_expr
## In state 210, spurious reduction of production cons_expr -> add_expr
## In state 207, spurious reduction of production cat_expr -> cons_expr
## In state 230, spurious reduction of production comp_expr -> cat_expr
## In state 217, spurious reduction of production set_membership -> comp_expr
## In state 155, spurious reduction of production conj_expr -> set_membership
## In state 234, spurious reduction of production disj_expr -> conj_expr
## In state 202, spurious reduction of production expr -> disj_expr
## In state 530, spurious reduction of production nsepseq(expr,COMMA) -> expr
## In state 544, spurious reduction of production tuple_comp -> expr COMMA nsepseq(expr,COMMA)
##
Ill-formed tuple expression.
At this point, if the component is complete, one of the following is
expected:
  * a comma ',' followed by another component as an expression;
  * a closing parenthesis ')' if the tuple is complete.

interactive_expr: LPAR Verbatim COMMA With
##
## Ends in an error in state: 543.
##
## tuple_comp -> expr COMMA . nsepseq(expr,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## expr COMMA
##
Ill-formed tuple expression.
At this point, a tuple component is expected as an expression.

interactive_expr: LPAR Verbatim With
##
## Ends in an error in state: 541.
##
## par(expr) -> LPAR expr . RPAR [ VBAR Type To Then TIMES Step SLASH SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Mod MINUS LT LPAR LE GT GE Function From End Else EQ EOF Contains Const CONS COMMA COLON CAT Block Begin Attributes And ARROW ]
## tuple_comp -> expr . COMMA nsepseq(expr,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## LPAR expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 204, spurious reduction of production unary_expr -> core_expr
## In state 153, spurious reduction of production mult_expr -> unary_expr
## In state 180, spurious reduction of production add_expr -> mult_expr
## In state 210, spurious reduction of production cons_expr -> add_expr
## In state 207, spurious reduction of production cat_expr -> cons_expr
## In state 230, spurious reduction of production comp_expr -> cat_expr
## In state 217, spurious reduction of production set_membership -> comp_expr
## In state 155, spurious reduction of production conj_expr -> set_membership
## In state 234, spurious reduction of production disj_expr -> conj_expr
## In state 545, spurious reduction of production expr -> disj_expr
##
Ill-formed expression.
At this point, if the expression is complete, one of the following is
expected:
  * a comma ',' followed by an expression if defining a tuple;
  * a closing parenthesis ')' if defining a parenthesised expression.

interactive_expr: LPAR With
##
## Ends in an error in state: 109.
##
## par(annot_expr) -> LPAR . annot_expr RPAR [ VBAR Type To Then TIMES Step SLASH SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Mod MINUS LT LE GT GE Function From End Else EQ EOF Contains Const CONS COMMA COLON CAT Block Begin Attributes And ARROW ]
## par(expr) -> LPAR . expr RPAR [ VBAR Type To Then TIMES Step SLASH SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Mod MINUS LT LPAR LE GT GE Function From End Else EQ EOF Contains Const CONS COMMA COLON CAT Block Begin Attributes And ARROW ]
## par(tuple_comp) -> LPAR . tuple_comp RPAR [ VBAR Type To Then TIMES Step SLASH SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Mod MINUS LT LE GT GE Function From End Else EQ EOF Contains Const CONS COMMA COLON CAT Block Begin Attributes And ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR
##
Ill-formed expression.
At this point, an expression is expected, denoting either
  * an annotated expression,
  * a parenthesised expression, or
  * a tuple component.

interactive_expr: Lang Verbatim With
##
## Ends in an error in state: 550.
##
## code_inj -> Lang expr . RBRACKET [ VBAR Type To Then TIMES Step SLASH SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Mod MINUS LT LE GT GE Function From End Else EQ EOF Contains Const CONS COMMA COLON CAT Block Begin Attributes And ARROW ]
##
## The known suffix of the stack is as follows:
## Lang expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 204, spurious reduction of production unary_expr -> core_expr
## In state 153, spurious reduction of production mult_expr -> unary_expr
## In state 180, spurious reduction of production add_expr -> mult_expr
## In state 210, spurious reduction of production cons_expr -> add_expr
## In state 207, spurious reduction of production cat_expr -> cons_expr
## In state 230, spurious reduction of production comp_expr -> cat_expr
## In state 217, spurious reduction of production set_membership -> comp_expr
## In state 155, spurious reduction of production conj_expr -> set_membership
## In state 234, spurious reduction of production disj_expr -> conj_expr
## In state 202, spurious reduction of production expr -> disj_expr
##
Ill-formed code injection.
At this point, if the expression denoting the code to inject is
complete, then a closing bracket ']' is expected.

interactive_expr: Lang With
##
## Ends in an error in state: 108.
##
## code_inj -> Lang . expr RBRACKET [ VBAR Type To Then TIMES Step SLASH SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Mod MINUS LT LE GT GE Function From End Else EQ EOF Contains Const CONS COMMA COLON CAT Block Begin Attributes And ARROW ]
##
## The known suffix of the stack is as follows:
## Lang
##
Ill-formed code injection.
At this point, the code is expected as an expression evaluating to a
string.

interactive_expr: List LBRACKET Verbatim With
##
## Ends in an error in state: 554.
##
## injection(List,expr) -> List LBRACKET sep_or_term_list(expr,SEMI) . RBRACKET [ VBAR Type To Then TIMES Step SLASH SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Mod MINUS LT LE GT GE Function From End Else EQ EOF Contains Const CONS COMMA COLON CAT Block Begin Attributes And ARROW ]
##
## The known suffix of the stack is as follows:
## List LBRACKET sep_or_term_list(expr,SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 204, spurious reduction of production unary_expr -> core_expr
## In state 153, spurious reduction of production mult_expr -> unary_expr
## In state 180, spurious reduction of production add_expr -> mult_expr
## In state 210, spurious reduction of production cons_expr -> add_expr
## In state 207, spurious reduction of production cat_expr -> cons_expr
## In state 230, spurious reduction of production comp_expr -> cat_expr
## In state 217, spurious reduction of production set_membership -> comp_expr
## In state 155, spurious reduction of production conj_expr -> set_membership
## In state 234, spurious reduction of production disj_expr -> conj_expr
## In state 202, spurious reduction of production expr -> disj_expr
## In state 276, spurious reduction of production nsepseq(expr,SEMI) -> expr
## In state 275, spurious reduction of production sep_or_term_list(expr,SEMI) -> nsepseq(expr,SEMI)
##
Ill-formed list of expressions.
At this point, if the list element is complete, one of the following
is expected:
  * a semicolon ';' followed by another element as an expression;
  * a closing bracket ']' if the list is complete.

interactive_expr: List LBRACKET With
##
## Ends in an error in state: 552.
##
## injection(List,expr) -> List LBRACKET . sep_or_term_list(expr,SEMI) RBRACKET [ VBAR Type To Then TIMES Step SLASH SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Mod MINUS LT LE GT GE Function From End Else EQ EOF Contains Const CONS COMMA COLON CAT Block Begin Attributes And ARROW ]
## injection(List,expr) -> List LBRACKET . RBRACKET [ VBAR Type To Then TIMES Step SLASH SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Mod MINUS LT LE GT GE Function From End Else EQ EOF Contains Const CONS COMMA COLON CAT Block Begin Attributes And ARROW ]
##
## The known suffix of the stack is as follows:
## List LBRACKET
##
Ill-formed list of expressions.
At this point, one of the following is expected:
  * a series of list elements as expressions separated by semicolons ';';
  * a closing bracket ']' if the list is empty.

interactive_expr: List Verbatim With
##
## Ends in an error in state: 557.
##
## injection(List,expr) -> List sep_or_term_list(expr,SEMI) . End [ VBAR Type To Then TIMES Step SLASH SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Mod MINUS LT LE GT GE Function From End Else EQ EOF Contains Const CONS COMMA COLON CAT Block Begin Attributes And ARROW ]
##
## The known suffix of the stack is as follows:
## List sep_or_term_list(expr,SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 204, spurious reduction of production unary_expr -> core_expr
## In state 153, spurious reduction of production mult_expr -> unary_expr
## In state 180, spurious reduction of production add_expr -> mult_expr
## In state 210, spurious reduction of production cons_expr -> add_expr
## In state 207, spurious reduction of production cat_expr -> cons_expr
## In state 230, spurious reduction of production comp_expr -> cat_expr
## In state 217, spurious reduction of production set_membership -> comp_expr
## In state 155, spurious reduction of production conj_expr -> set_membership
## In state 234, spurious reduction of production disj_expr -> conj_expr
## In state 202, spurious reduction of production expr -> disj_expr
## In state 276, spurious reduction of production nsepseq(expr,SEMI) -> expr
## In state 275, spurious reduction of production sep_or_term_list(expr,SEMI) -> nsepseq(expr,SEMI)
##
Ill-formed list of expressions.
At this point, if the list element is complete, one of the following
is expected:
  * a semicolon ';' followed by another element as an expression;
  * the keyword 'end' if the list is complete.

interactive_expr: List With
##
## Ends in an error in state: 107.
##
## injection(List,expr) -> List . sep_or_term_list(expr,SEMI) End [ VBAR Type To Then TIMES Step SLASH SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Mod MINUS LT LE GT GE Function From End Else EQ EOF Contains Const CONS COMMA COLON CAT Block Begin Attributes And ARROW ]
## injection(List,expr) -> List . End [ VBAR Type To Then TIMES Step SLASH SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Mod MINUS LT LE GT GE Function From End Else EQ EOF Contains Const CONS COMMA COLON CAT Block Begin Attributes And ARROW ]
## injection(List,expr) -> List . LBRACKET sep_or_term_list(expr,SEMI) RBRACKET [ VBAR Type To Then TIMES Step SLASH SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Mod MINUS LT LE GT GE Function From End Else EQ EOF Contains Const CONS COMMA COLON CAT Block Begin Attributes And ARROW ]
## injection(List,expr) -> List . LBRACKET RBRACKET [ VBAR Type To Then TIMES Step SLASH SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Mod MINUS LT LE GT GE Function From End Else EQ EOF Contains Const CONS COMMA COLON CAT Block Begin Attributes And ARROW ]
##
## The known suffix of the stack is as follows:
## List
##
Ill-formed list of expressions.
At this point, one of the following is expected:
  * list elements as expressions separated by semicolons ';';
  * an opening bracket '[' followed by expressions separated by
    semicolons ';', and a closing bracket ']';
  * the brackets '[]' or the keyword 'end' if the list is empty.

interactive_expr: MINUS With
##
## Ends in an error in state: 106.
##
## unary_expr -> MINUS . core_expr [ VBAR Type To Then TIMES Step SLASH SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Mod MINUS LT LE GT GE Function From End Else EQ EOF Const CONS COMMA COLON CAT Block Begin Attributes And ARROW ]
##
## The known suffix of the stack is as follows:
## MINUS
##
Ill-formed unary expression.
At this point, an expression is expected.

interactive_expr: Map LBRACKET Verbatim ARROW Bytes With
##
## Ends in an error in state: 562.
##
## injection(Map,binding) -> Map LBRACKET sep_or_term_list(binding,SEMI) . RBRACKET [ VBAR Type To Then TIMES Step SLASH SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Mod MINUS LT LE GT GE Function From End Else EQ EOF Contains Const CONS COMMA COLON CAT Block Begin Attributes And ARROW ]
##
## The known suffix of the stack is as follows:
## Map LBRACKET sep_or_term_list(binding,SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 204, spurious reduction of production unary_expr -> core_expr
## In state 153, spurious reduction of production mult_expr -> unary_expr
## In state 180, spurious reduction of production add_expr -> mult_expr
## In state 210, spurious reduction of production cons_expr -> add_expr
## In state 207, spurious reduction of production cat_expr -> cons_expr
## In state 230, spurious reduction of production comp_expr -> cat_expr
## In state 217, spurious reduction of production set_membership -> comp_expr
## In state 155, spurious reduction of production conj_expr -> set_membership
## In state 234, spurious reduction of production disj_expr -> conj_expr
## In state 202, spurious reduction of production expr -> disj_expr
## In state 308, spurious reduction of production binding -> expr ARROW expr
## In state 309, spurious reduction of production nsepseq(binding,SEMI) -> binding
## In state 305, spurious reduction of production sep_or_term_list(binding,SEMI) -> nsepseq(binding,SEMI)
##
Ill-formed map expression.
At this point, if the key/value binding is complete, one of the
following is expected:
  * a semicolon ';' followed by another key/value binding;
  * a closing bracket ']' if the map is complete.
Note: A binding is made of two expressions (a key and a value)
separated by an arrow '->'.

interactive_expr: Map LBRACKET With
##
## Ends in an error in state: 560.
##
## injection(Map,binding) -> Map LBRACKET . sep_or_term_list(binding,SEMI) RBRACKET [ VBAR Type To Then TIMES Step SLASH SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Mod MINUS LT LE GT GE Function From End Else EQ EOF Contains Const CONS COMMA COLON CAT Block Begin Attributes And ARROW ]
## injection(Map,binding) -> Map LBRACKET . RBRACKET [ VBAR Type To Then TIMES Step SLASH SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Mod MINUS LT LE GT GE Function From End Else EQ EOF Contains Const CONS COMMA COLON CAT Block Begin Attributes And ARROW ]
##
## The known suffix of the stack is as follows:
## Map LBRACKET
##
Ill-formed map expression.
At this point, one of the following is expected:
  * a key/value binding;
  * a closing bracket ']' if the map is empty.
Note: A binding is made of two expressions (a key and a value)
separated by an arrow '->'.

interactive_expr: Map Verbatim ARROW Bytes With
##
## Ends in an error in state: 565.
##
## injection(Map,binding) -> Map sep_or_term_list(binding,SEMI) . End [ VBAR Type To Then TIMES Step SLASH SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Mod MINUS LT LE GT GE Function From End Else EQ EOF Contains Const CONS COMMA COLON CAT Block Begin Attributes And ARROW ]
##
## The known suffix of the stack is as follows:
## Map sep_or_term_list(binding,SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 204, spurious reduction of production unary_expr -> core_expr
## In state 153, spurious reduction of production mult_expr -> unary_expr
## In state 180, spurious reduction of production add_expr -> mult_expr
## In state 210, spurious reduction of production cons_expr -> add_expr
## In state 207, spurious reduction of production cat_expr -> cons_expr
## In state 230, spurious reduction of production comp_expr -> cat_expr
## In state 217, spurious reduction of production set_membership -> comp_expr
## In state 155, spurious reduction of production conj_expr -> set_membership
## In state 234, spurious reduction of production disj_expr -> conj_expr
## In state 202, spurious reduction of production expr -> disj_expr
## In state 308, spurious reduction of production binding -> expr ARROW expr
## In state 309, spurious reduction of production nsepseq(binding,SEMI) -> binding
## In state 305, spurious reduction of production sep_or_term_list(binding,SEMI) -> nsepseq(binding,SEMI)
##
Ill-formed map expression.
At this point, if the key/value binding is complete, one of the
following is expected:
  * a semicolon ';' followed by another key/value binding;
  * the keyword 'end' keyword if the map is complete.
Note: A binding is made of two expressions (a key and a value)
separated by an arrow '->'.

interactive_expr: Map Verbatim ARROW With
##
## Ends in an error in state: 307.
##
## binding -> expr ARROW . expr [ SEMI RBRACKET End ]
##
## The known suffix of the stack is as follows:
## expr ARROW
##
Ill-formed key/value binding in a map.
At this point, the value is expected as an expression.
Note: A binding is made of two expressions (a key and a value)
separated by an arrow '->'.

interactive_expr: Map Verbatim With
##
## Ends in an error in state: 306.
##
## binding -> expr . ARROW expr [ SEMI RBRACKET End ]
##
## The known suffix of the stack is as follows:
## expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 204, spurious reduction of production unary_expr -> core_expr
## In state 153, spurious reduction of production mult_expr -> unary_expr
## In state 180, spurious reduction of production add_expr -> mult_expr
## In state 210, spurious reduction of production cons_expr -> add_expr
## In state 207, spurious reduction of production cat_expr -> cons_expr
## In state 230, spurious reduction of production comp_expr -> cat_expr
## In state 217, spurious reduction of production set_membership -> comp_expr
## In state 155, spurious reduction of production conj_expr -> set_membership
## In state 234, spurious reduction of production disj_expr -> conj_expr
## In state 202, spurious reduction of production expr -> disj_expr
##
Ill-formed map expression.
At this point, if the key is complete, an arrow '->' is expected,
  followed with a value in the form of an expression.

interactive_expr: Map With
##
## Ends in an error in state: 105.
##
## injection(Map,binding) -> Map . sep_or_term_list(binding,SEMI) End [ VBAR Type To Then TIMES Step SLASH SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Mod MINUS LT LE GT GE Function From End Else EQ EOF Contains Const CONS COMMA COLON CAT Block Begin Attributes And ARROW ]
## injection(Map,binding) -> Map . End [ VBAR Type To Then TIMES Step SLASH SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Mod MINUS LT LE GT GE Function From End Else EQ EOF Contains Const CONS COMMA COLON CAT Block Begin Attributes And ARROW ]
## injection(Map,binding) -> Map . LBRACKET sep_or_term_list(binding,SEMI) RBRACKET [ VBAR Type To Then TIMES Step SLASH SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Mod MINUS LT LE GT GE Function From End Else EQ EOF Contains Const CONS COMMA COLON CAT Block Begin Attributes And ARROW ]
## injection(Map,binding) -> Map . LBRACKET RBRACKET [ VBAR Type To Then TIMES Step SLASH SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Mod MINUS LT LE GT GE Function From End Else EQ EOF Contains Const CONS COMMA COLON CAT Block Begin Attributes And ARROW ]
##
## The known suffix of the stack is as follows:
## Map
##

Ill-formed map expression.
At this point one of the following is expected:
  a semicolon ';' separated list of key/value bindings,
    which are closed with the 'end' keyword; or
  the 'end' keyword if the map is empty; or
  an opening bracket '[',
    followed with one of the following:
      a semicolon ';' separated list of key/value bindings,
        which are closed by a bracket; or
    a closing bracket ']' if the map is empty.

interactive_expr: Not With
##
## Ends in an error in state: 101.
##
## unary_expr -> Not . core_expr [ VBAR Type To Then TIMES Step SLASH SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Mod MINUS LT LE GT GE Function From End Else EQ EOF Const CONS COMMA COLON CAT Block Begin Attributes And ARROW ]
##
## The known suffix of the stack is as follows:
## Not
##

Ill-formed unary expression.
At this point an expression is expected.

interactive_expr: Record Ident EQ Bytes With
##
## Ends in an error in state: 571.
##
## record_expr -> Record sep_or_term_list(field_assignment,SEMI) . End [ VBAR Type To Then TIMES Step SLASH SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Mod MINUS LT LE GT GE Function From End Else EQ EOF Contains Const CONS COMMA COLON CAT Block Begin Attributes And ARROW ]
##
## The known suffix of the stack is as follows:
## Record sep_or_term_list(field_assignment,SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 204, spurious reduction of production unary_expr -> core_expr
## In state 153, spurious reduction of production mult_expr -> unary_expr
## In state 180, spurious reduction of production add_expr -> mult_expr
## In state 210, spurious reduction of production cons_expr -> add_expr
## In state 207, spurious reduction of production cat_expr -> cons_expr
## In state 230, spurious reduction of production comp_expr -> cat_expr
## In state 217, spurious reduction of production set_membership -> comp_expr
## In state 155, spurious reduction of production conj_expr -> set_membership
## In state 234, spurious reduction of production disj_expr -> conj_expr
## In state 202, spurious reduction of production expr -> disj_expr
## In state 568, spurious reduction of production field_assignment -> Ident EQ expr
## In state 291, spurious reduction of production nsepseq(field_assignment,SEMI) -> field_assignment
## In state 290, spurious reduction of production sep_or_term_list(field_assignment,SEMI) -> nsepseq(field_assignment,SEMI)
##

Ill-formed record expression.
At this point one of the following is expected:
  a semicolon ';',
    followed with another record field assignment; or
  the closing 'end' keyword.

interactive_expr: Ident With Record Ident EQ With
##
## Ends in an error in state: 175.
##
## field_path_assignment -> path EQ . expr [ SEMI RBRACKET End ]
##
## The known suffix of the stack is as follows:
## path EQ
##
interactive_expr: Record Ident EQ With
##
## Ends in an error in state: 100.
##
## field_assignment -> Ident EQ . expr [ SEMI RBRACKET End ]
##
## The known suffix of the stack is as follows:
## Ident EQ
##

Ill-formed record field assignment.
At this point a value, in the form of an expression, is expected.

interactive_expr: Record Ident With
##
## Ends in an error in state: 99.
##
## field_assignment -> Ident . EQ expr [ SEMI RBRACKET End ]
##
## The known suffix of the stack is as follows:
## Ident
##

Ill-formed record field assignment.
At this point, if the record field name is complete, an equals '=' symbol is expected,
  followed with a value in the form of an expression.

interactive_expr: Record LBRACKET Ident EQ Bytes With
##
## Ends in an error in state: 569.
##
## record_expr -> Record LBRACKET sep_or_term_list(field_assignment,SEMI) . RBRACKET [ VBAR Type To Then TIMES Step SLASH SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Mod MINUS LT LE GT GE Function From End Else EQ EOF Contains Const CONS COMMA COLON CAT Block Begin Attributes And ARROW ]
##
## The known suffix of the stack is as follows:
## Record LBRACKET sep_or_term_list(field_assignment,SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 204, spurious reduction of production unary_expr -> core_expr
## In state 153, spurious reduction of production mult_expr -> unary_expr
## In state 180, spurious reduction of production add_expr -> mult_expr
## In state 210, spurious reduction of production cons_expr -> add_expr
## In state 207, spurious reduction of production cat_expr -> cons_expr
## In state 230, spurious reduction of production comp_expr -> cat_expr
## In state 217, spurious reduction of production set_membership -> comp_expr
## In state 155, spurious reduction of production conj_expr -> set_membership
## In state 234, spurious reduction of production disj_expr -> conj_expr
## In state 202, spurious reduction of production expr -> disj_expr
## In state 568, spurious reduction of production field_assignment -> Ident EQ expr
## In state 291, spurious reduction of production nsepseq(field_assignment,SEMI) -> field_assignment
## In state 290, spurious reduction of production sep_or_term_list(field_assignment,SEMI) -> nsepseq(field_assignment,SEMI)
##

Ill-formed record expression.
At this point one of the following is expected:
  a semicolon ';',
    followed with another record field assignment; or
  a closing bracket ']'.

interactive_expr: Record LBRACKET With
##
## Ends in an error in state: 98.
##
## record_expr -> Record LBRACKET . sep_or_term_list(field_assignment,SEMI) RBRACKET [ VBAR Type To Then TIMES Step SLASH SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Mod MINUS LT LE GT GE Function From End Else EQ EOF Contains Const CONS COMMA COLON CAT Block Begin Attributes And ARROW ]
##
## The known suffix of the stack is as follows:
## Record LBRACKET
##

Ill-formed record expression.
At this point one of the following is expected:
  a record field assignment; or
  a closing brace '}'.

interactive_expr: Set LBRACKET Verbatim With
##
## Ends in an error in state: 575.
##
## injection(Set,expr) -> Set LBRACKET sep_or_term_list(expr,SEMI) . RBRACKET [ VBAR Type To Then TIMES Step SLASH SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Mod MINUS LT LE GT GE Function From End Else EQ EOF Contains Const CONS COMMA COLON CAT Block Begin Attributes And ARROW ]
##
## The known suffix of the stack is as follows:
## Set LBRACKET sep_or_term_list(expr,SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 204, spurious reduction of production unary_expr -> core_expr
## In state 153, spurious reduction of production mult_expr -> unary_expr
## In state 180, spurious reduction of production add_expr -> mult_expr
## In state 210, spurious reduction of production cons_expr -> add_expr
## In state 207, spurious reduction of production cat_expr -> cons_expr
## In state 230, spurious reduction of production comp_expr -> cat_expr
## In state 217, spurious reduction of production set_membership -> comp_expr
## In state 155, spurious reduction of production conj_expr -> set_membership
## In state 234, spurious reduction of production disj_expr -> conj_expr
## In state 202, spurious reduction of production expr -> disj_expr
## In state 276, spurious reduction of production nsepseq(expr,SEMI) -> expr
## In state 275, spurious reduction of production sep_or_term_list(expr,SEMI) -> nsepseq(expr,SEMI)
##

Ill-formed set expression.
At this point one of the following is expected:
  a semicolon ';',
    followed with a item in the form of an expression; or
  a closing bracket ']' if the set is complete.

interactive_expr: Set LBRACKET With
##
## Ends in an error in state: 573.
##
## injection(Set,expr) -> Set LBRACKET . sep_or_term_list(expr,SEMI) RBRACKET [ VBAR Type To Then TIMES Step SLASH SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Mod MINUS LT LE GT GE Function From End Else EQ EOF Contains Const CONS COMMA COLON CAT Block Begin Attributes And ARROW ]
## injection(Set,expr) -> Set LBRACKET . RBRACKET [ VBAR Type To Then TIMES Step SLASH SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Mod MINUS LT LE GT GE Function From End Else EQ EOF Contains Const CONS COMMA COLON CAT Block Begin Attributes And ARROW ]
##
## The known suffix of the stack is as follows:
## Set LBRACKET
##

Ill-formed set expression.
At this point one of the following is expected:
  a semicolon ';' separated list of expressions; or
  a closing bracket ']' if the set is empty.

interactive_expr: Set Verbatim With
##
## Ends in an error in state: 578.
##
## injection(Set,expr) -> Set sep_or_term_list(expr,SEMI) . End [ VBAR Type To Then TIMES Step SLASH SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Mod MINUS LT LE GT GE Function From End Else EQ EOF Contains Const CONS COMMA COLON CAT Block Begin Attributes And ARROW ]
##
## The known suffix of the stack is as follows:
## Set sep_or_term_list(expr,SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 204, spurious reduction of production unary_expr -> core_expr
## In state 153, spurious reduction of production mult_expr -> unary_expr
## In state 180, spurious reduction of production add_expr -> mult_expr
## In state 210, spurious reduction of production cons_expr -> add_expr
## In state 207, spurious reduction of production cat_expr -> cons_expr
## In state 230, spurious reduction of production comp_expr -> cat_expr
## In state 217, spurious reduction of production set_membership -> comp_expr
## In state 155, spurious reduction of production conj_expr -> set_membership
## In state 234, spurious reduction of production disj_expr -> conj_expr
## In state 202, spurious reduction of production expr -> disj_expr
## In state 276, spurious reduction of production nsepseq(expr,SEMI) -> expr
## In state 275, spurious reduction of production sep_or_term_list(expr,SEMI) -> nsepseq(expr,SEMI)
##

Ill-formed set expression.
At this point one of the following is expected:
  a semicolon ';',
    followed with an item in the form of an expression; or
  the closing 'end' keyword if the set is complete.

interactive_expr: Set With
##
## Ends in an error in state: 96.
##
## injection(Set,expr) -> Set . sep_or_term_list(expr,SEMI) End [ VBAR Type To Then TIMES Step SLASH SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Mod MINUS LT LE GT GE Function From End Else EQ EOF Contains Const CONS COMMA COLON CAT Block Begin Attributes And ARROW ]
## injection(Set,expr) -> Set . End [ VBAR Type To Then TIMES Step SLASH SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Mod MINUS LT LE GT GE Function From End Else EQ EOF Contains Const CONS COMMA COLON CAT Block Begin Attributes And ARROW ]
## injection(Set,expr) -> Set . LBRACKET sep_or_term_list(expr,SEMI) RBRACKET [ VBAR Type To Then TIMES Step SLASH SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Mod MINUS LT LE GT GE Function From End Else EQ EOF Contains Const CONS COMMA COLON CAT Block Begin Attributes And ARROW ]
## injection(Set,expr) -> Set . LBRACKET RBRACKET [ VBAR Type To Then TIMES Step SLASH SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Mod MINUS LT LE GT GE Function From End Else EQ EOF Contains Const CONS COMMA COLON CAT Block Begin Attributes And ARROW ]
##
## The known suffix of the stack is as follows:
## Set
##

Ill-formed set expression.
At this point one of the following is expected:
  a semicolon ';' separated list of items,
    which are closed with the 'end' keyword; or
  the 'end' keyword if the set is empty; or
  an opening bracket '[',
    followed with one of the following:
      a semicolon ';' separated list of items,
        which are closed by a bracket; or
    a closing bracket if the set is empty.

interactive_expr: Verbatim And With
##
## Ends in an error in state: 232.
##
## conj_expr -> conj_expr And . set_membership [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Or Of Function From End Else EOF Const COMMA COLON Block Begin Attributes And ARROW ]
##
## The known suffix of the stack is as follows:
## conj_expr And
##

Ill-formed boolean operation.
At this point an expression is expected.

interactive_expr: Verbatim CAT With
##
## Ends in an error in state: 208.
##
## cat_expr -> cons_expr CAT . cat_expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Or Of NE LT LE GT GE Function From End Else EQ EOF Const COMMA COLON Block Begin Attributes And ARROW ]
##
## The known suffix of the stack is as follows:
## cons_expr CAT
##

Ill-formed concatenation operation.
At this point an expression is expected.

interactive_expr: Verbatim CONS With
##
## Ends in an error in state: 215.
##
## cons_expr -> add_expr CONS . cons_expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Or Of NE LT LE GT GE Function From End Else EQ EOF Const COMMA COLON CAT Block Begin Attributes And ARROW ]
##
## The known suffix of the stack is as follows:
## add_expr CONS
##

Ill-formed cons operation.
At this point an expression is expected.

interactive_expr: Verbatim Contains With
##
## Ends in an error in state: 205.
##
## set_membership -> core_expr Contains . set_membership [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Or Of Function From End Else EOF Const COMMA COLON Block Begin Attributes And ARROW ]
##
## The known suffix of the stack is as follows:
## core_expr Contains
##

Ill-formed unary expression.
At this point an expression is expected.

interactive_expr: Verbatim EQ With
##
## Ends in an error in state: 228.
##
## comp_expr -> comp_expr EQ . cat_expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Or Of NE LT LE GT GE Function From End Else EQ EOF Const COMMA COLON Block Begin Attributes And ARROW ]
##
## The known suffix of the stack is as follows:
## comp_expr EQ
##

Ill-formed contains operation.
At this point a value, in the form of an expression, is expected.

interactive_expr: Verbatim GE With
##
## Ends in an error in state: 226.
##
## comp_expr -> comp_expr GE . cat_expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Or Of NE LT LE GT GE Function From End Else EQ EOF Const COMMA COLON Block Begin Attributes And ARROW ]
##
## The known suffix of the stack is as follows:
## comp_expr GE
##

Ill-formed boolean operation.
At this point an expression is expected.

interactive_expr: Verbatim GT With
##
## Ends in an error in state: 224.
##
## comp_expr -> comp_expr GT . cat_expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Or Of NE LT LE GT GE Function From End Else EQ EOF Const COMMA COLON Block Begin Attributes And ARROW ]
##
## The known suffix of the stack is as follows:
## comp_expr GT
##

Ill-formed boolean operation.
At this point an expression is expected.

interactive_expr: Verbatim LE With
##
## Ends in an error in state: 222.
##
## comp_expr -> comp_expr LE . cat_expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Or Of NE LT LE GT GE Function From End Else EQ EOF Const COMMA COLON Block Begin Attributes And ARROW ]
##
## The known suffix of the stack is as follows:
## comp_expr LE
##

Ill-formed boolean operation.
At this point an expression is expected.

interactive_expr: Verbatim LT With
##
## Ends in an error in state: 220.
##
## comp_expr -> comp_expr LT . cat_expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Or Of NE LT LE GT GE Function From End Else EQ EOF Const COMMA COLON Block Begin Attributes And ARROW ]
##
## The known suffix of the stack is as follows:
## comp_expr LT
##

Ill-formed boolean operation.
At this point an expression is expected.

interactive_expr: Verbatim MINUS With
##
## Ends in an error in state: 213.
##
## add_expr -> add_expr MINUS . mult_expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE MINUS LT LE GT GE Function From End Else EQ EOF Const CONS COMMA COLON CAT Block Begin Attributes And ARROW ]
##
## The known suffix of the stack is as follows:
## add_expr MINUS
##

Ill-formed calculation.
At this point an expression is expected.

interactive_expr: Verbatim Mod With
##
## Ends in an error in state: 198.
##
## mult_expr -> mult_expr Mod . unary_expr [ VBAR Type To Then TIMES Step SLASH SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Mod MINUS LT LE GT GE Function From End Else EQ EOF Const CONS COMMA COLON CAT Block Begin Attributes And ARROW ]
##
## The known suffix of the stack is as follows:
## mult_expr Mod
##

Ill-formed calculation.
At this point an expression is expected.

interactive_expr: Verbatim NE With
##
## Ends in an error in state: 218.
##
## comp_expr -> comp_expr NE . cat_expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Or Of NE LT LE GT GE Function From End Else EQ EOF Const COMMA COLON Block Begin Attributes And ARROW ]
##
## The known suffix of the stack is as follows:
## comp_expr NE
##

Ill-formed boolean operation.
At this point an expression is expected.

interactive_expr: Verbatim Or With
##
## Ends in an error in state: 203.
##
## disj_expr -> disj_expr Or . conj_expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Or Of Function From End Else EOF Const COMMA COLON Block Begin Attributes ARROW ]
##
## The known suffix of the stack is as follows:
## disj_expr Or
##

Ill-formed boolean operation.
At this point an expression is expected.

interactive_expr: Verbatim PLUS With
##
## Ends in an error in state: 211.
##
## add_expr -> add_expr PLUS . mult_expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE MINUS LT LE GT GE Function From End Else EQ EOF Const CONS COMMA COLON CAT Block Begin Attributes And ARROW ]
##
## The known suffix of the stack is as follows:
## add_expr PLUS
##

Ill-formed calculation.
At this point an expression is expected.

interactive_expr: Verbatim SLASH With
##
## Ends in an error in state: 196.
##
## mult_expr -> mult_expr SLASH . unary_expr [ VBAR Type To Then TIMES Step SLASH SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Mod MINUS LT LE GT GE Function From End Else EQ EOF Const CONS COMMA COLON CAT Block Begin Attributes And ARROW ]
##
## The known suffix of the stack is as follows:
## mult_expr SLASH
##


Ill-formed calculation.
At this point an expression is expected.

interactive_expr: Verbatim TIMES With
##
## Ends in an error in state: 181.
##
## mult_expr -> mult_expr TIMES . unary_expr [ VBAR Type To Then TIMES Step SLASH SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Mod MINUS LT LE GT GE Function From End Else EQ EOF Const CONS COMMA COLON CAT Block Begin Attributes And ARROW ]
##
## The known suffix of the stack is as follows:
## mult_expr TIMES
##


Ill-formed calculation.
At this point an expression is expected.

interactive_expr: Verbatim With
##
## Ends in an error in state: 600.
##
## interactive_expr -> expr . EOF [ # ]
##
## The known suffix of the stack is as follows:
## expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 204, spurious reduction of production unary_expr -> core_expr
## In state 153, spurious reduction of production mult_expr -> unary_expr
## In state 180, spurious reduction of production add_expr -> mult_expr
## In state 210, spurious reduction of production cons_expr -> add_expr
## In state 207, spurious reduction of production cat_expr -> cons_expr
## In state 230, spurious reduction of production comp_expr -> cat_expr
## In state 217, spurious reduction of production set_membership -> comp_expr
## In state 155, spurious reduction of production conj_expr -> set_membership
## In state 234, spurious reduction of production disj_expr -> conj_expr
## In state 202, spurious reduction of production expr -> disj_expr
##

Ill-formed expression.

interactive_expr: With
##
## Ends in an error in state: 598.
##
## interactive_expr' -> . interactive_expr [ # ]
##
## The known suffix of the stack is as follows:
##
##

Ill-formed expression.

contract: Attributes LBRACKET String With
##
## Ends in an error in state: 472.
##
## ne_injection(Attributes,String) -> Attributes LBRACKET sep_or_term_list(String,SEMI) . RBRACKET [ Type SEMI Recursive RBRACE Function End EOF Const Attributes ]
##
## The known suffix of the stack is as follows:
## Attributes LBRACKET sep_or_term_list(String,SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 464, spurious reduction of production nsepseq(String,SEMI) -> String
## In state 475, spurious reduction of production sep_or_term_list(String,SEMI) -> nsepseq(String,SEMI)
##

Ill-formed attributes.
At this point one of the following is expected:
  a semicolon ';',
    followed with an attribute in the form of a string,
      which are closed with a closing bracket ']'; or
  a closing bracket ']'.

contract: Attributes LBRACKET With
##
## Ends in an error in state: 471.
##
## ne_injection(Attributes,String) -> Attributes LBRACKET . sep_or_term_list(String,SEMI) RBRACKET [ Type SEMI Recursive RBRACE Function End EOF Const Attributes ]
##
## The known suffix of the stack is as follows:
## Attributes LBRACKET
##

Ill-formed attributes.
At this point a semicolon separated ';' list of attributes is expected,
  followed with a closing bracket ']'.

contract: Attributes String End Attributes String End With
##
## Ends in an error in state: 593.
##
## seq(declaration) -> declaration . seq(declaration) [ EOF ]
##
## The known suffix of the stack is as follows:
## declaration
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 586, spurious reduction of production option(SEMI) ->
## In state 587, spurious reduction of production attr_decl -> open_attr_decl option(SEMI)
## In state 596, spurious reduction of production declaration -> attr_decl
##

Ill-formed declaration.
At this point a declaration is expected.

contract: Attributes String End With
##
## Ends in an error in state: 591.
##
## nseq(declaration) -> declaration . seq(declaration) [ EOF ]
##
## The known suffix of the stack is as follows:
## declaration
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 586, spurious reduction of production option(SEMI) ->
## In state 587, spurious reduction of production attr_decl -> open_attr_decl option(SEMI)
## In state 596, spurious reduction of production declaration -> attr_decl
##

Ill-formed declaration.
At this point a declaration is expected.

contract: Attributes String With
##
## Ends in an error in state: 476.
##
## ne_injection(Attributes,String) -> Attributes sep_or_term_list(String,SEMI) . End [ Type SEMI Recursive RBRACE Function End EOF Const Attributes ]
##
## The known suffix of the stack is as follows:
## Attributes sep_or_term_list(String,SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 464, spurious reduction of production nsepseq(String,SEMI) -> String
## In state 475, spurious reduction of production sep_or_term_list(String,SEMI) -> nsepseq(String,SEMI)
##

Ill-formed attributes.
At this point one of the following is expected:
  a semicolon ';',
    followed with an attribute in the form of a string; or
  the closing 'end' keyword.

contract: Attributes With
##
## Ends in an error in state: 463.
##
## ne_injection(Attributes,String) -> Attributes . sep_or_term_list(String,SEMI) End [ Type SEMI Recursive RBRACE Function End EOF Const Attributes ]
## ne_injection(Attributes,String) -> Attributes . LBRACKET sep_or_term_list(String,SEMI) RBRACKET [ Type SEMI Recursive RBRACE Function End EOF Const Attributes ]
##
## The known suffix of the stack is as follows:
## Attributes
##

Ill-formed attributes.
At this point one of the following is expected:
  a semicolon ';' separated list of strings,
    followed with the 'end' keyword.
  an opening bracket '[',
    followed with a semicolon ';' separated list of strings,
      which are closed with an closing bracket ']'.

contract: Const Ident COLON Ident With
##
## Ends in an error in state: 359.
##
## unqualified_decl(EQ) -> Ident option(type_annot) . EQ expr [ Type SEMI Recursive RBRACE Function End EOF Const Attributes ]
##
## The known suffix of the stack is as follows:
## Ident option(type_annot)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 16, spurious reduction of production core_type -> Ident
## In state 30, spurious reduction of production cartesian -> core_type
## In state 36, spurious reduction of production fun_type -> cartesian
## In state 44, spurious reduction of production type_expr -> fun_type
## In state 88, spurious reduction of production type_annot -> COLON type_expr
## In state 89, spurious reduction of production option(type_annot) -> type_annot
##

Ill-formed constant declaration.
At this point an equals '=' symbol is expected,
  followed with a value in the form of an expression.

contract: Const Ident EQ With
##
## Ends in an error in state: 360.
##
## unqualified_decl(EQ) -> Ident option(type_annot) EQ . expr [ Type SEMI Recursive RBRACE Function End EOF Const Attributes ]
##
## The known suffix of the stack is as follows:
## Ident option(type_annot) EQ
##

Ill-formed constant declaration.
At this point the value, in the form of an expression, is expected.

contract: Const Ident With
##
## Ends in an error in state: 358.
##
## unqualified_decl(EQ) -> Ident . option(type_annot) EQ expr [ Type SEMI Recursive RBRACE Function End EOF Const Attributes ]
##
## The known suffix of the stack is as follows:
## Ident
##

Ill-formed constant declaration.
At this point one of the following is expected:
  a type annotation; or
  an equals '=' symbol,
    followed with a value in the form of an expression.

contract: Const With
##
## Ends in an error in state: 357.
##
## open_const_decl -> Const . unqualified_decl(EQ) [ Type SEMI Recursive RBRACE Function End EOF Const Attributes ]
##
## The known suffix of the stack is as follows:
## Const
##

Ill-formed constant declaration.
At this point the name of the constant is expected,
  followed with equals '=' symbol and a value in the form of an expression.

contract: Function Ident LPAR Const Ident RPAR COLON Ident With
##
## Ends in an error in state: 330.
##
## open_fun_decl -> Function Ident parameters option(type_annot) . Is expr [ Type SEMI Recursive RBRACE Function End EOF Const Attributes ]
##
## The known suffix of the stack is as follows:
## Function Ident parameters option(type_annot)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 16, spurious reduction of production core_type -> Ident
## In state 30, spurious reduction of production cartesian -> core_type
## In state 36, spurious reduction of production fun_type -> cartesian
## In state 44, spurious reduction of production type_expr -> fun_type
## In state 88, spurious reduction of production type_annot -> COLON type_expr
## In state 89, spurious reduction of production option(type_annot) -> type_annot
##

Ill-formed function declaration.
At this point the 'is' keyword is expected,
  followed with an expression.

contract: Function Ident LPAR Const Ident RPAR Is With
##
## Ends in an error in state: 331.
##
## open_fun_decl -> Function Ident parameters option(type_annot) Is . expr [ Type SEMI Recursive RBRACE Function End EOF Const Attributes ]
##
## The known suffix of the stack is as follows:
## Function Ident parameters option(type_annot) Is
##

Ill-formed function declaration.
At this point the function body, in the form of an expression, is expected.

contract: Function Ident LPAR Const Ident RPAR With
##
## Ends in an error in state: 329.
##
## open_fun_decl -> Function Ident parameters . option(type_annot) Is expr [ Type SEMI Recursive RBRACE Function End EOF Const Attributes ]
##
## The known suffix of the stack is as follows:
## Function Ident parameters
##

Ill-formed function declaration.
At this point one of the following is expected:
  a type annotation; or
  the 'is' keyword,
    followed with an expression.

contract: Function Ident With
##
## Ends in an error in state: 328.
##
## open_fun_decl -> Function Ident . parameters option(type_annot) Is expr [ Type SEMI Recursive RBRACE Function End EOF Const Attributes ]
##
## The known suffix of the stack is as follows:
## Function Ident
##

Ill-formed function declaration.
At this point function parameters are expected.

contract: Function With
##
## Ends in an error in state: 327.
##
## open_fun_decl -> Function . Ident parameters option(type_annot) Is expr [ Type SEMI Recursive RBRACE Function End EOF Const Attributes ]
##
## The known suffix of the stack is as follows:
## Function
##

Ill-formed function declaration.
At this point the name of the function is expected.

contract: Recursive Function Ident LPAR Const Ident RPAR COLON String With
##
## Ends in an error in state: 90.
##
## open_fun_decl -> Recursive Function Ident parameters option(type_annot) . Is expr [ Type SEMI Recursive RBRACE Function End EOF Const Attributes ]
##
## The known suffix of the stack is as follows:
## Recursive Function Ident parameters option(type_annot)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 30, spurious reduction of production cartesian -> core_type
## In state 36, spurious reduction of production fun_type -> cartesian
## In state 44, spurious reduction of production type_expr -> fun_type
## In state 88, spurious reduction of production type_annot -> COLON type_expr
## In state 89, spurious reduction of production option(type_annot) -> type_annot
##

Ill-formed function declaration.
At this point the 'is' keyword is expected.

contract: Recursive Function Ident LPAR Const Ident RPAR Is With
##
## Ends in an error in state: 91.
##
## open_fun_decl -> Recursive Function Ident parameters option(type_annot) Is . expr [ Type SEMI Recursive RBRACE Function End EOF Const Attributes ]
##
## The known suffix of the stack is as follows:
## Recursive Function Ident parameters option(type_annot) Is
##

Ill-formed function declaration.
At this point the function body, in the form of an expression, is expected.

contract: Recursive Function Ident LPAR Const Ident RPAR With
##
## Ends in an error in state: 86.
##
## open_fun_decl -> Recursive Function Ident parameters . option(type_annot) Is expr [ Type SEMI Recursive RBRACE Function End EOF Const Attributes ]
##
## The known suffix of the stack is as follows:
## Recursive Function Ident parameters
##

Ill-formed function declaration.
At this point one of the following is expected:
  a type annotation; or
  the 'is' keyword,
    followed with an expression.

contract: Recursive Function Ident With
##
## Ends in an error in state: 70.
##
## open_fun_decl -> Recursive Function Ident . parameters option(type_annot) Is expr [ Type SEMI Recursive RBRACE Function End EOF Const Attributes ]
##
## The known suffix of the stack is as follows:
## Recursive Function Ident
##

Ill-formed function declaration.
At this point function parameters are expected.

contract: Recursive Function With
##
## Ends in an error in state: 69.
##
## open_fun_decl -> Recursive Function . Ident parameters option(type_annot) Is expr [ Type SEMI Recursive RBRACE Function End EOF Const Attributes ]
##
## The known suffix of the stack is as follows:
## Recursive Function
##

Ill-formed function declaration.
At this point the name of the function is expected.

contract: Recursive With
##
## Ends in an error in state: 68.
##
## open_fun_decl -> Recursive . Function Ident parameters option(type_annot) Is expr [ Type SEMI Recursive RBRACE Function End EOF Const Attributes ]
##
## The known suffix of the stack is as follows:
## Recursive
##

Ill-formed function declaration.
At this point the 'function' keyword is expected.

contract: Type Ident Is BigMap With
##
## Ends in an error in state: 19.
##
## core_type -> BigMap . type_tuple [ VBAR Type TIMES SEMI Recursive RPAR RBRACKET Is Function End EQ EOF Const COMMA Attributes ASS ARROW ]
##
## The known suffix of the stack is as follows:
## BigMap
##

Ill-formed big_map type.
At this point a tuple type is expected.

contract: Type Ident Is Constr Of With
##
## Ends in an error in state: 28.
##
## variant -> Constr Of . fun_type [ VBAR Type SEMI Recursive RPAR RBRACKET Is Function End EQ EOF Const COMMA Attributes ASS ]
##
## The known suffix of the stack is as follows:
## Constr Of
##

Ill-formed variant constructor.
At this point a type is expected.

contract: Type Ident Is Constr VBAR With
##
## Ends in an error in state: 40.
##
## nsepseq(variant,VBAR) -> variant VBAR . nsepseq(variant,VBAR) [ Type SEMI Recursive RPAR RBRACKET Is Function End EQ EOF Const COMMA Attributes ASS ]
##
## The known suffix of the stack is as follows:
## variant VBAR
##

Ill-formed variants type.
At this point a constructor is expected.

contract: Type Ident Is LPAR String With
##
## Ends in an error in state: 62.
##
## par(type_expr) -> LPAR type_expr . RPAR [ VBAR Type TIMES SEMI Recursive RPAR RBRACKET Is Function End EQ EOF Const COMMA Attributes ASS ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR type_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 30, spurious reduction of production cartesian -> core_type
## In state 36, spurious reduction of production fun_type -> cartesian
## In state 44, spurious reduction of production type_expr -> fun_type
##

Ill-formed type.
At this point, if the type expression is complete, a closing parenthesis ')' is expected.

contract: Type Ident Is List With
##
## Ends in an error in state: 14.
##
## core_type -> List . par(type_expr) [ VBAR Type TIMES SEMI Recursive RPAR RBRACKET Is Function End EQ EOF Const COMMA Attributes ASS ARROW ]
##
## The known suffix of the stack is as follows:
## List
##

Ill-formed list type.
At this point a type parameter is expected.

contract: Type Ident Is Map LPAR String With
##
## Ends in an error in state: 45.
##
## par(nsepseq(type_expr,COMMA)) -> LPAR nsepseq(type_expr,COMMA) . RPAR [ VBAR Type TIMES SEMI Recursive RPAR RBRACKET Is Function End EQ EOF Const COMMA Attributes ASS ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR nsepseq(type_expr,COMMA)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 30, spurious reduction of production cartesian -> core_type
## In state 36, spurious reduction of production fun_type -> cartesian
## In state 44, spurious reduction of production type_expr -> fun_type
## In state 21, spurious reduction of production nsepseq(type_expr,COMMA) -> type_expr
##

Ill-formed map type.
At this point one of the following is expected:
  a comma ',',
    followed with a type expression; or
  a closing parenthesis ')' if the map type is complete.

contract: Type Ident Is Map With
##
## Ends in an error in state: 12.
##
## core_type -> Map . type_tuple [ VBAR Type TIMES SEMI Recursive RPAR RBRACKET Is Function End EQ EOF Const COMMA Attributes ASS ARROW ]
##
## The known suffix of the stack is as follows:
## Map
##

Ill-formed map type.
At this point a tuple type is expected.

contract: Type Ident Is Record Ident COLON Ident With
##
## Ends in an error in state: 60.
##
## record_type -> Record sep_or_term_list(field_decl,SEMI) . End [ Type SEMI Recursive RPAR RBRACKET Is Function End EQ EOF Const COMMA Attributes ASS ]
##
## The known suffix of the stack is as follows:
## Record sep_or_term_list(field_decl,SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 16, spurious reduction of production core_type -> Ident
## In state 30, spurious reduction of production cartesian -> core_type
## In state 36, spurious reduction of production fun_type -> cartesian
## In state 44, spurious reduction of production type_expr -> fun_type
## In state 48, spurious reduction of production field_decl -> Ident COLON type_expr
## In state 53, spurious reduction of production nsepseq(field_decl,SEMI) -> field_decl
## In state 52, spurious reduction of production sep_or_term_list(field_decl,SEMI) -> nsepseq(field_decl,SEMI)
##

Ill-formed record type declaration.
At this point one of the following is expected:
  a semicolon ';',
    followed with another record field; or
  the closing 'end' keyword.

contract: Type Ident Is Record Ident With
##
## Ends in an error in state: 10.
##
## field_decl -> Ident . COLON type_expr [ SEMI RBRACKET End ]
##
## The known suffix of the stack is as follows:
## Ident
##

Ill-formed record type.
At this point, if the field name is complete, a colon ':' is expected,
  followed with a type expression.

contract: Type Ident Is Record LBRACKET Ident COLON Ident With
##
## Ends in an error in state: 49.
##
## record_type -> Record LBRACKET sep_or_term_list(field_decl,SEMI) . RBRACKET [ Type SEMI Recursive RPAR RBRACKET Is Function End EQ EOF Const COMMA Attributes ASS ]
##
## The known suffix of the stack is as follows:
## Record LBRACKET sep_or_term_list(field_decl,SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 16, spurious reduction of production core_type -> Ident
## In state 30, spurious reduction of production cartesian -> core_type
## In state 36, spurious reduction of production fun_type -> cartesian
## In state 44, spurious reduction of production type_expr -> fun_type
## In state 48, spurious reduction of production field_decl -> Ident COLON type_expr
## In state 53, spurious reduction of production nsepseq(field_decl,SEMI) -> field_decl
## In state 52, spurious reduction of production sep_or_term_list(field_decl,SEMI) -> nsepseq(field_decl,SEMI)
##

Ill-formed record type.
At this point one of the following is expected:
  a semicolon ';',
    followed with a record field declaration; or
  a closing bracket ']' if the record type is complete.

contract: Type Ident Is Record LBRACKET With
##
## Ends in an error in state: 9.
##
## record_type -> Record LBRACKET . sep_or_term_list(field_decl,SEMI) RBRACKET [ Type SEMI Recursive RPAR RBRACKET Is Function End EQ EOF Const COMMA Attributes ASS ]
##
## The known suffix of the stack is as follows:
## Record LBRACKET
##

Ill-formed record type.
At this point a semicolon ';' separated list of field declarations is expected,
  followed with a closing bracket ']'.

contract: Type Ident Is Record With
##
## Ends in an error in state: 8.
##
## record_type -> Record . sep_or_term_list(field_decl,SEMI) End [ Type SEMI Recursive RPAR RBRACKET Is Function End EQ EOF Const COMMA Attributes ASS ]
## record_type -> Record . LBRACKET sep_or_term_list(field_decl,SEMI) RBRACKET [ Type SEMI Recursive RPAR RBRACKET Is Function End EQ EOF Const COMMA Attributes ASS ]
##
## The known suffix of the stack is as follows:
## Record
##

Ill-formed record type.
At this point one of the following is expected:
  a semicolon ';' separated list of record field declarations,
    which are closed by the 'end' keyword; or
  an opening bracket '[',
    followed with a semicolon ';' separated list of record field declarations,
      which are closed by a bracket ']'.

contract: Type Ident Is Set With
##
## Ends in an error in state: 6.
##
## core_type -> Set . par(type_expr) [ VBAR Type TIMES SEMI Recursive RPAR RBRACKET Is Function End EQ EOF Const COMMA Attributes ASS ARROW ]
##
## The known suffix of the stack is as follows:
## Set
##

Ill-formed set type.
At this point a type parameter is expected.

contract: Type Ident Is String ARROW With
##
## Ends in an error in state: 37.
##
## fun_type -> cartesian ARROW . fun_type [ VBAR Type SEMI Recursive RPAR RBRACKET Is Function End EQ EOF Const COMMA Attributes ASS ]
##
## The known suffix of the stack is as follows:
## cartesian ARROW
##

Ill-formed function type.
At this point a type is expected.

contract: Type Ident Is String TIMES String TIMES With
##
## Ends in an error in state: 34.
##
## nsepseq(core_type,TIMES) -> core_type TIMES . nsepseq(core_type,TIMES) [ VBAR Type SEMI Recursive RPAR RBRACKET Is Function End EQ EOF Const COMMA Attributes ASS ARROW ]
##
## The known suffix of the stack is as follows:
## core_type TIMES
##

Ill-formed tuple type.
At this point a type is expected.

contract: Type Ident Is String TIMES With
##
## Ends in an error in state: 31.
##
## cartesian -> core_type TIMES . nsepseq(core_type,TIMES) [ VBAR Type SEMI Recursive RPAR RBRACKET Is Function End EQ EOF Const COMMA Attributes ASS ARROW ]
##
## The known suffix of the stack is as follows:
## core_type TIMES
##

Ill-formed tuple type.
At this point a type is expected.

contract: Type Ident Is With
##
## Ends in an error in state: 26.
##
## sum_type -> option(VBAR) . nsepseq(variant,VBAR) [ Type SEMI Recursive RPAR RBRACKET Is Function End EQ EOF Const COMMA Attributes ASS ]
##
## The known suffix of the stack is as follows:
## option(VBAR)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 3, spurious reduction of production option(VBAR) ->
##

Ill-formed type declaration.
At this point a type expression is expected.

contract: Type Ident With
##
## Ends in an error in state: 2.
##
## type_decl -> Type Ident . Is type_expr option(SEMI) [ Type Recursive Function EOF Const Attributes ]
##
## The known suffix of the stack is as follows:
## Type Ident
##

Ill-formed type declaration.
At this point, if the name of the type is complete, the "is" keyword is expected,
  followed with a type expression.

contract: Type With
##
## Ends in an error in state: 1.
##
## type_decl -> Type . Ident Is type_expr option(SEMI) [ Type Recursive Function EOF Const Attributes ]
##
## The known suffix of the stack is as follows:
## Type
##

Ill-formed type declaration.
At this point the name of the type is expected.

contract: With
##
## Ends in an error in state: 0.
##
## contract' -> . contract [ # ]
##
## The known suffix of the stack is as follows:
##
##

Ill-formed contract.
