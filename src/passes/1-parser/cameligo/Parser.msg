interactive_expr: Begin True RBRACKET
##
## Ends in an error in state: 218.
##
## sequence -> Begin option(sep_or_term_list(expr,SEMI)) . End [ With VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Mod MINUS Let LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Constr CONS COMMA COLON CAT Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## Begin option(sep_or_term_list(expr,SEMI))
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 225, spurious reduction of production call_expr_level -> core_expr 
## In state 232, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 214, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 222, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 262, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 252, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 284, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 291, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 298, spurious reduction of production disj_expr_level -> conj_expr_level 
## In state 250, spurious reduction of production base_expr(expr) -> disj_expr_level 
## In state 304, spurious reduction of production base_cond__open(expr) -> base_expr(expr) 
## In state 305, spurious reduction of production expr -> base_cond__open(expr) 
## In state 243, spurious reduction of production nsepseq(expr,SEMI) -> expr 
## In state 221, spurious reduction of production sep_or_term_list(expr,SEMI) -> nsepseq(expr,SEMI) 
## In state 217, spurious reduction of production option(sep_or_term_list(expr,SEMI)) -> sep_or_term_list(expr,SEMI) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Begin With
##
## Ends in an error in state: 201.
##
## sequence -> Begin . option(sep_or_term_list(expr,SEMI)) End [ With VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Mod MINUS Let LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Constr CONS COMMA COLON CAT Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## Begin
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: C_None WILD
##
## Ends in an error in state: 222.
##
## add_expr_level -> mult_expr_level . [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE PLUS Or NE MINUS Let LT LE In GT GE End Else EQ EOF CONS COMMA COLON CAT BOOL_OR BOOL_AND Attr ]
## bin_op(mult_expr_level,Mod,unary_expr_level) -> mult_expr_level . Mod unary_expr_level [ With VBAR Type Then TIMES SLASH SEMI RPAR RBRACKET RBRACE PLUS Or NE Mod MINUS Let LT LE In GT GE End Else EQ EOF CONS COMMA COLON CAT BOOL_OR BOOL_AND Attr ]
## bin_op(mult_expr_level,SLASH,unary_expr_level) -> mult_expr_level . SLASH unary_expr_level [ With VBAR Type Then TIMES SLASH SEMI RPAR RBRACKET RBRACE PLUS Or NE Mod MINUS Let LT LE In GT GE End Else EQ EOF CONS COMMA COLON CAT BOOL_OR BOOL_AND Attr ]
## bin_op(mult_expr_level,TIMES,unary_expr_level) -> mult_expr_level . TIMES unary_expr_level [ With VBAR Type Then TIMES SLASH SEMI RPAR RBRACKET RBRACE PLUS Or NE Mod MINUS Let LT LE In GT GE End Else EQ EOF CONS COMMA COLON CAT BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## mult_expr_level
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: C_Some With
##
## Ends in an error in state: 202.
##
## constr_expr -> C_Some . core_expr [ With VBAR Type Then TIMES SLASH SEMI RPAR RBRACKET RBRACE PLUS Or NE Mod MINUS Let LT LE In GT GE End Else EQ EOF CONS COMMA COLON CAT BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## C_Some
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Constr DOT Ident DOT With
##
## Ends in an error in state: 196.
##
## projection -> Constr DOT Ident DOT . nsepseq(selection,DOT) [ With VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Mod MINUS Let LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Constr CONS COMMA COLON CAT Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## Constr DOT Ident DOT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Constr DOT Ident WILD
##
## Ends in an error in state: 195.
##
## module_fun -> Ident . [ With VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Mod MINUS Let LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Constr CONS COMMA COLON CAT Bytes Begin BOOL_OR BOOL_AND Attr ]
## projection -> Constr DOT Ident . DOT nsepseq(selection,DOT) [ With VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Mod MINUS Let LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Constr CONS COMMA COLON CAT Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## Constr DOT Ident
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Constr DOT With
##
## Ends in an error in state: 193.
##
## module_field -> Constr DOT . module_fun [ With VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Mod MINUS Let LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Constr CONS COMMA COLON CAT Bytes Begin BOOL_OR BOOL_AND Attr ]
## projection -> Constr DOT . Ident DOT nsepseq(selection,DOT) [ With VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Mod MINUS Let LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Constr CONS COMMA COLON CAT Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## Constr DOT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Constr WILD
##
## Ends in an error in state: 192.
##
## constr_expr -> Constr . core_expr [ With VBAR Type Then TIMES SLASH SEMI RPAR RBRACKET RBRACE PLUS Or NE Mod MINUS Let LT LE In GT GE End Else EQ EOF CONS COMMA COLON CAT BOOL_OR BOOL_AND Attr ]
## constr_expr -> Constr . [ With VBAR Type Then TIMES SLASH SEMI RPAR RBRACKET RBRACE PLUS Or NE Mod MINUS Let LT LE In GT GE End Else EQ EOF CONS COMMA COLON CAT BOOL_OR BOOL_AND Attr ]
## module_field -> Constr . DOT module_fun [ With VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Mod MINUS Let LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Constr CONS COMMA COLON CAT Bytes Begin BOOL_OR BOOL_AND Attr ]
## projection -> Constr . DOT Ident DOT nsepseq(selection,DOT) [ With VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Mod MINUS Let LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Constr CONS COMMA COLON CAT Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## Constr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Fun WILD ARROW With
##
## Ends in an error in state: 190.
##
## fun_expr(expr) -> Fun nseq(irrefutable) ARROW . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun nseq(irrefutable) ARROW
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Fun WILD RPAR
##
## Ends in an error in state: 308.
##
## nseq(irrefutable) -> irrefutable . seq(irrefutable) [ ARROW ]
##
## The known suffix of the stack is as follows:
## irrefutable
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 134, spurious reduction of production irrefutable -> sub_irrefutable 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Fun WILD WILD RPAR
##
## Ends in an error in state: 310.
##
## seq(irrefutable) -> irrefutable . seq(irrefutable) [ ARROW ]
##
## The known suffix of the stack is as follows:
## irrefutable
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 134, spurious reduction of production irrefutable -> sub_irrefutable 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Fun With
##
## Ends in an error in state: 188.
##
## fun_expr(expr) -> Fun . nseq(irrefutable) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Ident DOT Int DOT With
##
## Ends in an error in state: 185.
##
## nsepseq(selection,DOT) -> selection DOT . nsepseq(selection,DOT) [ With VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Mod MINUS Let LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Constr CONS COMMA COLON CAT Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## selection DOT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Ident DOT Int WILD
##
## Ends in an error in state: 184.
##
## nsepseq(selection,DOT) -> selection . [ With VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Mod MINUS Let LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Constr CONS COMMA COLON CAT Bytes Begin BOOL_OR BOOL_AND Attr ]
## nsepseq(selection,DOT) -> selection . DOT nsepseq(selection,DOT) [ With VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Mod MINUS Let LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Constr CONS COMMA COLON CAT Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## selection
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Ident DOT With
##
## Ends in an error in state: 181.
##
## projection -> Ident DOT . nsepseq(selection,DOT) [ With VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Mod MINUS Let LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Constr CONS COMMA COLON CAT Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## Ident DOT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Ident WILD
##
## Ends in an error in state: 180.
##
## core_expr -> Ident . [ With VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Mod MINUS Let LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Constr CONS COMMA COLON CAT Bytes Begin BOOL_OR BOOL_AND Attr ]
## projection -> Ident . DOT nsepseq(selection,DOT) [ With VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Mod MINUS Let LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Constr CONS COMMA COLON CAT Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## Ident
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: If True Then Fun WILD ARROW With
##
## Ends in an error in state: 426.
##
## fun_expr(closed_if) -> Fun nseq(irrefutable) ARROW . closed_if [ Else ]
## fun_expr(expr) -> Fun nseq(irrefutable) ARROW . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun nseq(irrefutable) ARROW
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: If True Then Fun With
##
## Ends in an error in state: 424.
##
## fun_expr(closed_if) -> Fun . nseq(irrefutable) ARROW closed_if [ Else ]
## fun_expr(expr) -> Fun . nseq(irrefutable) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: If True Then If True Then True Else With
##
## Ends in an error in state: 431.
##
## if_then_else(closed_if) -> If expr Then closed_if Else . closed_if [ Else ]
## if_then_else(expr) -> If expr Then closed_if Else . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_if Else
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: If True Then If True Then With
##
## Ends in an error in state: 423.
##
## if_then(expr) -> If expr Then . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
## if_then_else(closed_if) -> If expr Then . closed_if Else closed_if [ Else ]
## if_then_else(expr) -> If expr Then . closed_if Else expr [ With Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## If expr Then
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: If True Then If True With
##
## Ends in an error in state: 422.
##
## if_then(expr) -> If expr . Then expr [ With Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
## if_then_else(closed_if) -> If expr . Then closed_if Else closed_if [ Else ]
## if_then_else(expr) -> If expr . Then closed_if Else expr [ With Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## If expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 225, spurious reduction of production call_expr_level -> core_expr 
## In state 232, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 214, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 222, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 262, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 252, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 284, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 291, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 298, spurious reduction of production disj_expr_level -> conj_expr_level 
## In state 250, spurious reduction of production base_expr(expr) -> disj_expr_level 
## In state 304, spurious reduction of production base_cond__open(expr) -> base_expr(expr) 
## In state 305, spurious reduction of production expr -> base_cond__open(expr) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: If True Then If With
##
## Ends in an error in state: 421.
##
## if_then(expr) -> If . expr Then expr [ With Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
## if_then_else(closed_if) -> If . expr Then closed_if Else closed_if [ Else ]
## if_then_else(expr) -> If . expr Then closed_if Else expr [ With Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## If
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: If True Then Let Rec WILD EQ Bytes Attr Type
##
## Ends in an error in state: 419.
##
## let_expr(closed_if) -> Let Rec let_binding seq(Attr) . In closed_if [ Else ]
## let_expr(expr) -> Let Rec let_binding seq(Attr) . In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding seq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 171, spurious reduction of production seq(Attr) -> 
## In state 172, spurious reduction of production seq(Attr) -> Attr seq(Attr) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: If True Then Let Rec WILD EQ Bytes In With
##
## Ends in an error in state: 420.
##
## let_expr(closed_if) -> Let Rec let_binding seq(Attr) In . closed_if [ Else ]
## let_expr(expr) -> Let Rec let_binding seq(Attr) In . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding seq(Attr) In
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: If True Then Let Rec WILD EQ Bytes With
##
## Ends in an error in state: 418.
##
## let_expr(closed_if) -> Let Rec let_binding . seq(Attr) In closed_if [ Else ]
## let_expr(expr) -> Let Rec let_binding . seq(Attr) In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 225, spurious reduction of production call_expr_level -> core_expr 
## In state 232, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 214, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 222, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 262, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 252, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 284, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 291, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 298, spurious reduction of production disj_expr_level -> conj_expr_level 
## In state 250, spurious reduction of production base_expr(expr) -> disj_expr_level 
## In state 304, spurious reduction of production base_cond__open(expr) -> base_expr(expr) 
## In state 305, spurious reduction of production expr -> base_cond__open(expr) 
## In state 388, spurious reduction of production let_binding -> irrefutable option(type_annotation) EQ expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: If True Then Let Rec With
##
## Ends in an error in state: 417.
##
## let_expr(closed_if) -> Let Rec . let_binding seq(Attr) In closed_if [ Else ]
## let_expr(expr) -> Let Rec . let_binding seq(Attr) In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let Rec
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: If True Then Let WILD EQ Bytes Attr Type
##
## Ends in an error in state: 435.
##
## let_expr(closed_if) -> Let let_binding seq(Attr) . In closed_if [ Else ]
## let_expr(expr) -> Let let_binding seq(Attr) . In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let let_binding seq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 171, spurious reduction of production seq(Attr) -> 
## In state 172, spurious reduction of production seq(Attr) -> Attr seq(Attr) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: If True Then Let WILD EQ Bytes In With
##
## Ends in an error in state: 436.
##
## let_expr(closed_if) -> Let let_binding seq(Attr) In . closed_if [ Else ]
## let_expr(expr) -> Let let_binding seq(Attr) In . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let let_binding seq(Attr) In
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: If True Then Let WILD EQ Bytes With
##
## Ends in an error in state: 434.
##
## let_expr(closed_if) -> Let let_binding . seq(Attr) In closed_if [ Else ]
## let_expr(expr) -> Let let_binding . seq(Attr) In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 225, spurious reduction of production call_expr_level -> core_expr 
## In state 232, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 214, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 222, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 262, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 252, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 284, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 291, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 298, spurious reduction of production disj_expr_level -> conj_expr_level 
## In state 250, spurious reduction of production base_expr(expr) -> disj_expr_level 
## In state 304, spurious reduction of production base_cond__open(expr) -> base_expr(expr) 
## In state 305, spurious reduction of production expr -> base_cond__open(expr) 
## In state 388, spurious reduction of production let_binding -> irrefutable option(type_annotation) EQ expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: If True Then Let With
##
## Ends in an error in state: 416.
##
## let_expr(closed_if) -> Let . let_binding seq(Attr) In closed_if [ Else ]
## let_expr(closed_if) -> Let . Rec let_binding seq(Attr) In closed_if [ Else ]
## let_expr(expr) -> Let . let_binding seq(Attr) In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
## let_expr(expr) -> Let . Rec let_binding seq(Attr) In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: If True Then Match True Type
##
## Ends in an error in state: 315.
##
## match_expr(base_cond) -> Match expr . With option(VBAR) cases(base_cond) [ With Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
## match_expr(base_if_then_else) -> Match expr . With option(VBAR) cases(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## Match expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 225, spurious reduction of production call_expr_level -> core_expr 
## In state 232, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 214, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 222, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 262, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 252, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 284, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 291, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 298, spurious reduction of production disj_expr_level -> conj_expr_level 
## In state 250, spurious reduction of production base_expr(expr) -> disj_expr_level 
## In state 304, spurious reduction of production base_cond__open(expr) -> base_expr(expr) 
## In state 305, spurious reduction of production expr -> base_cond__open(expr) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: If True Then Match True With VBAR Begin
##
## Ends in an error in state: 318.
##
## match_expr(base_cond) -> Match expr With option(VBAR) . cases(base_cond) [ With Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
## match_expr(base_if_then_else) -> Match expr With option(VBAR) . cases(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## Match expr With option(VBAR)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: If True Then Match True With WILD ARROW Bytes VBAR With
##
## Ends in an error in state: 345.
##
## cases(base_cond) -> cases(base_cond) VBAR . case_clause(base_cond) [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
## cases(base_if_then_else) -> cases(base_cond) VBAR . case_clause(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## cases(base_cond) VBAR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: If True Then Match True With WILD ARROW Fun WILD ARROW With
##
## Ends in an error in state: 398.
##
## fun_expr(base_cond) -> Fun nseq(irrefutable) ARROW . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
## fun_expr(base_if_then_else) -> Fun nseq(irrefutable) ARROW . base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Fun nseq(irrefutable) ARROW
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: If True Then Match True With WILD ARROW Fun With
##
## Ends in an error in state: 396.
##
## fun_expr(base_cond) -> Fun . nseq(irrefutable) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
## fun_expr(base_if_then_else) -> Fun . nseq(irrefutable) ARROW base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Fun
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: If True Then Match True With WILD ARROW If True Then True Else With
##
## Ends in an error in state: 395.
##
## if_then_else(base_cond) -> If expr Then closed_if Else . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
## if_then_else(base_if_then_else) -> If expr Then closed_if Else . base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_if Else
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: If True Then Match True With WILD ARROW If True Then With
##
## Ends in an error in state: 337.
##
## if_then(base_cond) -> If expr Then . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
## if_then_else(base_cond) -> If expr Then . closed_if Else base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
## if_then_else(base_if_then_else) -> If expr Then . closed_if Else base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## If expr Then
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: If True Then Match True With WILD ARROW If True With
##
## Ends in an error in state: 336.
##
## if_then(base_cond) -> If expr . Then base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
## if_then_else(base_cond) -> If expr . Then closed_if Else base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
## if_then_else(base_if_then_else) -> If expr . Then closed_if Else base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## If expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 225, spurious reduction of production call_expr_level -> core_expr 
## In state 232, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 214, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 222, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 262, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 252, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 284, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 291, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 298, spurious reduction of production disj_expr_level -> conj_expr_level 
## In state 250, spurious reduction of production base_expr(expr) -> disj_expr_level 
## In state 304, spurious reduction of production base_cond__open(expr) -> base_expr(expr) 
## In state 305, spurious reduction of production expr -> base_cond__open(expr) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: If True Then Match True With WILD ARROW If With
##
## Ends in an error in state: 335.
##
## if_then(base_cond) -> If . expr Then base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
## if_then_else(base_cond) -> If . expr Then closed_if Else base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
## if_then_else(base_if_then_else) -> If . expr Then closed_if Else base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## If
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: If True Then Match True With WILD ARROW Let Rec WILD EQ Bytes Attr Type
##
## Ends in an error in state: 333.
##
## let_expr(base_cond) -> Let Rec let_binding seq(Attr) . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
## let_expr(base_if_then_else) -> Let Rec let_binding seq(Attr) . In base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding seq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 171, spurious reduction of production seq(Attr) -> 
## In state 172, spurious reduction of production seq(Attr) -> Attr seq(Attr) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: If True Then Match True With WILD ARROW Let Rec WILD EQ Bytes In With
##
## Ends in an error in state: 334.
##
## let_expr(base_cond) -> Let Rec let_binding seq(Attr) In . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
## let_expr(base_if_then_else) -> Let Rec let_binding seq(Attr) In . base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding seq(Attr) In
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: If True Then Match True With WILD ARROW Let Rec WILD EQ Bytes With
##
## Ends in an error in state: 332.
##
## let_expr(base_cond) -> Let Rec let_binding . seq(Attr) In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
## let_expr(base_if_then_else) -> Let Rec let_binding . seq(Attr) In base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 225, spurious reduction of production call_expr_level -> core_expr 
## In state 232, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 214, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 222, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 262, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 252, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 284, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 291, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 298, spurious reduction of production disj_expr_level -> conj_expr_level 
## In state 250, spurious reduction of production base_expr(expr) -> disj_expr_level 
## In state 304, spurious reduction of production base_cond__open(expr) -> base_expr(expr) 
## In state 305, spurious reduction of production expr -> base_cond__open(expr) 
## In state 388, spurious reduction of production let_binding -> irrefutable option(type_annotation) EQ expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: If True Then Match True With WILD ARROW Let Rec With
##
## Ends in an error in state: 331.
##
## let_expr(base_cond) -> Let Rec . let_binding seq(Attr) In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
## let_expr(base_if_then_else) -> Let Rec . let_binding seq(Attr) In base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Let Rec
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: If True Then Match True With WILD ARROW Let WILD EQ Bytes Attr Type
##
## Ends in an error in state: 410.
##
## let_expr(base_cond) -> Let let_binding seq(Attr) . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
## let_expr(base_if_then_else) -> Let let_binding seq(Attr) . In base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Let let_binding seq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 171, spurious reduction of production seq(Attr) -> 
## In state 172, spurious reduction of production seq(Attr) -> Attr seq(Attr) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: If True Then Match True With WILD ARROW Let WILD EQ Bytes In With
##
## Ends in an error in state: 411.
##
## let_expr(base_cond) -> Let let_binding seq(Attr) In . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
## let_expr(base_if_then_else) -> Let let_binding seq(Attr) In . base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Let let_binding seq(Attr) In
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: If True Then Match True With WILD ARROW Let WILD EQ Bytes With
##
## Ends in an error in state: 409.
##
## let_expr(base_cond) -> Let let_binding . seq(Attr) In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
## let_expr(base_if_then_else) -> Let let_binding . seq(Attr) In base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 225, spurious reduction of production call_expr_level -> core_expr 
## In state 232, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 214, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 222, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 262, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 252, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 284, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 291, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 298, spurious reduction of production disj_expr_level -> conj_expr_level 
## In state 250, spurious reduction of production base_expr(expr) -> disj_expr_level 
## In state 304, spurious reduction of production base_cond__open(expr) -> base_expr(expr) 
## In state 305, spurious reduction of production expr -> base_cond__open(expr) 
## In state 388, spurious reduction of production let_binding -> irrefutable option(type_annotation) EQ expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: If True Then Match True With WILD ARROW Let With
##
## Ends in an error in state: 330.
##
## let_expr(base_cond) -> Let . let_binding seq(Attr) In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
## let_expr(base_cond) -> Let . Rec let_binding seq(Attr) In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
## let_expr(base_if_then_else) -> Let . let_binding seq(Attr) In base_if_then_else [ Else ]
## let_expr(base_if_then_else) -> Let . Rec let_binding seq(Attr) In base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Let
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: If True Then Match True With WILD ARROW With
##
## Ends in an error in state: 329.
##
## case_clause(base_cond) -> pattern ARROW . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
## case_clause(base_if_then_else) -> pattern ARROW . base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## pattern ARROW
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: If True Then Match True With WILD CONS Bytes SEMI
##
## Ends in an error in state: 328.
##
## case_clause(base_cond) -> pattern . ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
## case_clause(base_if_then_else) -> pattern . ARROW base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## pattern
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 95, spurious reduction of production tail -> sub_pattern 
## In state 322, spurious reduction of production pattern -> sub_pattern CONS tail 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: If True Then Match True With With
##
## Ends in an error in state: 316.
##
## match_expr(base_cond) -> Match expr With . option(VBAR) cases(base_cond) [ With Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
## match_expr(base_if_then_else) -> Match expr With . option(VBAR) cases(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## Match expr With
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: If True Then Match With
##
## Ends in an error in state: 314.
##
## match_expr(base_cond) -> Match . expr With option(VBAR) cases(base_cond) [ With Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
## match_expr(base_if_then_else) -> Match . expr With option(VBAR) cases(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## Match
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: If True Then True COMMA Bytes VBAR
##
## Ends in an error in state: 427.
##
## base_expr(closed_if) -> tuple_expr . [ Else ]
## base_expr(expr) -> tuple_expr . [ With Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## tuple_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 225, spurious reduction of production call_expr_level -> core_expr 
## In state 232, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 214, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 222, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 262, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 252, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 284, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 291, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 298, spurious reduction of production disj_expr_level -> conj_expr_level 
## In state 295, spurious reduction of production nsepseq(disj_expr_level,COMMA) -> disj_expr_level 
## In state 294, spurious reduction of production tuple(disj_expr_level) -> disj_expr_level COMMA nsepseq(disj_expr_level,COMMA) 
## In state 216, spurious reduction of production tuple_expr -> tuple(disj_expr_level) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: If True Then True Else With
##
## Ends in an error in state: 439.
##
## if_then_else(expr) -> If expr Then closed_if Else . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_if Else
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: If True Then True VBAR
##
## Ends in an error in state: 428.
##
## base_expr(closed_if) -> disj_expr_level . [ Else ]
## base_expr(expr) -> disj_expr_level . [ With Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
## bin_op(disj_expr_level,BOOL_OR,conj_expr_level) -> disj_expr_level . BOOL_OR conj_expr_level [ With Type Then SEMI RPAR RBRACKET RBRACE Or Let In End Else EOF COMMA COLON BOOL_OR Attr ]
## bin_op(disj_expr_level,Or,conj_expr_level) -> disj_expr_level . Or conj_expr_level [ With Type Then SEMI RPAR RBRACKET RBRACE Or Let In End Else EOF COMMA COLON BOOL_OR Attr ]
## tuple(disj_expr_level) -> disj_expr_level . COMMA nsepseq(disj_expr_level,COMMA) [ With Type Then SEMI RPAR RBRACKET RBRACE Let In End Else EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## disj_expr_level
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 225, spurious reduction of production call_expr_level -> core_expr 
## In state 232, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 214, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 222, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 262, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 252, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 284, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 291, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 298, spurious reduction of production disj_expr_level -> conj_expr_level 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: If True Then With
##
## Ends in an error in state: 313.
##
## if_then(expr) -> If expr Then . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
## if_then_else(expr) -> If expr Then . closed_if Else expr [ With Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## If expr Then
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: If True With
##
## Ends in an error in state: 312.
##
## if_then(expr) -> If expr . Then expr [ With Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
## if_then_else(expr) -> If expr . Then closed_if Else expr [ With Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## If expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 225, spurious reduction of production call_expr_level -> core_expr 
## In state 232, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 214, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 222, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 262, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 252, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 284, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 291, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 298, spurious reduction of production disj_expr_level -> conj_expr_level 
## In state 250, spurious reduction of production base_expr(expr) -> disj_expr_level 
## In state 304, spurious reduction of production base_cond__open(expr) -> base_expr(expr) 
## In state 305, spurious reduction of production expr -> base_cond__open(expr) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: If With
##
## Ends in an error in state: 179.
##
## if_then(expr) -> If . expr Then expr [ With Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
## if_then_else(expr) -> If . expr Then closed_if Else expr [ With Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## If
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: LBRACE Constr DOT Ident With
##
## Ends in an error in state: 443.
##
## projection -> Constr DOT Ident . DOT nsepseq(selection,DOT) [ With ]
##
## The known suffix of the stack is as follows:
## Constr DOT Ident
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: LBRACE Constr DOT With
##
## Ends in an error in state: 442.
##
## projection -> Constr DOT . Ident DOT nsepseq(selection,DOT) [ With ]
##
## The known suffix of the stack is as follows:
## Constr DOT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: LBRACE Constr With
##
## Ends in an error in state: 441.
##
## projection -> Constr . DOT Ident DOT nsepseq(selection,DOT) [ With ]
##
## The known suffix of the stack is as follows:
## Constr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: LBRACE Ident DOT Ident VBAR
##
## Ends in an error in state: 447.
##
## update_record -> LBRACE path . With sep_or_term_list(field_path_assignment,SEMI) RBRACE [ With VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Mod MINUS Let LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Constr CONS COMMA COLON CAT Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## LBRACE path
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 184, spurious reduction of production nsepseq(selection,DOT) -> selection 
## In state 187, spurious reduction of production projection -> Ident DOT nsepseq(selection,DOT) 
## In state 446, spurious reduction of production path -> projection 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: LBRACE Ident EQ Bytes SEMI Ident EQ Bytes SEMI With
##
## Ends in an error in state: 474.
##
## nsepseq(field_assignment,SEMI) -> field_assignment SEMI . nsepseq(field_assignment,SEMI) [ RBRACE ]
## seq(__anonymous_0(field_assignment,SEMI)) -> field_assignment SEMI . seq(__anonymous_0(field_assignment,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_assignment SEMI
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: LBRACE Ident EQ Bytes SEMI Ident EQ Bytes With
##
## Ends in an error in state: 473.
##
## nsepseq(field_assignment,SEMI) -> field_assignment . [ RBRACE ]
## nsepseq(field_assignment,SEMI) -> field_assignment . SEMI nsepseq(field_assignment,SEMI) [ RBRACE ]
## seq(__anonymous_0(field_assignment,SEMI)) -> field_assignment . SEMI seq(__anonymous_0(field_assignment,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_assignment
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 225, spurious reduction of production call_expr_level -> core_expr 
## In state 232, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 214, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 222, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 262, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 252, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 284, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 291, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 298, spurious reduction of production disj_expr_level -> conj_expr_level 
## In state 250, spurious reduction of production base_expr(expr) -> disj_expr_level 
## In state 304, spurious reduction of production base_cond__open(expr) -> base_expr(expr) 
## In state 305, spurious reduction of production expr -> base_cond__open(expr) 
## In state 440, spurious reduction of production field_assignment -> Ident EQ expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: LBRACE Ident EQ Bytes SEMI Ident With
##
## Ends in an error in state: 470.
##
## field_assignment -> Ident . EQ expr [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## Ident
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: LBRACE Ident EQ Bytes SEMI With
##
## Ends in an error in state: 469.
##
## nsepseq(field_assignment,SEMI) -> field_assignment SEMI . nsepseq(field_assignment,SEMI) [ RBRACE ]
## nseq(__anonymous_0(field_assignment,SEMI)) -> field_assignment SEMI . seq(__anonymous_0(field_assignment,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_assignment SEMI
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: LBRACE Ident EQ Bytes With
##
## Ends in an error in state: 468.
##
## nsepseq(field_assignment,SEMI) -> field_assignment . [ RBRACE ]
## nsepseq(field_assignment,SEMI) -> field_assignment . SEMI nsepseq(field_assignment,SEMI) [ RBRACE ]
## nseq(__anonymous_0(field_assignment,SEMI)) -> field_assignment . SEMI seq(__anonymous_0(field_assignment,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_assignment
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 225, spurious reduction of production call_expr_level -> core_expr 
## In state 232, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 214, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 222, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 262, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 252, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 284, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 291, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 298, spurious reduction of production disj_expr_level -> conj_expr_level 
## In state 250, spurious reduction of production base_expr(expr) -> disj_expr_level 
## In state 304, spurious reduction of production base_cond__open(expr) -> base_expr(expr) 
## In state 305, spurious reduction of production expr -> base_cond__open(expr) 
## In state 440, spurious reduction of production field_assignment -> Ident EQ expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: LBRACE Ident EQ With
##
## Ends in an error in state: 177.
##
## field_assignment -> Ident EQ . expr [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## Ident EQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: LBRACE Ident WILD
##
## Ends in an error in state: 176.
##
## field_assignment -> Ident . EQ expr [ SEMI RBRACE ]
## path -> Ident . [ With ]
## projection -> Ident . DOT nsepseq(selection,DOT) [ With ]
##
## The known suffix of the stack is as follows:
## Ident
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: LBRACE Ident With Ident DOT With
##
## Ends in an error in state: 450.
##
## nsepseq(field_name,DOT) -> Ident DOT . nsepseq(field_name,DOT) [ EQ ]
##
## The known suffix of the stack is as follows:
## Ident DOT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: LBRACE Ident With Ident EQ Bytes SEMI Ident EQ Bytes SEMI With
##
## Ends in an error in state: 464.
##
## nsepseq(field_path_assignment,SEMI) -> field_path_assignment SEMI . nsepseq(field_path_assignment,SEMI) [ RBRACE ]
## seq(__anonymous_0(field_path_assignment,SEMI)) -> field_path_assignment SEMI . seq(__anonymous_0(field_path_assignment,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_path_assignment SEMI
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: LBRACE Ident With Ident EQ Bytes SEMI Ident EQ Bytes With
##
## Ends in an error in state: 463.
##
## nsepseq(field_path_assignment,SEMI) -> field_path_assignment . [ RBRACE ]
## nsepseq(field_path_assignment,SEMI) -> field_path_assignment . SEMI nsepseq(field_path_assignment,SEMI) [ RBRACE ]
## seq(__anonymous_0(field_path_assignment,SEMI)) -> field_path_assignment . SEMI seq(__anonymous_0(field_path_assignment,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_path_assignment
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 225, spurious reduction of production call_expr_level -> core_expr 
## In state 232, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 214, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 222, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 262, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 252, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 284, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 291, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 298, spurious reduction of production disj_expr_level -> conj_expr_level 
## In state 250, spurious reduction of production base_expr(expr) -> disj_expr_level 
## In state 304, spurious reduction of production base_cond__open(expr) -> base_expr(expr) 
## In state 305, spurious reduction of production expr -> base_cond__open(expr) 
## In state 458, spurious reduction of production field_path_assignment -> nsepseq(field_name,DOT) EQ expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: LBRACE Ident With Ident EQ Bytes SEMI With
##
## Ends in an error in state: 460.
##
## nsepseq(field_path_assignment,SEMI) -> field_path_assignment SEMI . nsepseq(field_path_assignment,SEMI) [ RBRACE ]
## nseq(__anonymous_0(field_path_assignment,SEMI)) -> field_path_assignment SEMI . seq(__anonymous_0(field_path_assignment,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_path_assignment SEMI
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: LBRACE Ident With Ident EQ Bytes With
##
## Ends in an error in state: 459.
##
## nsepseq(field_path_assignment,SEMI) -> field_path_assignment . [ RBRACE ]
## nsepseq(field_path_assignment,SEMI) -> field_path_assignment . SEMI nsepseq(field_path_assignment,SEMI) [ RBRACE ]
## nseq(__anonymous_0(field_path_assignment,SEMI)) -> field_path_assignment . SEMI seq(__anonymous_0(field_path_assignment,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_path_assignment
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 225, spurious reduction of production call_expr_level -> core_expr 
## In state 232, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 214, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 222, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 262, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 252, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 284, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 291, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 298, spurious reduction of production disj_expr_level -> conj_expr_level 
## In state 250, spurious reduction of production base_expr(expr) -> disj_expr_level 
## In state 304, spurious reduction of production base_cond__open(expr) -> base_expr(expr) 
## In state 305, spurious reduction of production expr -> base_cond__open(expr) 
## In state 458, spurious reduction of production field_path_assignment -> nsepseq(field_name,DOT) EQ expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: LBRACE Ident With Ident EQ With
##
## Ends in an error in state: 457.
##
## field_path_assignment -> nsepseq(field_name,DOT) EQ . expr [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## nsepseq(field_name,DOT) EQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: LBRACE Ident With Ident With
##
## Ends in an error in state: 449.
##
## nsepseq(field_name,DOT) -> Ident . [ EQ ]
## nsepseq(field_name,DOT) -> Ident . DOT nsepseq(field_name,DOT) [ EQ ]
##
## The known suffix of the stack is as follows:
## Ident
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: LBRACE Ident With With
##
## Ends in an error in state: 448.
##
## update_record -> LBRACE path With . sep_or_term_list(field_path_assignment,SEMI) RBRACE [ With VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Mod MINUS Let LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Constr CONS COMMA COLON CAT Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## LBRACE path With
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: LBRACE With
##
## Ends in an error in state: 175.
##
## record_expr -> LBRACE . sep_or_term_list(field_assignment,SEMI) RBRACE [ With VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Mod MINUS Let LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Constr CONS COMMA COLON CAT Bytes Begin BOOL_OR BOOL_AND Attr ]
## update_record -> LBRACE . path With sep_or_term_list(field_path_assignment,SEMI) RBRACE [ With VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Mod MINUS Let LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Constr CONS COMMA COLON CAT Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## LBRACE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: LBRACKET True End
##
## Ends in an error in state: 479.
##
## list__(expr) -> LBRACKET option(sep_or_term_list(expr,SEMI)) . RBRACKET [ With VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Mod MINUS Let LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Constr CONS COMMA COLON CAT Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## LBRACKET option(sep_or_term_list(expr,SEMI))
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 225, spurious reduction of production call_expr_level -> core_expr 
## In state 232, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 214, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 222, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 262, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 252, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 284, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 291, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 298, spurious reduction of production disj_expr_level -> conj_expr_level 
## In state 250, spurious reduction of production base_expr(expr) -> disj_expr_level 
## In state 304, spurious reduction of production base_cond__open(expr) -> base_expr(expr) 
## In state 305, spurious reduction of production expr -> base_cond__open(expr) 
## In state 243, spurious reduction of production nsepseq(expr,SEMI) -> expr 
## In state 221, spurious reduction of production sep_or_term_list(expr,SEMI) -> nsepseq(expr,SEMI) 
## In state 217, spurious reduction of production option(sep_or_term_list(expr,SEMI)) -> sep_or_term_list(expr,SEMI) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: LBRACKET True SEMI True SEMI With
##
## Ends in an error in state: 248.
##
## nsepseq(expr,SEMI) -> expr SEMI . nsepseq(expr,SEMI) [ RBRACKET End ]
## seq(__anonymous_0(expr,SEMI)) -> expr SEMI . seq(__anonymous_0(expr,SEMI)) [ RBRACKET End ]
##
## The known suffix of the stack is as follows:
## expr SEMI
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: LBRACKET True SEMI True With
##
## Ends in an error in state: 247.
##
## nsepseq(expr,SEMI) -> expr . [ RBRACKET End ]
## nsepseq(expr,SEMI) -> expr . SEMI nsepseq(expr,SEMI) [ RBRACKET End ]
## seq(__anonymous_0(expr,SEMI)) -> expr . SEMI seq(__anonymous_0(expr,SEMI)) [ RBRACKET End ]
##
## The known suffix of the stack is as follows:
## expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 225, spurious reduction of production call_expr_level -> core_expr 
## In state 232, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 214, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 222, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 262, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 252, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 284, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 291, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 298, spurious reduction of production disj_expr_level -> conj_expr_level 
## In state 250, spurious reduction of production base_expr(expr) -> disj_expr_level 
## In state 304, spurious reduction of production base_cond__open(expr) -> base_expr(expr) 
## In state 305, spurious reduction of production expr -> base_cond__open(expr) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: LBRACKET True SEMI With
##
## Ends in an error in state: 244.
##
## nsepseq(expr,SEMI) -> expr SEMI . nsepseq(expr,SEMI) [ RBRACKET End ]
## nseq(__anonymous_0(expr,SEMI)) -> expr SEMI . seq(__anonymous_0(expr,SEMI)) [ RBRACKET End ]
##
## The known suffix of the stack is as follows:
## expr SEMI
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: LBRACKET True With
##
## Ends in an error in state: 243.
##
## nsepseq(expr,SEMI) -> expr . [ RBRACKET End ]
## nsepseq(expr,SEMI) -> expr . SEMI nsepseq(expr,SEMI) [ RBRACKET End ]
## nseq(__anonymous_0(expr,SEMI)) -> expr . SEMI seq(__anonymous_0(expr,SEMI)) [ RBRACKET End ]
##
## The known suffix of the stack is as follows:
## expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 225, spurious reduction of production call_expr_level -> core_expr 
## In state 232, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 214, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 222, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 262, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 252, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 284, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 291, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 298, spurious reduction of production disj_expr_level -> conj_expr_level 
## In state 250, spurious reduction of production base_expr(expr) -> disj_expr_level 
## In state 304, spurious reduction of production base_cond__open(expr) -> base_expr(expr) 
## In state 305, spurious reduction of production expr -> base_cond__open(expr) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: LBRACKET With
##
## Ends in an error in state: 167.
##
## list__(expr) -> LBRACKET . option(sep_or_term_list(expr,SEMI)) RBRACKET [ With VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Mod MINUS Let LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Constr CONS COMMA COLON CAT Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## LBRACKET
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: LPAR True COLON Ident VBAR
##
## Ends in an error in state: 510.
##
## par(__anonymous_1) -> LPAR expr COLON type_expr . RPAR [ With VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Mod MINUS Let LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Constr CONS COMMA COLON CAT Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## LPAR expr COLON type_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 27, spurious reduction of production cartesian -> core_type 
## In state 35, spurious reduction of production fun_type -> cartesian 
## In state 26, spurious reduction of production type_expr -> fun_type 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: LPAR True COLON With
##
## Ends in an error in state: 509.
##
## par(__anonymous_1) -> LPAR expr COLON . type_expr RPAR [ With VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Mod MINUS Let LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Constr CONS COMMA COLON CAT Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## LPAR expr COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: LPAR True With
##
## Ends in an error in state: 507.
##
## par(__anonymous_1) -> LPAR expr . COLON type_expr RPAR [ With VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Mod MINUS Let LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Constr CONS COMMA COLON CAT Bytes Begin BOOL_OR BOOL_AND Attr ]
## par(expr) -> LPAR expr . RPAR [ With VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Mod MINUS Let LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Constr CONS COMMA COLON CAT Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## LPAR expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 225, spurious reduction of production call_expr_level -> core_expr 
## In state 232, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 214, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 222, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 262, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 252, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 284, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 291, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 298, spurious reduction of production disj_expr_level -> conj_expr_level 
## In state 250, spurious reduction of production base_expr(expr) -> disj_expr_level 
## In state 304, spurious reduction of production base_cond__open(expr) -> base_expr(expr) 
## In state 305, spurious reduction of production expr -> base_cond__open(expr) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: LPAR With
##
## Ends in an error in state: 164.
##
## par(__anonymous_1) -> LPAR . expr COLON type_expr RPAR [ With VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Mod MINUS Let LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Constr CONS COMMA COLON CAT Bytes Begin BOOL_OR BOOL_AND Attr ]
## par(expr) -> LPAR . expr RPAR [ With VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Mod MINUS Let LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Constr CONS COMMA COLON CAT Bytes Begin BOOL_OR BOOL_AND Attr ]
## unit -> LPAR . RPAR [ With VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Mod MINUS Let LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Constr CONS COMMA COLON CAT Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## LPAR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Let Rec WILD EQ Bytes Attr Type
##
## Ends in an error in state: 173.
##
## let_expr(expr) -> Let Rec let_binding seq(Attr) . In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding seq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 171, spurious reduction of production seq(Attr) -> 
## In state 172, spurious reduction of production seq(Attr) -> Attr seq(Attr) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Let Rec WILD EQ Bytes In With
##
## Ends in an error in state: 174.
##
## let_expr(expr) -> Let Rec let_binding seq(Attr) In . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding seq(Attr) In
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Let Rec WILD EQ Bytes With
##
## Ends in an error in state: 170.
##
## let_expr(expr) -> Let Rec let_binding . seq(Attr) In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 225, spurious reduction of production call_expr_level -> core_expr 
## In state 232, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 214, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 222, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 262, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 252, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 284, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 291, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 298, spurious reduction of production disj_expr_level -> conj_expr_level 
## In state 250, spurious reduction of production base_expr(expr) -> disj_expr_level 
## In state 304, spurious reduction of production base_cond__open(expr) -> base_expr(expr) 
## In state 305, spurious reduction of production expr -> base_cond__open(expr) 
## In state 388, spurious reduction of production let_binding -> irrefutable option(type_annotation) EQ expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Let Rec With
##
## Ends in an error in state: 169.
##
## let_expr(expr) -> Let Rec . let_binding seq(Attr) In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let Rec
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Let WILD EQ Bytes Attr Type
##
## Ends in an error in state: 477.
##
## let_expr(expr) -> Let let_binding seq(Attr) . In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let let_binding seq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 171, spurious reduction of production seq(Attr) -> 
## In state 172, spurious reduction of production seq(Attr) -> Attr seq(Attr) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Let WILD EQ Bytes In With
##
## Ends in an error in state: 478.
##
## let_expr(expr) -> Let let_binding seq(Attr) In . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let let_binding seq(Attr) In
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Let WILD EQ Bytes With
##
## Ends in an error in state: 476.
##
## let_expr(expr) -> Let let_binding . seq(Attr) In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 225, spurious reduction of production call_expr_level -> core_expr 
## In state 232, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 214, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 222, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 262, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 252, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 284, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 291, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 298, spurious reduction of production disj_expr_level -> conj_expr_level 
## In state 250, spurious reduction of production base_expr(expr) -> disj_expr_level 
## In state 304, spurious reduction of production base_cond__open(expr) -> base_expr(expr) 
## In state 305, spurious reduction of production expr -> base_cond__open(expr) 
## In state 388, spurious reduction of production let_binding -> irrefutable option(type_annotation) EQ expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Let With
##
## Ends in an error in state: 168.
##
## let_expr(expr) -> Let . let_binding seq(Attr) In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
## let_expr(expr) -> Let . Rec let_binding seq(Attr) In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: MINUS With
##
## Ends in an error in state: 166.
##
## unary_expr_level -> MINUS . call_expr_level [ With VBAR Type Then TIMES SLASH SEMI RPAR RBRACKET RBRACE PLUS Or NE Mod MINUS Let LT LE In GT GE End Else EQ EOF CONS COMMA COLON CAT BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## MINUS
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match True Type
##
## Ends in an error in state: 482.
##
## match_expr(base_cond) -> Match expr . With option(VBAR) cases(base_cond) [ With Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## Match expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 225, spurious reduction of production call_expr_level -> core_expr 
## In state 232, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 214, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 222, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 262, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 252, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 284, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 291, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 298, spurious reduction of production disj_expr_level -> conj_expr_level 
## In state 250, spurious reduction of production base_expr(expr) -> disj_expr_level 
## In state 304, spurious reduction of production base_cond__open(expr) -> base_expr(expr) 
## In state 305, spurious reduction of production expr -> base_cond__open(expr) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match True With LPAR Bytes RPAR With
##
## Ends in an error in state: 320.
##
## pattern -> sub_pattern . CONS tail [ ARROW ]
## tuple(sub_pattern) -> sub_pattern . COMMA nsepseq(sub_pattern,COMMA) [ ARROW ]
##
## The known suffix of the stack is as follows:
## sub_pattern
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match True With VBAR Begin
##
## Ends in an error in state: 484.
##
## match_expr(base_cond) -> Match expr With option(VBAR) . cases(base_cond) [ With Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## Match expr With option(VBAR)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match True With WILD ARROW Bytes VBAR With
##
## Ends in an error in state: 506.
##
## cases(base_cond) -> cases(base_cond) VBAR . case_clause(base_cond) [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## cases(base_cond) VBAR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match True With WILD ARROW Fun WILD ARROW With
##
## Ends in an error in state: 499.
##
## fun_expr(base_cond) -> Fun nseq(irrefutable) ARROW . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun nseq(irrefutable) ARROW
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match True With WILD ARROW Fun With
##
## Ends in an error in state: 497.
##
## fun_expr(base_cond) -> Fun . nseq(irrefutable) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match True With WILD ARROW If True Then Fun WILD ARROW With
##
## Ends in an error in state: 360.
##
## fun_expr(base_cond) -> Fun nseq(irrefutable) ARROW . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
## fun_expr(closed_if) -> Fun nseq(irrefutable) ARROW . closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## Fun nseq(irrefutable) ARROW
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match True With WILD ARROW If True Then Fun With
##
## Ends in an error in state: 358.
##
## fun_expr(base_cond) -> Fun . nseq(irrefutable) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
## fun_expr(closed_if) -> Fun . nseq(irrefutable) ARROW closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## Fun
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match True With WILD ARROW If True Then If True Then True Else With
##
## Ends in an error in state: 379.
##
## if_then_else(base_cond) -> If expr Then closed_if Else . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
## if_then_else(closed_if) -> If expr Then closed_if Else . closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_if Else
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match True With WILD ARROW If True Then If True Then With
##
## Ends in an error in state: 357.
##
## if_then(base_cond) -> If expr Then . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
## if_then_else(base_cond) -> If expr Then . closed_if Else base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
## if_then_else(closed_if) -> If expr Then . closed_if Else closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## If expr Then
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match True With WILD ARROW If True Then If True With
##
## Ends in an error in state: 356.
##
## if_then(base_cond) -> If expr . Then base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
## if_then_else(base_cond) -> If expr . Then closed_if Else base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
## if_then_else(closed_if) -> If expr . Then closed_if Else closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## If expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 225, spurious reduction of production call_expr_level -> core_expr 
## In state 232, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 214, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 222, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 262, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 252, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 284, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 291, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 298, spurious reduction of production disj_expr_level -> conj_expr_level 
## In state 250, spurious reduction of production base_expr(expr) -> disj_expr_level 
## In state 304, spurious reduction of production base_cond__open(expr) -> base_expr(expr) 
## In state 305, spurious reduction of production expr -> base_cond__open(expr) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match True With WILD ARROW If True Then If With
##
## Ends in an error in state: 355.
##
## if_then(base_cond) -> If . expr Then base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
## if_then_else(base_cond) -> If . expr Then closed_if Else base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
## if_then_else(closed_if) -> If . expr Then closed_if Else closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## If
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match True With WILD ARROW If True Then Let Rec WILD EQ Bytes Attr Type
##
## Ends in an error in state: 353.
##
## let_expr(base_cond) -> Let Rec let_binding seq(Attr) . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
## let_expr(closed_if) -> Let Rec let_binding seq(Attr) . In closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding seq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 171, spurious reduction of production seq(Attr) -> 
## In state 172, spurious reduction of production seq(Attr) -> Attr seq(Attr) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match True With WILD ARROW If True Then Let Rec WILD EQ Bytes In With
##
## Ends in an error in state: 354.
##
## let_expr(base_cond) -> Let Rec let_binding seq(Attr) In . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
## let_expr(closed_if) -> Let Rec let_binding seq(Attr) In . closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding seq(Attr) In
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match True With WILD ARROW If True Then Let Rec WILD EQ Bytes With
##
## Ends in an error in state: 352.
##
## let_expr(base_cond) -> Let Rec let_binding . seq(Attr) In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
## let_expr(closed_if) -> Let Rec let_binding . seq(Attr) In closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 225, spurious reduction of production call_expr_level -> core_expr 
## In state 232, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 214, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 222, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 262, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 252, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 284, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 291, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 298, spurious reduction of production disj_expr_level -> conj_expr_level 
## In state 250, spurious reduction of production base_expr(expr) -> disj_expr_level 
## In state 304, spurious reduction of production base_cond__open(expr) -> base_expr(expr) 
## In state 305, spurious reduction of production expr -> base_cond__open(expr) 
## In state 388, spurious reduction of production let_binding -> irrefutable option(type_annotation) EQ expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match True With WILD ARROW If True Then Let Rec With
##
## Ends in an error in state: 351.
##
## let_expr(base_cond) -> Let Rec . let_binding seq(Attr) In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
## let_expr(closed_if) -> Let Rec . let_binding seq(Attr) In closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## Let Rec
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match True With WILD ARROW If True Then Let WILD EQ Bytes Attr Type
##
## Ends in an error in state: 390.
##
## let_expr(base_cond) -> Let let_binding seq(Attr) . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
## let_expr(closed_if) -> Let let_binding seq(Attr) . In closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## Let let_binding seq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 171, spurious reduction of production seq(Attr) -> 
## In state 172, spurious reduction of production seq(Attr) -> Attr seq(Attr) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match True With WILD ARROW If True Then Let WILD EQ Bytes In With
##
## Ends in an error in state: 391.
##
## let_expr(base_cond) -> Let let_binding seq(Attr) In . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
## let_expr(closed_if) -> Let let_binding seq(Attr) In . closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## Let let_binding seq(Attr) In
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match True With WILD ARROW If True Then Let WILD EQ Bytes With
##
## Ends in an error in state: 389.
##
## let_expr(base_cond) -> Let let_binding . seq(Attr) In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
## let_expr(closed_if) -> Let let_binding . seq(Attr) In closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 225, spurious reduction of production call_expr_level -> core_expr 
## In state 232, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 214, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 222, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 262, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 252, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 284, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 291, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 298, spurious reduction of production disj_expr_level -> conj_expr_level 
## In state 250, spurious reduction of production base_expr(expr) -> disj_expr_level 
## In state 304, spurious reduction of production base_cond__open(expr) -> base_expr(expr) 
## In state 305, spurious reduction of production expr -> base_cond__open(expr) 
## In state 388, spurious reduction of production let_binding -> irrefutable option(type_annotation) EQ expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match True With WILD ARROW If True Then Let With
##
## Ends in an error in state: 350.
##
## let_expr(base_cond) -> Let . let_binding seq(Attr) In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
## let_expr(base_cond) -> Let . Rec let_binding seq(Attr) In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
## let_expr(closed_if) -> Let . let_binding seq(Attr) In closed_if [ Else ]
## let_expr(closed_if) -> Let . Rec let_binding seq(Attr) In closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## Let
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match True With WILD ARROW If True Then Match True Type
##
## Ends in an error in state: 339.
##
## match_expr(base_if_then_else) -> Match expr . With option(VBAR) cases(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## Match expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 225, spurious reduction of production call_expr_level -> core_expr 
## In state 232, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 214, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 222, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 262, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 252, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 284, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 291, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 298, spurious reduction of production disj_expr_level -> conj_expr_level 
## In state 250, spurious reduction of production base_expr(expr) -> disj_expr_level 
## In state 304, spurious reduction of production base_cond__open(expr) -> base_expr(expr) 
## In state 305, spurious reduction of production expr -> base_cond__open(expr) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match True With WILD ARROW If True Then Match True With VBAR Begin
##
## Ends in an error in state: 341.
##
## match_expr(base_if_then_else) -> Match expr With option(VBAR) . cases(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## Match expr With option(VBAR)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match True With WILD ARROW If True Then Match True With WILD ARROW Bytes With
##
## Ends in an error in state: 344.
##
## cases(base_cond) -> cases(base_cond) . VBAR case_clause(base_cond) [ VBAR ]
## cases(base_if_then_else) -> cases(base_cond) . VBAR case_clause(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## cases(base_cond)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 225, spurious reduction of production call_expr_level -> core_expr 
## In state 232, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 214, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 222, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 262, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 252, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 284, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 291, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 298, spurious reduction of production disj_expr_level -> conj_expr_level 
## In state 403, spurious reduction of production base_expr(base_cond) -> disj_expr_level 
## In state 375, spurious reduction of production base_cond__open(base_cond) -> base_expr(base_cond) 
## In state 376, spurious reduction of production base_cond -> base_cond__open(base_cond) 
## In state 414, spurious reduction of production case_clause(base_cond) -> pattern ARROW base_cond 
## In state 349, spurious reduction of production cases(base_cond) -> case_clause(base_cond) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match True With WILD ARROW If True Then Match True With With
##
## Ends in an error in state: 340.
##
## match_expr(base_if_then_else) -> Match expr With . option(VBAR) cases(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## Match expr With
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match True With WILD ARROW If True Then Match With
##
## Ends in an error in state: 338.
##
## match_expr(base_if_then_else) -> Match . expr With option(VBAR) cases(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## Match
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match True With WILD ARROW If True Then True Else With
##
## Ends in an error in state: 496.
##
## if_then_else(base_cond) -> If expr Then closed_if Else . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_if Else
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match True With WILD ARROW If True Then With
##
## Ends in an error in state: 494.
##
## if_then(base_cond) -> If expr Then . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
## if_then_else(base_cond) -> If expr Then . closed_if Else base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## If expr Then
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match True With WILD ARROW If True With
##
## Ends in an error in state: 493.
##
## if_then(base_cond) -> If expr . Then base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
## if_then_else(base_cond) -> If expr . Then closed_if Else base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## If expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 225, spurious reduction of production call_expr_level -> core_expr 
## In state 232, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 214, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 222, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 262, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 252, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 284, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 291, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 298, spurious reduction of production disj_expr_level -> conj_expr_level 
## In state 250, spurious reduction of production base_expr(expr) -> disj_expr_level 
## In state 304, spurious reduction of production base_cond__open(expr) -> base_expr(expr) 
## In state 305, spurious reduction of production expr -> base_cond__open(expr) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match True With WILD ARROW If With
##
## Ends in an error in state: 492.
##
## if_then(base_cond) -> If . expr Then base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
## if_then_else(base_cond) -> If . expr Then closed_if Else base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## If
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match True With WILD ARROW Let Rec WILD EQ Bytes Attr Type
##
## Ends in an error in state: 490.
##
## let_expr(base_cond) -> Let Rec let_binding seq(Attr) . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding seq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 171, spurious reduction of production seq(Attr) -> 
## In state 172, spurious reduction of production seq(Attr) -> Attr seq(Attr) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match True With WILD ARROW Let Rec WILD EQ Bytes In With
##
## Ends in an error in state: 491.
##
## let_expr(base_cond) -> Let Rec let_binding seq(Attr) In . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding seq(Attr) In
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match True With WILD ARROW Let Rec WILD EQ Bytes With
##
## Ends in an error in state: 489.
##
## let_expr(base_cond) -> Let Rec let_binding . seq(Attr) In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 225, spurious reduction of production call_expr_level -> core_expr 
## In state 232, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 214, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 222, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 262, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 252, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 284, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 291, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 298, spurious reduction of production disj_expr_level -> conj_expr_level 
## In state 250, spurious reduction of production base_expr(expr) -> disj_expr_level 
## In state 304, spurious reduction of production base_cond__open(expr) -> base_expr(expr) 
## In state 305, spurious reduction of production expr -> base_cond__open(expr) 
## In state 388, spurious reduction of production let_binding -> irrefutable option(type_annotation) EQ expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match True With WILD ARROW Let Rec With
##
## Ends in an error in state: 488.
##
## let_expr(base_cond) -> Let Rec . let_binding seq(Attr) In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let Rec
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match True With WILD ARROW Let WILD EQ Bytes Attr Type
##
## Ends in an error in state: 503.
##
## let_expr(base_cond) -> Let let_binding seq(Attr) . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let let_binding seq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 171, spurious reduction of production seq(Attr) -> 
## In state 172, spurious reduction of production seq(Attr) -> Attr seq(Attr) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match True With WILD ARROW Let WILD EQ Bytes In With
##
## Ends in an error in state: 504.
##
## let_expr(base_cond) -> Let let_binding seq(Attr) In . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let let_binding seq(Attr) In
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match True With WILD ARROW Let WILD EQ Bytes With
##
## Ends in an error in state: 502.
##
## let_expr(base_cond) -> Let let_binding . seq(Attr) In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 225, spurious reduction of production call_expr_level -> core_expr 
## In state 232, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 214, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 222, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 262, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 252, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 284, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 291, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 298, spurious reduction of production disj_expr_level -> conj_expr_level 
## In state 250, spurious reduction of production base_expr(expr) -> disj_expr_level 
## In state 304, spurious reduction of production base_cond__open(expr) -> base_expr(expr) 
## In state 305, spurious reduction of production expr -> base_cond__open(expr) 
## In state 388, spurious reduction of production let_binding -> irrefutable option(type_annotation) EQ expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match True With WILD ARROW Let With
##
## Ends in an error in state: 487.
##
## let_expr(base_cond) -> Let . let_binding seq(Attr) In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
## let_expr(base_cond) -> Let . Rec let_binding seq(Attr) In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match True With WILD ARROW True COMMA Bytes Else
##
## Ends in an error in state: 505.
##
## cases(base_cond) -> cases(base_cond) . VBAR case_clause(base_cond) [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
## match_expr(base_cond) -> Match expr With option(VBAR) cases(base_cond) . [ With Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## Match expr With option(VBAR) cases(base_cond)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 225, spurious reduction of production call_expr_level -> core_expr 
## In state 232, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 214, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 222, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 262, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 252, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 284, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 291, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 298, spurious reduction of production disj_expr_level -> conj_expr_level 
## In state 295, spurious reduction of production nsepseq(disj_expr_level,COMMA) -> disj_expr_level 
## In state 294, spurious reduction of production tuple(disj_expr_level) -> disj_expr_level COMMA nsepseq(disj_expr_level,COMMA) 
## In state 216, spurious reduction of production tuple_expr -> tuple(disj_expr_level) 
## In state 500, spurious reduction of production base_expr(base_cond) -> tuple_expr 
## In state 375, spurious reduction of production base_cond__open(base_cond) -> base_expr(base_cond) 
## In state 376, spurious reduction of production base_cond -> base_cond__open(base_cond) 
## In state 414, spurious reduction of production case_clause(base_cond) -> pattern ARROW base_cond 
## In state 349, spurious reduction of production cases(base_cond) -> case_clause(base_cond) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match True With WILD ARROW True Else
##
## Ends in an error in state: 501.
##
## base_expr(base_cond) -> disj_expr_level . [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
## bin_op(disj_expr_level,BOOL_OR,conj_expr_level) -> disj_expr_level . BOOL_OR conj_expr_level [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Or Let In End EOF COMMA COLON BOOL_OR Attr ]
## bin_op(disj_expr_level,Or,conj_expr_level) -> disj_expr_level . Or conj_expr_level [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Or Let In End EOF COMMA COLON BOOL_OR Attr ]
## tuple(disj_expr_level) -> disj_expr_level . COMMA nsepseq(disj_expr_level,COMMA) [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## disj_expr_level
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 225, spurious reduction of production call_expr_level -> core_expr 
## In state 232, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 214, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 222, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 262, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 252, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 284, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 291, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 298, spurious reduction of production disj_expr_level -> conj_expr_level 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match True With WILD ARROW With
##
## Ends in an error in state: 486.
##
## case_clause(base_cond) -> pattern ARROW . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## pattern ARROW
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match True With WILD COMMA WILD COMMA With
##
## Ends in an error in state: 325.
##
## nsepseq(sub_pattern,COMMA) -> sub_pattern COMMA . nsepseq(sub_pattern,COMMA) [ ARROW ]
##
## The known suffix of the stack is as follows:
## sub_pattern COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match True With WILD COMMA WILD With
##
## Ends in an error in state: 324.
##
## nsepseq(sub_pattern,COMMA) -> sub_pattern . [ ARROW ]
## nsepseq(sub_pattern,COMMA) -> sub_pattern . COMMA nsepseq(sub_pattern,COMMA) [ ARROW ]
##
## The known suffix of the stack is as follows:
## sub_pattern
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match True With WILD COMMA With
##
## Ends in an error in state: 323.
##
## tuple(sub_pattern) -> sub_pattern COMMA . nsepseq(sub_pattern,COMMA) [ ARROW ]
##
## The known suffix of the stack is as follows:
## sub_pattern COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match True With WILD CONS Bytes SEMI
##
## Ends in an error in state: 485.
##
## case_clause(base_cond) -> pattern . ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## pattern
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 95, spurious reduction of production tail -> sub_pattern 
## In state 322, spurious reduction of production pattern -> sub_pattern CONS tail 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match True With WILD CONS With
##
## Ends in an error in state: 321.
##
## pattern -> sub_pattern CONS . tail [ ARROW ]
##
## The known suffix of the stack is as follows:
## sub_pattern CONS
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match True With WILD With
##
## Ends in an error in state: 342.
##
## pattern -> core_pattern . [ ARROW ]
## sub_pattern -> core_pattern . [ CONS COMMA ]
##
## The known suffix of the stack is as follows:
## core_pattern
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match True With With
##
## Ends in an error in state: 483.
##
## match_expr(base_cond) -> Match expr With . option(VBAR) cases(base_cond) [ With Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## Match expr With
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match With
##
## Ends in an error in state: 165.
##
## match_expr(base_cond) -> Match . expr With option(VBAR) cases(base_cond) [ With Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## Match
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Not With
##
## Ends in an error in state: 161.
##
## unary_expr_level -> Not . call_expr_level [ With VBAR Type Then TIMES SLASH SEMI RPAR RBRACKET RBRACE PLUS Or NE Mod MINUS Let LT LE In GT GE End Else EQ EOF CONS COMMA COLON CAT BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## Not
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: True BOOL_AND With
##
## Ends in an error in state: 270.
##
## bin_op(conj_expr_level,BOOL_AND,comp_expr_level) -> conj_expr_level BOOL_AND . comp_expr_level [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Or Let In End Else EOF COMMA COLON BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## conj_expr_level BOOL_AND
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: True BOOL_OR With
##
## Ends in an error in state: 301.
##
## bin_op(disj_expr_level,BOOL_OR,conj_expr_level) -> disj_expr_level BOOL_OR . conj_expr_level [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Or Let In End Else EOF COMMA COLON BOOL_OR Attr ]
##
## The known suffix of the stack is as follows:
## disj_expr_level BOOL_OR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: True CAT With
##
## Ends in an error in state: 253.
##
## bin_op(cons_expr_level,CAT,cat_expr_level) -> cons_expr_level CAT . cat_expr_level [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Or NE Let LT LE In GT GE End Else EQ EOF COMMA COLON BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## cons_expr_level CAT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: True COMMA True COMMA With
##
## Ends in an error in state: 296.
##
## nsepseq(disj_expr_level,COMMA) -> disj_expr_level COMMA . nsepseq(disj_expr_level,COMMA) [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In End Else EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## disj_expr_level COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: True COMMA With
##
## Ends in an error in state: 293.
##
## tuple(disj_expr_level) -> disj_expr_level COMMA . nsepseq(disj_expr_level,COMMA) [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Let In End Else EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## disj_expr_level COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: True CONS With
##
## Ends in an error in state: 267.
##
## bin_op(add_expr_level,CONS,cons_expr_level) -> add_expr_level CONS . cons_expr_level [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Or NE Let LT LE In GT GE End Else EQ EOF COMMA COLON CAT BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## add_expr_level CONS
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: True Constr With
##
## Ends in an error in state: 199.
##
## module_field -> Constr . DOT module_fun [ With VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Mod MINUS Let LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Constr CONS COMMA COLON CAT Bytes Begin BOOL_OR BOOL_AND Attr ]
## projection -> Constr . DOT Ident DOT nsepseq(selection,DOT) [ With VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Mod MINUS Let LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Constr CONS COMMA COLON CAT Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## Constr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: True EQ With
##
## Ends in an error in state: 282.
##
## bin_op(comp_expr_level,EQ,cat_expr_level) -> comp_expr_level EQ . cat_expr_level [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Or NE Let LT LE In GT GE End Else EQ EOF COMMA COLON BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## comp_expr_level EQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: True GE With
##
## Ends in an error in state: 280.
##
## bin_op(comp_expr_level,GE,cat_expr_level) -> comp_expr_level GE . cat_expr_level [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Or NE Let LT LE In GT GE End Else EQ EOF COMMA COLON BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## comp_expr_level GE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: True GT With
##
## Ends in an error in state: 278.
##
## bin_op(comp_expr_level,GT,cat_expr_level) -> comp_expr_level GT . cat_expr_level [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Or NE Let LT LE In GT GE End Else EQ EOF COMMA COLON BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## comp_expr_level GT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: True LE With
##
## Ends in an error in state: 276.
##
## bin_op(comp_expr_level,LE,cat_expr_level) -> comp_expr_level LE . cat_expr_level [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Or NE Let LT LE In GT GE End Else EQ EOF COMMA COLON BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## comp_expr_level LE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: True LT With
##
## Ends in an error in state: 274.
##
## bin_op(comp_expr_level,LT,cat_expr_level) -> comp_expr_level LT . cat_expr_level [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Or NE Let LT LE In GT GE End Else EQ EOF COMMA COLON BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## comp_expr_level LT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: True MINUS C_None WILD
##
## Ends in an error in state: 266.
##
## bin_op(add_expr_level,MINUS,mult_expr_level) -> add_expr_level MINUS mult_expr_level . [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE PLUS Or NE MINUS Let LT LE In GT GE End Else EQ EOF CONS COMMA COLON CAT BOOL_OR BOOL_AND Attr ]
## bin_op(mult_expr_level,Mod,unary_expr_level) -> mult_expr_level . Mod unary_expr_level [ With VBAR Type Then TIMES SLASH SEMI RPAR RBRACKET RBRACE PLUS Or NE Mod MINUS Let LT LE In GT GE End Else EQ EOF CONS COMMA COLON CAT BOOL_OR BOOL_AND Attr ]
## bin_op(mult_expr_level,SLASH,unary_expr_level) -> mult_expr_level . SLASH unary_expr_level [ With VBAR Type Then TIMES SLASH SEMI RPAR RBRACKET RBRACE PLUS Or NE Mod MINUS Let LT LE In GT GE End Else EQ EOF CONS COMMA COLON CAT BOOL_OR BOOL_AND Attr ]
## bin_op(mult_expr_level,TIMES,unary_expr_level) -> mult_expr_level . TIMES unary_expr_level [ With VBAR Type Then TIMES SLASH SEMI RPAR RBRACKET RBRACE PLUS Or NE Mod MINUS Let LT LE In GT GE End Else EQ EOF CONS COMMA COLON CAT BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## add_expr_level MINUS mult_expr_level
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: True MINUS With
##
## Ends in an error in state: 265.
##
## bin_op(add_expr_level,MINUS,mult_expr_level) -> add_expr_level MINUS . mult_expr_level [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE PLUS Or NE MINUS Let LT LE In GT GE End Else EQ EOF CONS COMMA COLON CAT BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## add_expr_level MINUS
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: True Mod With
##
## Ends in an error in state: 236.
##
## bin_op(mult_expr_level,Mod,unary_expr_level) -> mult_expr_level Mod . unary_expr_level [ With VBAR Type Then TIMES SLASH SEMI RPAR RBRACKET RBRACE PLUS Or NE Mod MINUS Let LT LE In GT GE End Else EQ EOF CONS COMMA COLON CAT BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## mult_expr_level Mod
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: True NE With
##
## Ends in an error in state: 272.
##
## bin_op(comp_expr_level,NE,cat_expr_level) -> comp_expr_level NE . cat_expr_level [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Or NE Let LT LE In GT GE End Else EQ EOF COMMA COLON BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## comp_expr_level NE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: True Or With
##
## Ends in an error in state: 251.
##
## bin_op(disj_expr_level,Or,conj_expr_level) -> disj_expr_level Or . conj_expr_level [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Or Let In End Else EOF COMMA COLON BOOL_OR Attr ]
##
## The known suffix of the stack is as follows:
## disj_expr_level Or
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: True PLUS C_None WILD
##
## Ends in an error in state: 264.
##
## bin_op(add_expr_level,PLUS,mult_expr_level) -> add_expr_level PLUS mult_expr_level . [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE PLUS Or NE MINUS Let LT LE In GT GE End Else EQ EOF CONS COMMA COLON CAT BOOL_OR BOOL_AND Attr ]
## bin_op(mult_expr_level,Mod,unary_expr_level) -> mult_expr_level . Mod unary_expr_level [ With VBAR Type Then TIMES SLASH SEMI RPAR RBRACKET RBRACE PLUS Or NE Mod MINUS Let LT LE In GT GE End Else EQ EOF CONS COMMA COLON CAT BOOL_OR BOOL_AND Attr ]
## bin_op(mult_expr_level,SLASH,unary_expr_level) -> mult_expr_level . SLASH unary_expr_level [ With VBAR Type Then TIMES SLASH SEMI RPAR RBRACKET RBRACE PLUS Or NE Mod MINUS Let LT LE In GT GE End Else EQ EOF CONS COMMA COLON CAT BOOL_OR BOOL_AND Attr ]
## bin_op(mult_expr_level,TIMES,unary_expr_level) -> mult_expr_level . TIMES unary_expr_level [ With VBAR Type Then TIMES SLASH SEMI RPAR RBRACKET RBRACE PLUS Or NE Mod MINUS Let LT LE In GT GE End Else EQ EOF CONS COMMA COLON CAT BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## add_expr_level PLUS mult_expr_level
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: True PLUS With
##
## Ends in an error in state: 263.
##
## bin_op(add_expr_level,PLUS,mult_expr_level) -> add_expr_level PLUS . mult_expr_level [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE PLUS Or NE MINUS Let LT LE In GT GE End Else EQ EOF CONS COMMA COLON CAT BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## add_expr_level PLUS
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: True SLASH With
##
## Ends in an error in state: 234.
##
## bin_op(mult_expr_level,SLASH,unary_expr_level) -> mult_expr_level SLASH . unary_expr_level [ With VBAR Type Then TIMES SLASH SEMI RPAR RBRACKET RBRACE PLUS Or NE Mod MINUS Let LT LE In GT GE End Else EQ EOF CONS COMMA COLON CAT BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## mult_expr_level SLASH
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: True TIMES With
##
## Ends in an error in state: 223.
##
## bin_op(mult_expr_level,TIMES,unary_expr_level) -> mult_expr_level TIMES . unary_expr_level [ With VBAR Type Then TIMES SLASH SEMI RPAR RBRACKET RBRACE PLUS Or NE Mod MINUS Let LT LE In GT GE End Else EQ EOF CONS COMMA COLON CAT BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## mult_expr_level TIMES
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: True True True WILD
##
## Ends in an error in state: 229.
##
## seq(core_expr) -> core_expr . seq(core_expr) [ With VBAR Type Then TIMES SLASH SEMI RPAR RBRACKET RBRACE PLUS Or NE Mod MINUS Let LT LE In GT GE End Else EQ EOF CONS COMMA COLON CAT BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## core_expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: True True WILD
##
## Ends in an error in state: 227.
##
## nseq(core_expr) -> core_expr . seq(core_expr) [ With VBAR Type Then TIMES SLASH SEMI RPAR RBRACKET RBRACE PLUS Or NE Mod MINUS Let LT LE In GT GE End Else EQ EOF CONS COMMA COLON CAT BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## core_expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: True VBAR
##
## Ends in an error in state: 250.
##
## base_expr(expr) -> disj_expr_level . [ With Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
## bin_op(disj_expr_level,BOOL_OR,conj_expr_level) -> disj_expr_level . BOOL_OR conj_expr_level [ With Type Then SEMI RPAR RBRACKET RBRACE Or Let In End EOF COMMA COLON BOOL_OR Attr ]
## bin_op(disj_expr_level,Or,conj_expr_level) -> disj_expr_level . Or conj_expr_level [ With Type Then SEMI RPAR RBRACKET RBRACE Or Let In End EOF COMMA COLON BOOL_OR Attr ]
## tuple(disj_expr_level) -> disj_expr_level . COMMA nsepseq(disj_expr_level,COMMA) [ With Type Then SEMI RPAR RBRACKET RBRACE Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## disj_expr_level
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 225, spurious reduction of production call_expr_level -> core_expr 
## In state 232, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 214, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 222, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 262, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 252, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 284, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 291, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 298, spurious reduction of production disj_expr_level -> conj_expr_level 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: True WILD
##
## Ends in an error in state: 225.
##
## call_expr -> core_expr . nseq(core_expr) [ With VBAR Type Then TIMES SLASH SEMI RPAR RBRACKET RBRACE PLUS Or NE Mod MINUS Let LT LE In GT GE End Else EQ EOF CONS COMMA COLON CAT BOOL_OR BOOL_AND Attr ]
## call_expr_level -> core_expr . [ With VBAR Type Then TIMES SLASH SEMI RPAR RBRACKET RBRACE PLUS Or NE Mod MINUS Let LT LE In GT GE End Else EQ EOF CONS COMMA COLON CAT BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## core_expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: True With
##
## Ends in an error in state: 527.
##
## interactive_expr -> expr . EOF [ # ]
##
## The known suffix of the stack is as follows:
## expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 225, spurious reduction of production call_expr_level -> core_expr 
## In state 232, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 214, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 222, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 262, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 252, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 284, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 291, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 298, spurious reduction of production disj_expr_level -> conj_expr_level 
## In state 250, spurious reduction of production base_expr(expr) -> disj_expr_level 
## In state 304, spurious reduction of production base_cond__open(expr) -> base_expr(expr) 
## In state 305, spurious reduction of production expr -> base_cond__open(expr) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: With
##
## Ends in an error in state: 525.
##
## interactive_expr' -> . interactive_expr [ # ]
##
## The known suffix of the stack is as follows:
##
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let Ident WILD COLON Ident VBAR
##
## Ends in an error in state: 157.
##
## let_binding -> Ident nseq(sub_irrefutable) option(type_annotation) . EQ expr [ Type Let In EOF Attr ]
##
## The known suffix of the stack is as follows:
## Ident nseq(sub_irrefutable) option(type_annotation)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 27, spurious reduction of production cartesian -> core_type 
## In state 35, spurious reduction of production fun_type -> cartesian 
## In state 26, spurious reduction of production type_expr -> fun_type 
## In state 155, spurious reduction of production type_annotation -> COLON type_expr 
## In state 156, spurious reduction of production option(type_annotation) -> type_annotation 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let Ident WILD EQ With
##
## Ends in an error in state: 158.
##
## let_binding -> Ident nseq(sub_irrefutable) option(type_annotation) EQ . expr [ Type Let In EOF Attr ]
##
## The known suffix of the stack is as follows:
## Ident nseq(sub_irrefutable) option(type_annotation) EQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let Ident WILD WILD With
##
## Ends in an error in state: 150.
##
## seq(sub_irrefutable) -> sub_irrefutable . seq(sub_irrefutable) [ EQ COLON ]
##
## The known suffix of the stack is as follows:
## sub_irrefutable
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let Ident WILD With
##
## Ends in an error in state: 149.
##
## nseq(sub_irrefutable) -> sub_irrefutable . seq(sub_irrefutable) [ EQ COLON ]
##
## The known suffix of the stack is as follows:
## sub_irrefutable
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let Ident With
##
## Ends in an error in state: 148.
##
## let_binding -> Ident . nseq(sub_irrefutable) option(type_annotation) EQ expr [ Type Let In EOF Attr ]
## sub_irrefutable -> Ident . [ EQ COMMA COLON ]
##
## The known suffix of the stack is as follows:
## Ident
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let LBRACE Ident EQ Bytes SEMI Ident EQ Bytes SEMI With
##
## Ends in an error in state: 126.
##
## nsepseq(field_pattern,SEMI) -> field_pattern SEMI . nsepseq(field_pattern,SEMI) [ RBRACE ]
## seq(__anonymous_0(field_pattern,SEMI)) -> field_pattern SEMI . seq(__anonymous_0(field_pattern,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_pattern SEMI
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let LBRACE Ident EQ Bytes SEMI Ident EQ Bytes With
##
## Ends in an error in state: 125.
##
## nsepseq(field_pattern,SEMI) -> field_pattern . [ RBRACE ]
## nsepseq(field_pattern,SEMI) -> field_pattern . SEMI nsepseq(field_pattern,SEMI) [ RBRACE ]
## seq(__anonymous_0(field_pattern,SEMI)) -> field_pattern . SEMI seq(__anonymous_0(field_pattern,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_pattern
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let LBRACE Ident EQ Bytes SEMI With
##
## Ends in an error in state: 122.
##
## nsepseq(field_pattern,SEMI) -> field_pattern SEMI . nsepseq(field_pattern,SEMI) [ RBRACE ]
## nseq(__anonymous_0(field_pattern,SEMI)) -> field_pattern SEMI . seq(__anonymous_0(field_pattern,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_pattern SEMI
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let LBRACE Ident EQ Bytes With
##
## Ends in an error in state: 121.
##
## nsepseq(field_pattern,SEMI) -> field_pattern . [ RBRACE ]
## nsepseq(field_pattern,SEMI) -> field_pattern . SEMI nsepseq(field_pattern,SEMI) [ RBRACE ]
## nseq(__anonymous_0(field_pattern,SEMI)) -> field_pattern . SEMI seq(__anonymous_0(field_pattern,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_pattern
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let LBRACE Ident EQ With
##
## Ends in an error in state: 68.
##
## field_pattern -> Ident EQ . sub_pattern [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## Ident EQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let LBRACE Ident With
##
## Ends in an error in state: 67.
##
## field_pattern -> Ident . EQ sub_pattern [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## Ident
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let LBRACE With
##
## Ends in an error in state: 66.
##
## record_pattern -> LBRACE . sep_or_term_list(field_pattern,SEMI) RBRACE [ WILD SEMI RPAR RBRACKET RBRACE LPAR LBRACE Ident EQ Constr CONS COMMA COLON ARROW ]
##
## The known suffix of the stack is as follows:
## LBRACE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let LPAR Constr C_Some With
##
## Ends in an error in state: 79.
##
## constr_pattern -> C_Some . sub_pattern [ SEMI RPAR RBRACKET RBRACE CONS COMMA ARROW ]
##
## The known suffix of the stack is as follows:
## C_Some
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let LPAR Constr Constr With
##
## Ends in an error in state: 78.
##
## constr_pattern -> Constr . [ SEMI RPAR RBRACKET RBRACE CONS COMMA ARROW ]
## constr_pattern -> Constr . sub_pattern [ SEMI RPAR RBRACKET RBRACE CONS COMMA ARROW ]
##
## The known suffix of the stack is as follows:
## Constr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let LPAR Constr LBRACKET WILD RPAR
##
## Ends in an error in state: 91.
##
## nsepseq(tail,SEMI) -> tail . [ RBRACKET ]
## nsepseq(tail,SEMI) -> tail . SEMI nsepseq(tail,SEMI) [ RBRACKET ]
## nseq(__anonymous_0(tail,SEMI)) -> tail . SEMI seq(__anonymous_0(tail,SEMI)) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## tail
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 95, spurious reduction of production tail -> sub_pattern 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let LPAR Constr LBRACKET WILD SEMI WILD RPAR
##
## Ends in an error in state: 93.
##
## nsepseq(tail,SEMI) -> tail . [ RBRACKET ]
## nsepseq(tail,SEMI) -> tail . SEMI nsepseq(tail,SEMI) [ RBRACKET ]
## seq(__anonymous_0(tail,SEMI)) -> tail . SEMI seq(__anonymous_0(tail,SEMI)) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## tail
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 95, spurious reduction of production tail -> sub_pattern 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let LPAR Constr LBRACKET WILD SEMI WILD SEMI With
##
## Ends in an error in state: 94.
##
## nsepseq(tail,SEMI) -> tail SEMI . nsepseq(tail,SEMI) [ RBRACKET ]
## seq(__anonymous_0(tail,SEMI)) -> tail SEMI . seq(__anonymous_0(tail,SEMI)) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## tail SEMI
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let LPAR Constr LBRACKET WILD SEMI With
##
## Ends in an error in state: 92.
##
## nsepseq(tail,SEMI) -> tail SEMI . nsepseq(tail,SEMI) [ RBRACKET ]
## nseq(__anonymous_0(tail,SEMI)) -> tail SEMI . seq(__anonymous_0(tail,SEMI)) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## tail SEMI
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let LPAR Constr LBRACKET With
##
## Ends in an error in state: 74.
##
## list__(tail) -> LBRACKET . option(sep_or_term_list(tail,SEMI)) RBRACKET [ SEMI RPAR RBRACKET RBRACE CONS COMMA ARROW ]
##
## The known suffix of the stack is as follows:
## LBRACKET
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let LPAR Constr LPAR WILD COMMA WILD COMMA With
##
## Ends in an error in state: 111.
##
## nsepseq(tail,COMMA) -> tail COMMA . nsepseq(tail,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## tail COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let LPAR Constr LPAR WILD COMMA WILD SEMI
##
## Ends in an error in state: 110.
##
## nsepseq(tail,COMMA) -> tail . [ RPAR ]
## nsepseq(tail,COMMA) -> tail . COMMA nsepseq(tail,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## tail
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 95, spurious reduction of production tail -> sub_pattern 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let LPAR Constr LPAR WILD COMMA With
##
## Ends in an error in state: 109.
##
## tuple(tail) -> tail COMMA . nsepseq(tail,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## tail COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let LPAR Constr LPAR WILD CONS With
##
## Ends in an error in state: 96.
##
## tail -> sub_pattern CONS . tail [ SEMI RPAR RBRACKET COMMA ARROW ]
##
## The known suffix of the stack is as follows:
## sub_pattern CONS
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let LPAR Constr LPAR WILD SEMI
##
## Ends in an error in state: 107.
##
## par(tail) -> LPAR tail . RPAR [ SEMI RPAR RBRACKET RBRACE CONS COMMA ARROW ]
## tuple(tail) -> tail . COMMA nsepseq(tail,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## LPAR tail
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 95, spurious reduction of production tail -> sub_pattern 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let LPAR Constr LPAR WILD With
##
## Ends in an error in state: 95.
##
## tail -> sub_pattern . [ SEMI RPAR RBRACKET COMMA ARROW ]
## tail -> sub_pattern . CONS tail [ SEMI RPAR RBRACKET COMMA ARROW ]
##
## The known suffix of the stack is as follows:
## sub_pattern
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let LPAR Constr LPAR With
##
## Ends in an error in state: 73.
##
## par(ptuple) -> LPAR . ptuple RPAR [ SEMI RPAR RBRACKET RBRACE CONS COMMA ARROW ]
## par(tail) -> LPAR . tail RPAR [ SEMI RPAR RBRACKET RBRACE CONS COMMA ARROW ]
## unit -> LPAR . RPAR [ SEMI RPAR RBRACKET RBRACE CONS COMMA ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let LPAR Constr WILD With
##
## Ends in an error in state: 146.
##
## par(closed_irrefutable) -> LPAR closed_irrefutable . RPAR [ WILD RPAR LPAR LBRACE Ident EQ Constr COMMA COLON ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR closed_irrefutable
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let LPAR Constr With
##
## Ends in an error in state: 129.
##
## closed_irrefutable -> Constr . sub_pattern [ RPAR ]
## sub_irrefutable -> Constr . [ RPAR COMMA COLON ]
##
## The known suffix of the stack is as follows:
## Constr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let LPAR WILD COLON With
##
## Ends in an error in state: 144.
##
## typed_pattern -> irrefutable COLON . type_expr [ RPAR ]
##
## The known suffix of the stack is as follows:
## irrefutable COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let LPAR WILD WILD
##
## Ends in an error in state: 143.
##
## closed_irrefutable -> irrefutable . [ RPAR ]
## typed_pattern -> irrefutable . COLON type_expr [ RPAR ]
##
## The known suffix of the stack is as follows:
## irrefutable
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 134, spurious reduction of production irrefutable -> sub_irrefutable 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let LPAR With
##
## Ends in an error in state: 64.
##
## par(closed_irrefutable) -> LPAR . closed_irrefutable RPAR [ WILD RPAR LPAR LBRACE Ident EQ Constr COMMA COLON ARROW ]
## unit -> LPAR . RPAR [ WILD RPAR LPAR LBRACE Ident EQ Constr COMMA COLON ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let Rec WILD EQ Bytes With
##
## Ends in an error in state: 514.
##
## let_declaration -> Let Rec let_binding . seq(Attr) [ Type Let EOF ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 225, spurious reduction of production call_expr_level -> core_expr 
## In state 232, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 214, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 222, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 262, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 252, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 284, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 291, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 298, spurious reduction of production disj_expr_level -> conj_expr_level 
## In state 250, spurious reduction of production base_expr(expr) -> disj_expr_level 
## In state 304, spurious reduction of production base_cond__open(expr) -> base_expr(expr) 
## In state 305, spurious reduction of production expr -> base_cond__open(expr) 
## In state 388, spurious reduction of production let_binding -> irrefutable option(type_annotation) EQ expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let Rec With
##
## Ends in an error in state: 63.
##
## let_declaration -> Let Rec . let_binding seq(Attr) [ Type Let EOF ]
##
## The known suffix of the stack is as follows:
## Let Rec
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let WILD COLON Ident VBAR
##
## Ends in an error in state: 386.
##
## let_binding -> irrefutable option(type_annotation) . EQ expr [ Type Let In EOF Attr ]
##
## The known suffix of the stack is as follows:
## irrefutable option(type_annotation)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 27, spurious reduction of production cartesian -> core_type 
## In state 35, spurious reduction of production fun_type -> cartesian 
## In state 26, spurious reduction of production type_expr -> fun_type 
## In state 155, spurious reduction of production type_annotation -> COLON type_expr 
## In state 156, spurious reduction of production option(type_annotation) -> type_annotation 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let WILD COLON With
##
## Ends in an error in state: 154.
##
## type_annotation -> COLON . type_expr [ EQ ]
##
## The known suffix of the stack is as follows:
## COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let WILD COMMA WILD COMMA With
##
## Ends in an error in state: 138.
##
## nsepseq(sub_irrefutable,COMMA) -> sub_irrefutable COMMA . nsepseq(sub_irrefutable,COMMA) [ WILD RPAR LPAR LBRACE Ident EQ Constr COLON ARROW ]
##
## The known suffix of the stack is as follows:
## sub_irrefutable COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let WILD COMMA WILD With
##
## Ends in an error in state: 137.
##
## nsepseq(sub_irrefutable,COMMA) -> sub_irrefutable . [ WILD RPAR LPAR LBRACE Ident EQ Constr COLON ARROW ]
## nsepseq(sub_irrefutable,COMMA) -> sub_irrefutable . COMMA nsepseq(sub_irrefutable,COMMA) [ WILD RPAR LPAR LBRACE Ident EQ Constr COLON ARROW ]
##
## The known suffix of the stack is as follows:
## sub_irrefutable
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let WILD COMMA With
##
## Ends in an error in state: 135.
##
## tuple(sub_irrefutable) -> sub_irrefutable COMMA . nsepseq(sub_irrefutable,COMMA) [ WILD RPAR LPAR LBRACE Ident EQ Constr COLON ARROW ]
##
## The known suffix of the stack is as follows:
## sub_irrefutable COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let WILD EQ Bytes Attr With
##
## Ends in an error in state: 171.
##
## seq(Attr) -> Attr . seq(Attr) [ Type Let In EOF ]
##
## The known suffix of the stack is as follows:
## Attr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let WILD EQ Bytes With
##
## Ends in an error in state: 516.
##
## let_declaration -> Let let_binding . seq(Attr) [ Type Let EOF ]
##
## The known suffix of the stack is as follows:
## Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 225, spurious reduction of production call_expr_level -> core_expr 
## In state 232, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 214, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 222, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 262, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 252, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 284, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 291, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 298, spurious reduction of production disj_expr_level -> conj_expr_level 
## In state 250, spurious reduction of production base_expr(expr) -> disj_expr_level 
## In state 304, spurious reduction of production base_cond__open(expr) -> base_expr(expr) 
## In state 305, spurious reduction of production expr -> base_cond__open(expr) 
## In state 388, spurious reduction of production let_binding -> irrefutable option(type_annotation) EQ expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let WILD EQ With
##
## Ends in an error in state: 387.
##
## let_binding -> irrefutable option(type_annotation) EQ . expr [ Type Let In EOF Attr ]
##
## The known suffix of the stack is as follows:
## irrefutable option(type_annotation) EQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let WILD WILD
##
## Ends in an error in state: 385.
##
## let_binding -> irrefutable . option(type_annotation) EQ expr [ Type Let In EOF Attr ]
##
## The known suffix of the stack is as follows:
## irrefutable
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 134, spurious reduction of production irrefutable -> sub_irrefutable 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let WILD With
##
## Ends in an error in state: 134.
##
## irrefutable -> sub_irrefutable . [ WILD RPAR LPAR LBRACE Ident EQ Constr COLON ARROW ]
## tuple(sub_irrefutable) -> sub_irrefutable . COMMA nsepseq(sub_irrefutable,COMMA) [ WILD RPAR LPAR LBRACE Ident EQ Constr COLON ARROW ]
##
## The known suffix of the stack is as follows:
## sub_irrefutable
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let With
##
## Ends in an error in state: 61.
##
## let_declaration -> Let . let_binding seq(Attr) [ Type Let EOF ]
## let_declaration -> Let . Rec let_binding seq(Attr) [ Type Let EOF ]
##
## The known suffix of the stack is as follows:
## Let
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Type Ident EQ Constr DOT With
##
## Ends in an error in state: 13.
##
## core_type -> Constr DOT . Ident [ VBAR Type TIMES SEMI RPAR RBRACE Let Ident EQ EOF COMMA ARROW ]
##
## The known suffix of the stack is as follows:
## Constr DOT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Type Ident EQ Constr Of With
##
## Ends in an error in state: 6.
##
## variant -> Constr Of . fun_type [ VBAR Type SEMI RPAR RBRACE Let EQ EOF COMMA ]
##
## The known suffix of the stack is as follows:
## Constr Of
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Type Ident EQ Constr VBAR With
##
## Ends in an error in state: 16.
##
## nsepseq(variant,VBAR) -> variant VBAR . nsepseq(variant,VBAR) [ Type SEMI RPAR RBRACE Let EQ EOF COMMA ]
##
## The known suffix of the stack is as follows:
## variant VBAR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Type Ident EQ Constr With
##
## Ends in an error in state: 12.
##
## core_type -> Constr . DOT Ident [ Type TIMES SEMI RPAR RBRACE Let Ident EQ EOF COMMA ARROW ]
## variant -> Constr . [ VBAR Type SEMI RPAR RBRACE Let EQ EOF COMMA ]
## variant -> Constr . Of fun_type [ VBAR Type SEMI RPAR RBRACE Let EQ EOF COMMA ]
##
## The known suffix of the stack is as follows:
## Constr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Type Ident EQ Ident ARROW With
##
## Ends in an error in state: 36.
##
## fun_type -> cartesian ARROW . fun_type [ VBAR Type SEMI RPAR RBRACE Let EQ EOF COMMA ]
##
## The known suffix of the stack is as follows:
## cartesian ARROW
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Type Ident EQ Ident TIMES Constr With
##
## Ends in an error in state: 29.
##
## core_type -> Constr . DOT Ident [ VBAR Type TIMES SEMI RPAR RBRACE Let Ident EQ EOF COMMA ARROW ]
##
## The known suffix of the stack is as follows:
## Constr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Type Ident EQ Ident TIMES Ident TIMES With
##
## Ends in an error in state: 32.
##
## nsepseq(core_type,TIMES) -> core_type TIMES . nsepseq(core_type,TIMES) [ VBAR Type SEMI RPAR RBRACE Let EQ EOF COMMA ARROW ]
##
## The known suffix of the stack is as follows:
## core_type TIMES
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Type Ident EQ Ident TIMES Ident With
##
## Ends in an error in state: 31.
##
## core_type -> core_type . Ident [ VBAR Type TIMES SEMI RPAR RBRACE Let Ident EQ EOF COMMA ARROW ]
## nsepseq(core_type,TIMES) -> core_type . [ VBAR Type SEMI RPAR RBRACE Let EQ EOF COMMA ARROW ]
## nsepseq(core_type,TIMES) -> core_type . TIMES nsepseq(core_type,TIMES) [ VBAR Type SEMI RPAR RBRACE Let EQ EOF COMMA ARROW ]
##
## The known suffix of the stack is as follows:
## core_type
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Type Ident EQ Ident TIMES With
##
## Ends in an error in state: 28.
##
## cartesian -> core_type TIMES . nsepseq(core_type,TIMES) [ VBAR Type SEMI RPAR RBRACE Let EQ EOF COMMA ARROW ]
##
## The known suffix of the stack is as follows:
## core_type TIMES
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Type Ident EQ Ident VBAR
##
## Ends in an error in state: 522.
##
## declarations -> declaration . [ EOF ]
## declarations -> declaration . declarations [ EOF ]
##
## The known suffix of the stack is as follows:
## declaration
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 27, spurious reduction of production cartesian -> core_type 
## In state 35, spurious reduction of production fun_type -> cartesian 
## In state 26, spurious reduction of production type_expr -> fun_type 
## In state 60, spurious reduction of production type_decl -> Type Ident EQ type_expr 
## In state 518, spurious reduction of production declaration -> type_decl 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Type Ident EQ Ident With
##
## Ends in an error in state: 27.
##
## cartesian -> core_type . [ VBAR Type SEMI RPAR RBRACE Let EQ EOF COMMA ARROW ]
## cartesian -> core_type . TIMES nsepseq(core_type,TIMES) [ VBAR Type SEMI RPAR RBRACE Let EQ EOF COMMA ARROW ]
## core_type -> core_type . Ident [ VBAR Type TIMES SEMI RPAR RBRACE Let Ident EQ EOF COMMA ARROW ]
##
## The known suffix of the stack is as follows:
## core_type
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Type Ident EQ LBRACE Ident COLON Constr SEMI Ident COLON Constr SEMI With
##
## Ends in an error in state: 47.
##
## nsepseq(field_decl,SEMI) -> field_decl SEMI . nsepseq(field_decl,SEMI) [ RBRACE ]
## seq(__anonymous_0(field_decl,SEMI)) -> field_decl SEMI . seq(__anonymous_0(field_decl,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_decl SEMI
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Type Ident EQ LBRACE Ident COLON Constr SEMI Ident COLON Ident VBAR
##
## Ends in an error in state: 46.
##
## nsepseq(field_decl,SEMI) -> field_decl . [ RBRACE ]
## nsepseq(field_decl,SEMI) -> field_decl . SEMI nsepseq(field_decl,SEMI) [ RBRACE ]
## seq(__anonymous_0(field_decl,SEMI)) -> field_decl . SEMI seq(__anonymous_0(field_decl,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_decl
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 27, spurious reduction of production cartesian -> core_type 
## In state 35, spurious reduction of production fun_type -> cartesian 
## In state 26, spurious reduction of production type_expr -> fun_type 
## In state 20, spurious reduction of production field_decl -> Ident COLON type_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Type Ident EQ LBRACE Ident COLON Constr SEMI With
##
## Ends in an error in state: 43.
##
## nsepseq(field_decl,SEMI) -> field_decl SEMI . nsepseq(field_decl,SEMI) [ RBRACE ]
## nseq(__anonymous_0(field_decl,SEMI)) -> field_decl SEMI . seq(__anonymous_0(field_decl,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_decl SEMI
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Type Ident EQ LBRACE Ident COLON Ident VBAR
##
## Ends in an error in state: 42.
##
## nsepseq(field_decl,SEMI) -> field_decl . [ RBRACE ]
## nsepseq(field_decl,SEMI) -> field_decl . SEMI nsepseq(field_decl,SEMI) [ RBRACE ]
## nseq(__anonymous_0(field_decl,SEMI)) -> field_decl . SEMI seq(__anonymous_0(field_decl,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_decl
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 27, spurious reduction of production cartesian -> core_type 
## In state 35, spurious reduction of production fun_type -> cartesian 
## In state 26, spurious reduction of production type_expr -> fun_type 
## In state 20, spurious reduction of production field_decl -> Ident COLON type_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Type Ident EQ LBRACE Ident COLON With
##
## Ends in an error in state: 10.
##
## field_decl -> Ident COLON . type_expr [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## Ident COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Type Ident EQ LBRACE Ident With
##
## Ends in an error in state: 9.
##
## field_decl -> Ident . COLON type_expr [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## Ident
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Type Ident EQ LBRACE With
##
## Ends in an error in state: 8.
##
## record_type -> LBRACE . sep_or_term_list(field_decl,SEMI) RBRACE [ Type SEMI RPAR RBRACE Let EQ EOF COMMA ]
##
## The known suffix of the stack is as follows:
## LBRACE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Type Ident EQ LPAR Ident COMMA Constr RPAR With
##
## Ends in an error in state: 18.
##
## core_type -> type_tuple . Ident [ VBAR Type TIMES SEMI RPAR RBRACE Let Ident EQ EOF COMMA ARROW ]
##
## The known suffix of the stack is as follows:
## type_tuple
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Type Ident EQ LPAR Ident COMMA Ident COMMA With
##
## Ends in an error in state: 53.
##
## nsepseq(type_expr,COMMA) -> type_expr COMMA . nsepseq(type_expr,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## type_expr COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Type Ident EQ LPAR Ident COMMA Ident VBAR
##
## Ends in an error in state: 52.
##
## nsepseq(type_expr,COMMA) -> type_expr . [ RPAR ]
## nsepseq(type_expr,COMMA) -> type_expr . COMMA nsepseq(type_expr,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## type_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 27, spurious reduction of production cartesian -> core_type 
## In state 35, spurious reduction of production fun_type -> cartesian 
## In state 26, spurious reduction of production type_expr -> fun_type 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Type Ident EQ LPAR Ident COMMA With
##
## Ends in an error in state: 51.
##
## tuple(type_expr) -> type_expr COMMA . nsepseq(type_expr,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## type_expr COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Type Ident EQ LPAR Ident VBAR
##
## Ends in an error in state: 49.
##
## par(type_expr) -> LPAR type_expr . RPAR [ VBAR Type TIMES SEMI RPAR RBRACE Let Ident EQ EOF COMMA ARROW ]
## tuple(type_expr) -> type_expr . COMMA nsepseq(type_expr,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## LPAR type_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 27, spurious reduction of production cartesian -> core_type 
## In state 35, spurious reduction of production fun_type -> cartesian 
## In state 26, spurious reduction of production type_expr -> fun_type 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Type Ident EQ LPAR With
##
## Ends in an error in state: 7.
##
## par(tuple(type_expr)) -> LPAR . tuple(type_expr) RPAR [ Ident ]
## par(type_expr) -> LPAR . type_expr RPAR [ VBAR Type TIMES SEMI RPAR RBRACE Let Ident EQ EOF COMMA ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Type Ident EQ VBAR Constr With
##
## Ends in an error in state: 5.
##
## variant -> Constr . [ VBAR Type SEMI RPAR RBRACE Let EQ EOF COMMA ]
## variant -> Constr . Of fun_type [ VBAR Type SEMI RPAR RBRACE Let EQ EOF COMMA ]
##
## The known suffix of the stack is as follows:
## Constr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Type Ident EQ VBAR With
##
## Ends in an error in state: 4.
##
## sum_type -> VBAR . nsepseq(variant,VBAR) [ Type SEMI RPAR RBRACE Let EQ EOF COMMA ]
##
## The known suffix of the stack is as follows:
## VBAR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Type Ident EQ With
##
## Ends in an error in state: 3.
##
## type_decl -> Type Ident EQ . type_expr [ Type Let EOF ]
##
## The known suffix of the stack is as follows:
## Type Ident EQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Type Ident With
##
## Ends in an error in state: 2.
##
## type_decl -> Type Ident . EQ type_expr [ Type Let EOF ]
##
## The known suffix of the stack is as follows:
## Type Ident
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Type With
##
## Ends in an error in state: 1.
##
## type_decl -> Type . Ident EQ type_expr [ Type Let EOF ]
##
## The known suffix of the stack is as follows:
## Type
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: With
##
## Ends in an error in state: 0.
##
## contract' -> . contract [ # ]
##
## The known suffix of the stack is as follows:
##
##

<YOUR SYNTAX ERROR MESSAGE HERE>

