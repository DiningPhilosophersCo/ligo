(* Generated by: ocaml-crunch 
  Creation date: Tue, 17 May 2022 11:11:14 GMT *)

module Internal = struct
let d_05823b0eacca75f2c915c180f4394332 = "module Test = struct\n  [@private] let failwith (type a) (v : a) : a external_failwith = [%external \"FAILWITH\"] v\n  type ('a, 'b) typed_address = unit\n  type michelson_program = unit\n  type test_exec_result = unit\n  type mutation = unit\n  let to_contract (type p s) (_t : (p, s) typed_address) : p contract = failwith \"TEST MODE\"\n  let originate_from_file ((_fn, _e, _v, _s, _t) : string * string * string list * michelson_program * tez) : address * michelson_program * int = failwith \"TEST MODE\"\n  let originate (type p s) ((_f, _s, _t) : (p * s -> operation list * s) * s * tez) : ((p, s) typed_address * michelson_program * int) = failwith \"TEST MODE\"\n  let set_source (_a : address) : unit = failwith \"TEST MODE\"\n  let set_baker (_a : address) : unit = failwith \"TEST MODE\"\n  let transfer ((_a, _s, _t) : address * michelson_program * tez) : test_exec_result = failwith \"TEST MODE\"\n  let transfer_exn ((_a, _s, _t) : address * michelson_program * tez) : nat = failwith \"TEST MODE\"\n  let transfer_to_contract (type p) ((_a, _s, _t) : p contract * p * tez) : test_exec_result = failwith \"TEST MODE\"\n  let transfer_to_contract_exn (type p) ((_a, _s, _t) : p contract * p * tez) : nat = failwith \"TEST MODE\"\n  let get_storage (type a b) (_t : (a, b) typed_address) : b = failwith \"TEST MODE\"\n  let get_storage_of_address (_a : address) : michelson_program = failwith \"TEST MODE\"\n  let get_balance (_a : address) : tez = failwith \"TEST MODE\"\n  let michelson_equal ((_m1, _m2) : michelson_program * michelson_program) : bool = failwith \"TEST MODE\"\n  let log (type a) (_v : a) : unit = failwith \"TEST MODE\"\n  let reset_state ((_n, _l) : nat * tez list) : unit = failwith \"TEST MODE\"\n  let get_voting_power (_kh : key_hash) : nat = failwith \"TEST MODE\"\n  [@thunk] let get_total_voting_power : nat = failwith \"TEST MODE\"\n  let bootstrap_contract (type p s) ((_f, _s, _t) : (p * s -> operation list * s) * s * tez) : unit = failwith \"TEST MODE\"\n  let nth_bootstrap_contract (_i : nat) : address = failwith \"TEST MODE\"\n  let nth_bootstrap_account (_i : int) : address = failwith \"TEST MODE\"\n  let nth_bootstrap_typed_address (type a b) (_n : nat) : (a, b) typed_address = failwith \"TEST MODE\"\n  let last_originations (_u : unit) : (address, address list) map = failwith \"TEST MODE\"\n  let compile_value (type a) (_v : a) : michelson_program = failwith \"TEST MODE\"\n  let mutate_value (type a) ((_n, _v) : nat * a) : (a * mutation) option = failwith \"TEST MODE\"\n  let save_mutation ((_s, _m) : string * mutation) : string option = failwith \"TEST MODE\"\n  let mutation_test (type a b) ((_v, _f) : a * (a -> b)) : (b * mutation) option = failwith \"TEST MODE\"\n  let mutation_test_all (type a b) ((_v, _f) : a * (a -> b)) : (b * mutation) list = failwith \"TEST MODE\"\n  let run (type a b) ((_f, _v) : (a -> b) * a) : michelson_program = failwith \"TEST MODE\"\n  let eval (type a) (_v : a) : michelson_program = failwith \"TEST MODE\"\n  let decompile (type a) (_m : michelson_program) : a = failwith \"TEST MODE\"\n  let random (type a) (_u : unit) : a option = failwith \"TEST MODE\"\n  let add_account ((_s, _k) : string * key) : unit = failwith \"TEST MODE\"\n  let new_account (_u : unit) : string * key = failwith \"TEST MODE\"\n  let baker_account ((_p, _o) : (string * key) * tez option) : unit = failwith \"TEST MODE\"\n  let bake_until_n_cycle_end (_n : nat) : unit = failwith \"TEST MODE\"\n  let register_delegate (_kh : key_hash) : unit = failwith \"TEST MODE\"\n  let register_constant (_m : michelson_program) : string = failwith \"TEST MODE\"\n  let cast_address (type a b) (_a : address) : (a, b) typed_address = failwith \"TEST MODE\"\n  let to_typed_address (type a b) (_c : a contract) : (a, b) typed_address = failwith \"TEST MODE\"\n  let to_entrypoint (type a b c) ((_s, _t) : string * (a, b) typed_address) : c contract = failwith \"TEST MODE\"\n  let set_big_map (type a b) ((_i, _m) : int * (a, b) big_map) : unit = failwith \"TEST MODE\"\n  let create_chest ((_b, _n) : bytes * nat) : chest * chest_key = failwith \"TEST MODE\"\n  let create_chest_key ((_c, _n) : chest * nat) : chest_key = failwith \"TEST MODE\"\n  let constant_to_m"
let d_1b319111fd5b52a1ff5a524dcabb67b2 = "module Tezos = struct\n  let get_contract (type a) (a : address) : (a contract) = [%external \"CONTRACT\"] a\n  let get_contract_opt (type a) (a : address) : (a contract) option = [%external \"CONTRACT_OPT\"] a\n  let get_contract_with_error (type a) (a : address) (s : string) : a contract = [%external \"CONTRACT_WITH_ERROR\"] a s\n  (* let get_entrypoint_opt (type a) (s : string) (a : address) : (a contract) option = [%external \"CONTRACT_ENTRYPOINT_OPT\"] s a *)\n  [@thunk]\n    let balance : tez = [%Michelson ({| { DROP ; BALANCE } |} : unit -> tez)] ()\n  [@thunk]\n    let amount : tez = [%Michelson ({| { DROP ; AMOUNT } |} : unit -> tez)] ()\n  [@thunk]\n    let now : timestamp = [%Michelson ({| { DROP ; NOW } |} : unit -> timestamp)] ()\n  [@thunk]\n    let sender : address = [%Michelson ({| { DROP ; SENDER } |} : unit -> address)] ()\n  [@thunk]\n    let source : address = [%Michelson ({| { DROP ; SOURCE } |} : unit -> address)] ()\n  [@thunk]\n    let level : nat = [%Michelson ({| { DROP ; LEVEL } |} : unit -> nat)] ()\n  [@thunk]\n    let self_address : address = [%external \"SELF_ADDRESS\"]\n  [@thunk]\n    let chain_id : chain_id = [%Michelson ({| { DROP ; CHAIN_ID } |} : unit -> chain_id)] ()\n  [@thunk]\n    let total_voting_power : nat = [%Michelson ({| { DROP ; TOTAL_VOTING_POWER } |} : unit -> nat)] ()\n  (* [@thunk] let self (type a) (s : string) : a contract = [%external \"SELF\"] s *)\n  let voting_power (kh : key_hash) : nat = [%Michelson ({| { VOTING_POWER } |} : key_hash -> nat)] kh\n  let address (type a) (c : a contract) : address = [%external \"ADDRESS\"] c\n  let implicit_account (kh : key_hash) : unit contract = [%external \"IMPLICIT_ACCOUNT\"] kh\n  let create_ticket (type a) (v : a) (n : nat) : a ticket = [%Michelson ({| { UNPAIR ; TICKET } |} : a * nat -> a ticket)] (v, n)\n  let join_tickets (type a) (t : a ticket * a ticket) : (a ticket) option = [%Michelson ({| { JOIN_TICKETS } |} : a ticket * a ticket -> a ticket option)] t\n  let split_ticket (type a) (t : a ticket) (p : nat * nat) : (a ticket * a ticket) option =\n    [%Michelson ({| { UNPAIR ; SPLIT_TICKET } |} : a ticket * (nat * nat) -> (a ticket * a ticket) option)] (t, p)\n  let read_ticket (type a) (t : a ticket) : (address * (a * nat)) * a ticket =\n    [%Michelson ({| { READ_TICKET ; PAIR } |} : a ticket -> (address * (a * nat)) * a ticket)] t\n  (* let create_contract (type a b) (c : a * b -> operation list * b) (kh : key_hash) (mu : tez) (s : b) : operation * address = [%external \"CREATE_CONTRACT\"] c kh mu s *)\n  let never (type a) (n : never) : a = [%Michelson ({| { NEVER } |} : never -> a)] n\n  let pairing_check (l : (bls12_381_g1 * bls12_381_g2) list) : bool = [%Michelson ({| { PAIRING_CHECK } |} : (bls12_381_g1 * bls12_381_g2) list -> bool)] l\n  let open_chest (ck : chest_key) (c : chest) (n : nat) : chest_opening_result = [%external \"OPEN_CHEST\"] ck c n\n  let call_view (type a b) (s : string) (x : a) (a : address)  : b option = [%external \"VIEW\"] s x a\n  let constant (type a) (s : string) : a = [%external \"GLOBAL_CONSTANT\"] s\n  let transaction (type a) (a : a) (mu : tez) (c : a contract) : operation = [%external \"CALL\"] a mu c\n  let set_delegate (o : key_hash option) : operation = [%external \"SET_DELEGATE\"] o\nend\n\nmodule Bitwise = struct\n  (* let and (type a b) (l : a) (r : b) : (a, b) external_and = [%external \"AND\"] l r *)\n  let xor (l : nat) (r : nat) : nat = [%external \"XOR\"] l r\n  (* let or (l : nat) (r : nat) : nat = [%external \"OR\"] l r *)\n  let shift_left (l : nat) (r : nat) : nat = [%external \"LSL\"] l r\n  let shift_right (l : nat) (r : nat) : nat = [%external \"LSR\"] l r\nend\n\nmodule Big_map = struct\n  let empty (type k v) : (k, v) big_map = [%external \"BIG_MAP_EMPTY\"]\n  let mem (type k v) (k : k) (m : (k, v) big_map) : bool = [%Michelson ({| { UNPAIR ; MEM } |} : k * (k, v) big_map -> bool)] (k, m)\n  let add (type k v) (k : k) (v : v) (m : (k, v) big_map) : (k, v) big_map = [%external \"MAP_ADD\"] k v m\n  let remove (type k v) (k : k) (m : (k, v) big_map) : (k, v) big_map = [%external \"MAP_REMOVE\"] k m\n  let update (type k v) (k : k) (v : v option) (m : (k, v) bi"
let d_1ed171f3cf60d47cd2cc53196bdb6bcc = "ichelson_program (_s : string) : michelson_program = failwith \"TEST MODE\"\n  let restore_context (_u : unit) : unit = failwith \"TEST_POP_CONTEXT\"\n  let save_context (_u : unit) : unit = failwith \"TEST_PUSH_CONTEXT\"\nend"
let d_5eb13cdf86c3cfead85a9d7c868dcf74 = "type test_exec_error_balance_too_low =\n  { contract_too_low : address ; contract_balance : tez ; spend_request : tez }\n\ntype test_exec_error =\n  | Rejected of michelson_program * address\n  | Balance_too_low of test_exec_error_balance_too_low\n  | Other of string\n\ntype test_exec_result = Success of nat | Fail of test_exec_error\n\nmodule Test = struct\n  let to_contract (type p s) (t : (p, s) typed_address) : p contract = [%external \"TEST_TO_CONTRACT\"] t\n  let originate_from_file (fn : string) (e : string) (v : string list) (s : michelson_program)  (t : tez) : address * michelson_program * int = [%external \"TEST_ORIGINATE_FROM_FILE\"] fn e v s t\n  let originate (type p s) (f : p * s -> operation list * s) (s : s) (t : tez) : ((p, s) typed_address * michelson_program * int) = [%external \"TEST_ORIGINATE\"] f s t\n  let set_source (a : address) : unit = [%external \"TEST_SET_SOURCE\"] a\n  let set_baker (a : address) : unit = [%external \"TEST_SET_BAKER\"] a\n  let transfer (a : address) (s : michelson_program) (t : tez) : test_exec_result = [%external \"TEST_EXTERNAL_CALL_TO_ADDRESS\"] a s t\n  let transfer_exn (a : address) (s : michelson_program) (t : tez) : nat = [%external \"TEST_EXTERNAL_CALL_TO_ADDRESS_EXN\"] a s t\n  let transfer_to_contract (type p) (a : p contract) (s : p) (t : tez) : test_exec_result = [%external \"TEST_EXTERNAL_CALL_TO_CONTRACT\"] a s t\n  let transfer_to_contract_exn (type p) (a : p contract) (s : p) (t : tez) : nat = [%external \"TEST_EXTERNAL_CALL_TO_CONTRACT_EXN\"] a s t\n  let get_storage (type a b) (t : (a, b) typed_address) : b = [%external \"TEST_GET_STORAGE\"] t\n  let get_storage_of_address (a : address) : michelson_program = [%external \"TEST_GET_STORAGE_OF_ADDRESS\"] a\n  let get_balance (a : address) : tez = [%external \"TEST_GET_BALANCE\"] a\n  let michelson_equal (m1 : michelson_program) (m2 : michelson_program) : bool = [%external \"TEST_MICHELSON_EQUAL\"] m1 m2\n  let log (type a) (v : a) : unit = [%external \"TEST_LOG\"] v\n  let reset_state (n : nat) (l : tez list) : unit = [%external \"TEST_STATE_RESET\"] n l\n  let get_voting_power (kh : key_hash) : nat = [%external \"TEST_GET_VOTING_POWER\"] kh\n  [@thunk]\n    let get_total_voting_power : nat = [%external \"TEST_GET_TOTAL_VOTING_POWER\"]\n  let bootstrap_contract (type p s) (f : p * s -> operation list * s) (s : s) (t : tez) : unit = [%external \"TEST_BOOTSTRAP_CONTRACT\"] f s t\n  let nth_bootstrap_contract (i : nat) : address = [%external \"TEST_NTH_BOOTSTRAP_CONTRACT\"] i\n  let nth_bootstrap_account (i : int) : address = [%external \"TEST_GET_NTH_BS\"] i\n  let nth_bootstrap_typed_address (type a b) (n : nat) : (a, b) typed_address = [%external \"TEST_NTH_BOOTSTRAP_TYPED_ADDRESS\"] n\n  let last_originations (u : unit) : (address, address list) map = [%external \"TEST_LAST_ORIGINATIONS\"] u\n  let compile_value (type a) (v : a) : michelson_program = [%external \"TEST_COMPILE_META_VALUE\"] v\n  let mutate_value (type a) (n : nat) (v : a) : (a * mutation) option = [%external \"TEST_MUTATE_VALUE\"] n v\n  let save_mutation (s : string) (m : mutation) : string option = [%external \"TEST_SAVE_MUTATION\"] s m\n  let mutation_test (type a b) (v : a) (f : a -> b) : (b * mutation) option = [%external \"TEST_MUTATION_TEST\"] v f\n  let mutation_test_all (type a b) (v : a) (f : a -> b) : (b * mutation) list = [%external \"TEST_MUTATION_TEST_ALL\"] v f\n  let run (type a b) (f : a -> b) (v : a) : michelson_program = [%external \"TEST_RUN\"] f v\n  let eval (type a) (v : a) : michelson_program = [%external \"TEST_EVAL\"] v\n  let decompile (type a) (m : michelson_program) : a = [%external \"TEST_DECOMPILE\"] m\n  let random (type a) (u : unit) : a = [%external \"TEST_RANDOM\"] u\n  let add_account (s : string) (k : key) : unit = [%external \"TEST_ADD_ACCOUNT\"] s k\n  let new_account (u : unit) : string * key = [%external \"TEST_NEW_ACCOUNT\"] u\n  let baker_account (p : string * key) (o : tez option) : unit = [%external \"TEST_BAKER_ACCOUNT\"] p o\n  let bake_until_n_cycle_end (n : nat) : unit = [%external \"TEST_BAKE_UNTIL_N_CYCLE_END\"] n\n  let register_delegate (kh : key_hash) : unit = [%external \"TEST_REGISTER_DELEGATE\"] kh\n  le"
let d_5efba605c14daea6c0229fd63494d14c = " big_map = [%external \"MAP_REMOVE\"] k m\n  let update (type k v) (k : k) (v : v option) (m : (k, v) big_map) : (k, v) big_map = [%external \"MAP_UPDATE\"] k v m\n  let get_and_update (type k v) (k : k) (v : v option) (m : (k, v) big_map) : v option * (k, v) big_map = [%external \"BIG_MAP_GET_AND_UPDATE\"] k v m\n  let find_opt (type k v) (k : k) (m : (k, v) big_map) : v option = [%external \"MAP_FIND_OPT\"] k m\n  let find (type k v) (k : k) (m : (k, v) big_map) : v = [%external \"MAP_FIND\"] k m\nend\n\nmodule Map = struct\n  let empty (type k v) : (k, v) map = [%external \"MAP_EMPTY\"]\n  let size (type k v) (m : (k, v) map) : nat = [%Michelson ({| { SIZE } |} : (k, v) map -> nat)] m\n  let mem (type k v) (k : k) (m : (k, v) map) : bool = [%Michelson ({| { UNPAIR ; MEM } |} : k * (k, v) map -> bool)] (k, m)\n  let add (type k v) (k : k) (v : v) (m : (k, v) map) : (k, v) map = [%external \"MAP_ADD\"] k v m\n  let remove (type k v) (k : k) (m : (k, v) map) : (k, v) map = [%external \"MAP_REMOVE\"] k m\n  let update (type k v) (k : k) (v : v option) (m : (k, v) map) : (k, v) map = [%external \"MAP_UPDATE\"] k v m\n  let get_and_update (type k v) (k : k) (v : v option) (m : (k, v) map) : v option * (k, v) map = [%external \"MAP_GET_AND_UPDATE\"] k v m\n  let find (type k v) (k : k) (m : (k, v) map) : v = [%external \"MAP_FIND\"] k m\n  let find_opt (type k v) (k : k) (m : (k, v) map) : v option = [%external \"MAP_FIND_OPT\"] k m\n  let iter (type k v) (f : k * v -> unit) (m : (k, v) map) : unit = [%external \"MAP_ITER\"] f m\n  let map (type k v w) (f : k * v -> w) (m : (k, v) map) : (k, w) map = [%external \"MAP_MAP\"] f m\n  let fold (type k v c) (f : c * (k * v) -> c) (m : (k, v) map) (i : c) : c = [%external \"MAP_FOLD\"] f m i\nend\n\nmodule Set = struct\n  let empty (type a) : a set = [%external \"SET_EMPTY\"]\n  let mem (type a) (x : a) (s : a set) : bool = [%external \"SET_MEM\"] x s\n  let add (type a) (x : a) (s : a set) : a set = [%external \"SET_ADD\"] x s\n  let remove (type a) (x : a) (s : a set) : a set = [%external \"SET_REMOVE\"] x s\n  let update (type a) (x : a) (b : bool) (s : a set) = [%external \"SET_UPDATE\"] x b s\n  let iter (type a) (f : a -> unit) (s : a set) : unit = [%external \"SET_ITER\"] f s\n  let fold (type a b) (f : b * a -> b) (s : a set) (i : b) : b = [%external \"SET_FOLD\"] f s i\n  let fold_desc (type a b) (f : a * b -> b) (s : a set) (i : b) : b = [%external \"SET_FOLD_DESC\"] f s i\n  let size (type a) (s : a set) : nat = [%Michelson ({| { SIZE } |} : a set -> nat)]  s\n  let cardinal (type a) (s : a set) : nat = [%Michelson ({| { SIZE } |} : a set -> nat)] s\nend\n\nmodule List = struct\n  let length (type a) (xs : a list) : nat = [%Michelson ({| { SIZE } |} : a list -> nat)]  xs\n  let size (type a) (xs : a list) : nat = [%Michelson ({| { SIZE } |} : a list -> nat)]  xs\n  let head_opt (type a) (xs : a list) : a option = [%external \"LIST_HEAD_OPT\"] xs\n  let tail_opt (type a) (xs : a list) : (a list) option = [%external \"LIST_TAIL_OPT\"] xs\n  let map (type a b) (f : a -> b) (xs : a list) : b list = [%external \"LIST_MAP\"] f xs\n  let iter (type a) (f : a -> unit) (xs : a list): unit = [%external \"LIST_ITER\"] f xs\n  let fold (type a b) (f : b * a -> b) (xs : a list) (i : b) : b = [%external \"LIST_FOLD\"] f xs i\n  let fold_left (type a b) (f : b * a -> b) (i : b) (xs : a list) : b = [%external \"LIST_FOLD_LEFT\"] f i xs\n  let fold_right (type a b) (f : a * b -> b) (xs : a list) (i : b) : b = [%external \"LIST_FOLD_RIGHT\"] f xs i\n  let cons (type a) (x : a) (xs : a list) : a list = [%external \"CONS\"] x xs\nend\n\nmodule String = struct\n  let concat (b1 : string) (b2 : string) : string = [%Michelson ({| { UNPAIR ; CONCAT } |} : string * string -> string)] (b1, b2)\n  let sub (s : nat) (l : nat) (b : string) : string =\n    [%Michelson ({| { UNPAIR ; UNPAIR ; SLICE ; IF_NONE { PUSH string \"SLICE\" ; FAILWITH } {} } |} : nat * nat * string -> string)] (s, l, b)\n  let length (b : string) : nat = [%Michelson ({| { SIZE } |} : string -> nat)] b\nend\n\nmodule Option = struct\n  let unopt (type a) (v : a option) : a = [%external \"UNOPT\"] v\n  let unopt_with_error (type a) (v : a option) ("
let d_616c2ac351ab2f5ad2983d2528ee3dd4 = " string) : michelson_program = failwith \"TEST MODE\"\n  let restore_context (_u : unit) : unit = failwith \"TEST_POP_CONTEXT\"\n  let save_context (_u : unit) : unit = failwith \"TEST_PUSH_CONTEXT\"\nend"
let d_9048e7429ed786680d770f7eb70c3d89 = "\n  let unopt_with_error (type a) ((v, s) : (a option) * string) : a = [%external \"UNOPT_WITH_ERROR\"] v s\n  (* let map (type a b) ((f, v) : (a -> b) * (a option)) : b option = [%external \"OPTION_MAP\"] f v *)\nend\n\nmodule Bytes = struct\n  let concat ((b1, b2) : bytes * bytes) : bytes = [%Michelson ({| { UNPAIR ; CONCAT } |} : bytes * bytes -> bytes)] (b1, b2)\n  let sub ((s, l, b) : nat * nat * bytes) : bytes = [%Michelson ({| { UNPAIR ; UNPAIR ; SLICE ; IF_NONE { PUSH string \"SLICE\" ; FAILWITH } {} } |} : nat * nat * bytes -> bytes)] (s, l, b)\n  let pack (type a) (v : a) : bytes = [%Michelson ({| { PACK } |} : a -> bytes)] v\n  let unpack (type a) (b : bytes) : a option = [%external \"BYTES_UNPACK\"] b\n  let length (b : bytes) : nat = [%Michelson ({| { SIZE } |} : bytes -> nat)] b\nend\n\nmodule Crypto = struct\n  let blake2b (b : bytes) : bytes = [%Michelson ({| { BLAKE2B } |} : bytes -> bytes)] b\n  let sha256 (b : bytes) : bytes = [%Michelson ({| { SHA256 } |} : bytes -> bytes)] b\n  let sha512 (b : bytes) : bytes = [%Michelson ({| { SHA512 } |} : bytes -> bytes)] b\n  let sha3 (b : bytes) : bytes = [%Michelson ({| { SHA3 } |} : bytes -> bytes)] b\n  let keccak (b : bytes) : bytes = [%Michelson ({| { KECCAK } |} : bytes -> bytes)] b\n  let hash_key (k : key) : key_hash = [%Michelson ({| { HASH_KEY } |} : key -> key_hash)] k\n  let check ((k, s, b) : key * signature * bytes) : bool = [%Michelson ({| { UNPAIR ; UNPAIR ; CHECK_SIGNATURE } |} : key * signature * bytes -> bool)] (k, s, b)\nend\n\n[@private]\n  let assert (b : bool) : unit = [%Michelson ({| { IF { UNIT } { PUSH string \"failed assertion\" ; FAILWITH } } |} : bool -> unit)] b\n[@private]\n  let assert_with_error ((b, s) : bool * string) = [%Michelson ({| { UNPAIR ; IF { DROP ; UNIT } { FAILWITH } } |} : bool * string -> unit)] (b, s)\n[@private]\n  let assert_some (type a) (v : a option) : unit = [%Michelson ({| { IF_NONE { PUSH string \"failed assert some\" ; FAILWITH } { DROP ; UNIT } } |} : a option -> unit)] v\n[@private]\n  let assert_some_with_error (type a) ((v, s) : a option * string) : unit = [%Michelson ({| { UNPAIR ; IF_NONE { FAILWITH } { DROP 2 ; UNIT } } |} : a option * string -> unit)] (v, s)\n[@private]\n  let assert_none (type a) (v : a option) : unit = [%Michelson ({| { IF_NONE { UNIT } { PUSH string \"failed assert none\" ; FAILWITH } } |} : a option -> unit)] v\n[@private]\n  let assert_none_with_error (type a) ((v, s) : a option * string) : unit = [%Michelson ({| { UNPAIR ; IF_NONE { DROP ; UNIT } { DROP ; FAILWITH } } |} : a option * string -> unit)] (v, s)\n[@private]\n  let abs (i : int) : nat = [%Michelson ({| { ABS } |} : int -> nat)] i\n[@private]\n  let is_nat (i : int) : nat option = [%Michelson ({| { ISNAT } |} : int -> nat option)] i\n[@private]\n  let true : bool = [%external \"TRUE\"]\n[@private]\n  let false : bool = [%external \"FALSE\"]\n[@private]\n  let unit : unit = [%external \"UNIT\"]\n[@private]\n  let failwith (type a) (v : a) : a external_failwith = [%external \"FAILWITH\"] v\n[@private]\n  let int (type a) (v : a) : a external_int = [%Michelson ({| { INT } |} : a -> a external_int)] v\n[@private]\n  let ediv (type a b) ((l, r) : (a * b)) : (a, b) external_u_ediv = [%Michelson ({| { UNPAIR ; EDIV } |} : a * b -> (a, b) external_u_ediv)] (l, r)"
let d_92a0c0d9aa552ce357610166c378698a = "s : string) : a = [%external \"UNOPT_WITH_ERROR\"] v s\n  (* let map (type a b) (f : a -> b) (v : a option) : b option = [%external \"OPTION_MAP\"] f v *)\nend\n\nmodule Bytes = struct\n  let concat (b1 : bytes) (b2 : bytes) : bytes = [%Michelson ({| { UNPAIR ; CONCAT } |} : bytes * bytes -> bytes)] (b1, b2)\n  let sub (s : nat) (l : nat) (b : bytes) : bytes =\n    [%Michelson ({| { UNPAIR ; UNPAIR ; SLICE ; IF_NONE { PUSH string \"SLICE\" ; FAILWITH } {} } |} : nat * nat * bytes -> bytes)] (s, l, b)\n  let pack (type a) (v : a) : bytes = [%Michelson ({| { PACK } |} : a -> bytes)] v\n  let unpack (type a) (b : bytes) : a option = [%external \"BYTES_UNPACK\"] b\n  let length (b : bytes) : nat = [%Michelson ({| { SIZE } |} : bytes -> nat)] b\nend\n\nmodule Crypto = struct\n  let blake2b (b : bytes) : bytes = [%Michelson ({| { BLAKE2B } |} : bytes -> bytes)] b\n  let sha256 (b : bytes) : bytes = [%Michelson ({| { SHA256 } |} : bytes -> bytes)] b\n  let sha512 (b : bytes) : bytes = [%Michelson ({| { SHA512 } |} : bytes -> bytes)] b\n  let sha3 (b : bytes) : bytes = [%Michelson ({| { SHA3 } |} : bytes -> bytes)] b\n  let keccak (b : bytes) : bytes = [%Michelson ({| { KECCAK } |} : bytes -> bytes)] b\n  let hash_key (k : key) : key_hash = [%Michelson ({| { HASH_KEY } |} : key -> key_hash)] k\n  let check (k : key) (s : signature) (b : bytes) : bool = [%Michelson ({| { UNPAIR ; UNPAIR ; CHECK_SIGNATURE } |} : key * signature * bytes -> bool)] (k, s, b)\nend\n\n[@private]\n  let assert (b : bool) : unit = [%Michelson ({| { IF { UNIT } { PUSH string \"failed assertion\" ; FAILWITH } } |} : bool -> unit)] b\n[@private]\n  let assert_with_error (b : bool) (s : string) =\n    [%Michelson ({| { UNPAIR ; IF { DROP ; UNIT } { FAILWITH } } |} : bool * string -> unit)] (b, s)\n[@private]\n  let assert_some (type a) (v : a option) : unit =\n    [%Michelson ({| { IF_NONE { PUSH string \"failed assert some\" ; FAILWITH } { DROP ; UNIT } } |} : a option -> unit)] v\n[@private]\n  let assert_some_with_error (type a) (v : a option) (s : string) : unit =\n    [%Michelson ({| { UNPAIR ; IF_NONE { FAILWITH } { DROP 2 ; UNIT } } |} : a option * string -> unit)] (v, s)\n[@private]\n  let assert_none (type a) (v : a option) : unit =\n    [%Michelson ({| { IF_NONE { UNIT } { PUSH string \"failed assert none\" ; FAILWITH } } |} : a option -> unit)] v\n[@private]\n  let assert_none_with_error (type a) (v : a option) (s : string) : unit =\n    [%Michelson ({| { UNPAIR ; IF_NONE { DROP ; UNIT } { DROP ; FAILWITH } } |} : a option * string -> unit)] (v, s)\n[@private]\n  let abs (i : int) : nat = [%Michelson ({| { ABS } |} : int -> nat)] i\n[@private]\n  let is_nat (i : int) : nat option = [%Michelson ({| { ISNAT } |} : int -> nat option)] i\n[@private]\n  let true : bool = [%external \"TRUE\"]\n[@private]\n  let false : bool = [%external \"FALSE\"]\n[@private]\n  let unit : unit = [%external \"UNIT\"]\n[@private]\n  let failwith (type a) (v : a) : a external_failwith = [%external \"FAILWITH\"] v\n[@private]\n  let int (type a) (v : a) : a external_int = [%Michelson ({| { INT } |} : a -> a external_int)] v\n[@private]\n  let ediv (type a b) (l : a) (r : b) : (a, b) external_ediv = [%Michelson ({| { UNPAIR ; EDIV } |} : a * b -> (a, b) external_ediv)] (l, r)"
let d_9ccb85d53cd15605686f7c9899a0bc47 = "module Test = struct\n  [@private] let failwith (type a) (v : a) : a external_failwith = [%external \"FAILWITH\"] v\n  type ('a, 'b) typed_address = unit\n  type michelson_program = unit\n  type test_exec_result = unit\n  type mutation = unit\n  let to_contract (type p s) (_t : (p, s) typed_address) : p contract = failwith \"TEST MODE\"\n  let originate_from_file (_fn : string) (_e : string) (_v : string list) (_s : michelson_program)  (_t : tez) : address * michelson_program * int = failwith \"TEST MODE\"\n  let originate (type p s) (_f : p * s -> operation list * s) (_s : s) (_t : tez) : ((p, s) typed_address * michelson_program * int) = failwith \"TEST MODE\"\n  let set_source (_a : address) : unit = failwith \"TEST MODE\"\n  let set_baker (_a : address) : unit = failwith \"TEST MODE\"\n  let transfer (_a : address) (_s : michelson_program) (_t : tez) : test_exec_result = failwith \"TEST MODE\"\n  let transfer_exn (_a : address) (_s : michelson_program) (_t : tez) : nat = failwith \"TEST MODE\"\n  let transfer_to_contract (type p) (_a : p contract) (_s : p) (_t : tez) : test_exec_result = failwith \"TEST MODE\"\n  let transfer_to_contract_exn (type p) (_a : p contract) (_s : p) (_t : tez) : nat = failwith \"TEST MODE\"\n  let get_storage (type a b) (_t : (a, b) typed_address) : b = failwith \"TEST MODE\"\n  let get_storage_of_address (_a : address) : michelson_program = failwith \"TEST MODE\"\n  let get_balance (_a : address) : tez = failwith \"TEST MODE\"\n  let michelson_equal (_m1 : michelson_program) (_m2 : michelson_program) : bool = failwith \"TEST MODE\"\n  let log (type a) (_v : a) : unit = failwith \"TEST MODE\"\n  let reset_state (_n : nat) (_l : tez list) : unit = failwith \"TEST MODE\"\n  let get_voting_power (_kh : key_hash) : nat = failwith \"TEST MODE\"\n  [@thunk] let get_total_voting_power : nat = failwith \"TEST MODE\"\n  let bootstrap_contract (type p s) (_f : p * s -> operation list * s) (_s : s) (_t : tez) : unit = failwith \"TEST MODE\"\n  let nth_bootstrap_contract (_i : nat) : address = failwith \"TEST MODE\"\n  let nth_bootstrap_account (_i : int) : address = failwith \"TEST MODE\"\n  let nth_bootstrap_typed_address (type a b) (_n : nat) : (a, b) typed_address = failwith \"TEST MODE\"\n  let last_originations (_u : unit) : (address, address list) map = failwith \"TEST MODE\"\n  let compile_value (type a) (_v : a) : michelson_program = failwith \"TEST MODE\"\n  let mutate_value (type a) (_n : nat) (_v : a) : (a * mutation) option = failwith \"TEST MODE\"\n  let save_mutation (_s : string) (_m : mutation) : string option = failwith \"TEST MODE\"\n  let mutation_test (type a b) (_v : a) (_f : a -> b) : (b * mutation) option = failwith \"TEST MODE\"\n  let mutation_test_all (type a b) (_v : a) (_f : a -> b) : (b * mutation) list = failwith \"TEST MODE\"\n  let run (type a b) (_f : a -> b) (_v : a) : michelson_program = failwith \"TEST MODE\"\n  let eval (type a) (_v : a) : michelson_program = failwith \"TEST MODE\"\n  let decompile (type a) (_m : michelson_program) : a = failwith \"TEST MODE\"\n  let random (type a) (_u : unit) : a option = failwith \"TEST MODE\"\n  let add_account (_s : string) (_k : key) : unit = failwith \"TEST MODE\"\n  let new_account (_u : unit) : string * key = failwith \"TEST MODE\"\n  let baker_account (_p : string * key) (_o : tez option) : unit = failwith \"TEST MODE\"\n  let bake_until_n_cycle_end (_n : nat) : unit = failwith \"TEST MODE\"\n  let register_delegate (_kh : key_hash) : unit = failwith \"TEST MODE\"\n  let register_constant (_m : michelson_program) : string = failwith \"TEST MODE\"\n  let cast_address (type a b) (_a : address) : (a, b) typed_address = failwith \"TEST MODE\"\n  let to_typed_address (type a b) (_c : a contract) : (a, b) typed_address = failwith \"TEST MODE\"\n  let to_entrypoint (type a b c) (_s : string) (_t : (a, b) typed_address) : c contract = failwith \"TEST MODE\"\n  let set_big_map (type a b) (_i : int) (_m : (a, b) big_map) : unit = failwith \"TEST MODE\"\n  let create_chest (_b : bytes) (_n : nat) : chest * chest_key = failwith \"TEST MODE\"\n  let create_chest_key (_c : chest) (_n : nat) : chest_key = failwith \"TEST MODE\"\n  let constant_to_michelson_program (_s :"
let d_a6dde8289f57cc12abaa8b7f5ca447a7 = "module Tezos = struct\n  let get_contract (type a) (a : address) : (a contract) = [%external \"CONTRACT\"] a\n  let get_contract_opt (type a) (a : address) : (a contract) option = [%external \"CONTRACT_OPT\"] a\n  let get_contract_with_error (type a) (a : address) (s : string) : a contract = [%external \"CONTRACT_WITH_ERROR\"] a s\n  (* let get_entrypoint_opt (type a) (s : string) (a : address) : (a contract) option = [%external \"CONTRACT_ENTRYPOINT_OPT\"] s a *)\n  [@thunk]\n    let balance : tez = [%Michelson ({| { DROP ; BALANCE } |} : unit -> tez)] ()\n  [@thunk]\n    let amount : tez = [%Michelson ({| { DROP ; AMOUNT } |} : unit -> tez)] ()\n  [@thunk]\n    let now : timestamp = [%Michelson ({| { DROP ; NOW } |} : unit -> timestamp)] ()\n  [@thunk]\n    let sender : address = [%Michelson ({| { DROP ; SENDER } |} : unit -> address)] ()\n  [@thunk]\n    let source : address = [%Michelson ({| { DROP ; SOURCE } |} : unit -> address)] ()\n  [@thunk]\n    let level : nat = [%Michelson ({| { DROP ; LEVEL } |} : unit -> nat)] ()\n  [@thunk]\n    let self_address : address = [%external \"SELF_ADDRESS\"]\n  [@thunk]\n    let chain_id : chain_id = [%Michelson ({| { DROP ; CHAIN_ID } |} : unit -> chain_id)] ()\n  [@thunk]\n    let total_voting_power : nat = [%Michelson ({| { DROP ; TOTAL_VOTING_POWER } |} : unit -> nat)] ()\n  let min_block_time : unit -> nat = [%Michelson ({| { DROP; MIN_BLOCK_TIME } |} : unit -> nat) ]\n  (* [@thunk] let self (type a) (s : string) : a contract = [%external \"SELF\"] s *)\n  let voting_power (kh : key_hash) : nat = [%Michelson ({| { VOTING_POWER } |} : key_hash -> nat)] kh\n  let address (type a) (c : a contract) : address = [%external \"ADDRESS\"] c\n  let implicit_account (kh : key_hash) : unit contract = [%external \"IMPLICIT_ACCOUNT\"] kh\n  let create_ticket (type a) (v : a) (n : nat) : a ticket = [%Michelson ({| { UNPAIR ; TICKET } |} : a * nat -> a ticket)] (v, n)\n  let join_tickets (type a) (t : a ticket * a ticket) : (a ticket) option = [%Michelson ({| { JOIN_TICKETS } |} : a ticket * a ticket -> a ticket option)] t\n  let split_ticket (type a) (t : a ticket) (p : nat * nat) : (a ticket * a ticket) option =\n    [%Michelson ({| { UNPAIR ; SPLIT_TICKET } |} : a ticket * (nat * nat) -> (a ticket * a ticket) option)] (t, p)\n  let read_ticket (type a) (t : a ticket) : (address * (a * nat)) * a ticket =\n    [%Michelson ({| { READ_TICKET ; PAIR } |} : a ticket -> (address * (a * nat)) * a ticket)] t\n  (* let create_contract (type a b) (c : a * b -> operation list * b) (kh : key_hash) (mu : tez) (s : b) : operation * address = [%external \"CREATE_CONTRACT\"] c kh mu s *)\n  let never (type a) (n : never) : a = [%Michelson ({| { NEVER } |} : never -> a)] n\n  let pairing_check (l : (bls12_381_g1 * bls12_381_g2) list) : bool = [%Michelson ({| { PAIRING_CHECK } |} : (bls12_381_g1 * bls12_381_g2) list -> bool)] l\n  let open_chest (ck : chest_key) (c : chest) (n : nat) : chest_opening_result = [%external \"OPEN_CHEST\"] ck c n\n  let call_view (type a b) (s : string) (x : a) (a : address)  : b option = [%external \"VIEW\"] s x a\n  let constant (type a) (s : string) : a = [%external \"GLOBAL_CONSTANT\"] s\n  let transaction (type a) (a : a) (mu : tez) (c : a contract) : operation = [%external \"CALL\"] a mu c\n  let set_delegate (o : key_hash option) : operation = [%external \"SET_DELEGATE\"] o\n  \nend\n\nmodule Bitwise = struct\n  (* let and (type a b) (l : a) (r : b) : (a, b) external_and = [%external \"AND\"] l r *)\n  let xor (l : nat) (r : nat) : nat = [%external \"XOR\"] l r\n  (* let or (l : nat) (r : nat) : nat = [%external \"OR\"] l r *)\n  let shift_left (l : nat) (r : nat) : nat = [%external \"LSL\"] l r\n  let shift_right (l : nat) (r : nat) : nat = [%external \"LSR\"] l r\nend\n\nmodule Big_map = struct\n  let empty (type k v) : (k, v) big_map = [%external \"BIG_MAP_EMPTY\"]\n  let mem (type k v) (k : k) (m : (k, v) big_map) : bool = [%Michelson ({| { UNPAIR ; MEM } |} : k * (k, v) big_map -> bool)] (k, m)\n  let add (type k v) (k : k) (v : v) (m : (k, v) big_map) : (k, v) big_map = [%external \"MAP_ADD\"] k v m\n  let remove (type k v) (k : k) (m : (k, v) big_map) : (k, v)"
let d_b1d733fb76da185dec75be4a275041b7 = "on) : b option = [%external \"OPTION_MAP\"] f v *)\nend\n\nmodule Bytes = struct\n  let concat (b1 : bytes) (b2 : bytes) : bytes = [%Michelson ({| { UNPAIR ; CONCAT } |} : bytes * bytes -> bytes)] (b1, b2)\n  let sub (s : nat) (l : nat) (b : bytes) : bytes =\n    [%Michelson ({| { UNPAIR ; UNPAIR ; SLICE ; IF_NONE { PUSH string \"SLICE\" ; FAILWITH } {} } |} : nat * nat * bytes -> bytes)] (s, l, b)\n  let pack (type a) (v : a) : bytes = [%Michelson ({| { PACK } |} : a -> bytes)] v\n  let unpack (type a) (b : bytes) : a option = [%external \"BYTES_UNPACK\"] b\n  let length (b : bytes) : nat = [%Michelson ({| { SIZE } |} : bytes -> nat)] b\nend\n\nmodule Crypto = struct\n  let blake2b (b : bytes) : bytes = [%Michelson ({| { BLAKE2B } |} : bytes -> bytes)] b\n  let sha256 (b : bytes) : bytes = [%Michelson ({| { SHA256 } |} : bytes -> bytes)] b\n  let sha512 (b : bytes) : bytes = [%Michelson ({| { SHA512 } |} : bytes -> bytes)] b\n  let sha3 (b : bytes) : bytes = [%Michelson ({| { SHA3 } |} : bytes -> bytes)] b\n  let keccak (b : bytes) : bytes = [%Michelson ({| { KECCAK } |} : bytes -> bytes)] b\n  let hash_key (k : key) : key_hash = [%Michelson ({| { HASH_KEY } |} : key -> key_hash)] k\n  let check (k : key) (s : signature) (b : bytes) : bool = [%Michelson ({| { UNPAIR ; UNPAIR ; CHECK_SIGNATURE } |} : key * signature * bytes -> bool)] (k, s, b)\nend\n\n[@private]\n  let assert (b : bool) : unit = [%Michelson ({| { IF { UNIT } { PUSH string \"failed assertion\" ; FAILWITH } } |} : bool -> unit)] b\n[@private]\n  let assert_with_error (b : bool) (s : string) =\n    [%Michelson ({| { UNPAIR ; IF { DROP ; UNIT } { FAILWITH } } |} : bool * string -> unit)] (b, s)\n[@private]\n  let assert_some (type a) (v : a option) : unit =\n    [%Michelson ({| { IF_NONE { PUSH string \"failed assert some\" ; FAILWITH } { DROP ; UNIT } } |} : a option -> unit)] v\n[@private]\n  let assert_some_with_error (type a) (v : a option) (s : string) : unit =\n    [%Michelson ({| { UNPAIR ; IF_NONE { FAILWITH } { DROP 2 ; UNIT } } |} : a option * string -> unit)] (v, s)\n[@private]\n  let assert_none (type a) (v : a option) : unit =\n    [%Michelson ({| { IF_NONE { UNIT } { PUSH string \"failed assert none\" ; FAILWITH } } |} : a option -> unit)] v\n[@private]\n  let assert_none_with_error (type a) (v : a option) (s : string) : unit =\n    [%Michelson ({| { UNPAIR ; IF_NONE { DROP ; UNIT } { DROP ; FAILWITH } } |} : a option * string -> unit)] (v, s)\n[@private]\n  let abs (i : int) : nat = [%Michelson ({| { ABS } |} : int -> nat)] i\n[@private]\n  let is_nat (i : int) : nat option = [%Michelson ({| { ISNAT } |} : int -> nat option)] i\n[@private]\n  let true : bool = [%external \"TRUE\"]\n[@private]\n  let false : bool = [%external \"FALSE\"]\n[@private]\n  let unit : unit = [%external \"UNIT\"]\n[@private]\n  let failwith (type a) (v : a) : a external_failwith = [%external \"FAILWITH\"] v\n[@private]\n  let int (type a) (v : a) : a external_int = [%Michelson ({| { INT } |} : a -> a external_int)] v\n[@private]\n  let ediv (type a b) (l : a) (r : b) : (a, b) external_ediv = [%Michelson ({| { UNPAIR ; EDIV } |} : a * b -> (a, b) external_ediv)] (l, r)"
let d_c13b3defbdcfef249fd5de6c5940bf4a = "module Tezos = struct\n  let get_contract (type a) (a : address) : (a contract) = [%external \"CONTRACT\"] a\n  let get_contract_opt (type a) (a : address) : (a contract) option = [%external \"CONTRACT_OPT\"] a\n  let get_contract_with_error (type a) ((a, s) : address * string) : a contract = [%external \"CONTRACT_WITH_ERROR\"] a s\n  (* let get_entrypoint_opt (type a) ((s, a) : string * address) : (a contract) option = [%external \"CONTRACT_ENTRYPOINT_OPT\"] s a *)\n  [@thunk]\n    let balance : tez = [%Michelson ({| { DROP ; BALANCE } |} : unit -> tez)] ()\n  [@thunk]\n    let amount : tez = [%Michelson ({| { DROP ; AMOUNT } |} : unit -> tez)] ()\n  [@thunk]\n    let now : timestamp = [%Michelson ({| { DROP ; NOW } |} : unit -> timestamp)] ()\n  [@thunk]\n    let sender : address = [%Michelson ({| { DROP ; SENDER } |} : unit -> address)] ()\n  [@thunk]\n    let source : address = [%Michelson ({| { DROP ; SOURCE } |} : unit -> address)] ()\n  [@thunk]\n    let level : nat = [%Michelson ({| { DROP ; LEVEL } |} : unit -> nat)] ()\n  [@thunk]\n    let self_address : address = [%external \"SELF_ADDRESS\"]\n  [@thunk]\n    let chain_id : chain_id = [%Michelson ({| { DROP ; CHAIN_ID } |} : unit -> chain_id)] ()\n  [@thunk]\n    let total_voting_power : nat = [%Michelson ({| { DROP ; TOTAL_VOTING_POWER } |} : unit -> nat)] ()\n  (* [@thunk] let self (type a) (s : string) : a contract = [%external \"SELF\"] s *)\n  let voting_power (kh : key_hash) : nat = [%Michelson ({| { VOTING_POWER } |} : key_hash -> nat)] kh\n  let address (type a) (c : a contract) : address = [%external \"ADDRESS\"] c\n  let implicit_account (kh : key_hash) : unit contract = [%external \"IMPLICIT_ACCOUNT\"] kh\n  let create_ticket (type a) ((v, n) : a * nat) : a ticket =\n    [%Michelson ({| { UNPAIR ; TICKET } |} : a * nat -> a ticket)] (v, n)\n  let join_tickets (type a) (t : a ticket * a ticket) : (a ticket) option = [%Michelson ({| { JOIN_TICKETS } |} : a ticket * a ticket -> a ticket option)] t\n  let split_ticket (type a) ((t, p) : (a ticket) * (nat * nat)) : (a ticket * a ticket) option =\n    [%Michelson ({| { UNPAIR ; SPLIT_TICKET } |} : a ticket * (nat * nat) -> (a ticket * a ticket) option)] (t, p)\n  let read_ticket (type a) (t : a ticket) : (address * (a * nat)) * a ticket = [%Michelson ({| { READ_TICKET ; PAIR } |} : a ticket -> (address * (a * nat)) * a ticket)] t\n  (* let create_contract (type a b) ((c, kh, mu, s) : (a * b -> operation list * b) * key_hash * tez * b) : operation * address = [%external \"CREATE_CONTRACT\"] c kh mu s *)\n  let never (type a) (n : never) : a = [%Michelson ({| { NEVER } |} : never -> a)] n\n  let pairing_check (l : (bls12_381_g1 * bls12_381_g2) list) : bool = [%Michelson ({| { PAIRING_CHECK } |} : (bls12_381_g1 * bls12_381_g2) list -> bool)] l\n  let open_chest ((ck, c, n) : chest_key * chest * nat) : chest_opening_result = [%external \"OPEN_CHEST\"] ck c n\n  let call_view (type a b) ((s, x, a) : string * a * address)  : b option = [%external \"VIEW\"] s x a\n  let constant (type a) (s : string) : a = [%external \"GLOBAL_CONSTANT\"] s\n  let transaction (type a) ((a, mu, c) : a * tez * a contract) : operation = [%external \"CALL\"] a mu c\n  let set_delegate (o : key_hash option) : operation = [%external \"SET_DELEGATE\"] o\nend\n\nmodule Bitwise = struct\n  (* let and (type a b) ((l, r) : (a, b)) : (a, b) external_and = [%external \"AND\"] l r *)\n  let xor ((l, r) : nat * nat) : nat = [%external \"XOR\"] l r\n  (* let or ((l, r) : nat * nat) : nat = [%external \"OR\"] l r *)\n  let shift_left ((l, r) : nat * nat) : nat = [%external \"LSL\"] l r\n  let shift_right ((l, r) : nat * nat) : nat = [%external \"LSR\"] l r\nend\n\nmodule Big_map = struct\n  let empty (type k v) : (k, v) big_map = [%external \"BIG_MAP_EMPTY\"]\n  let mem (type k v) ((k, m) : k * (k, v) big_map) : bool = [%Michelson ({| { UNPAIR ; MEM } |} : k * (k, v) big_map -> bool)] (k, m)\n  let add (type k v) ((k, v, m) : k * v * (k, v) big_map) : (k, v) big_map = [%external \"MAP_ADD\"] k v m\n  let remove (type k v) ((k, m) : k * (k, v) big_map) : (k, v) big_map = [%external \"MAP_REMOVE\"] k m\n  let update (type k v) ((k, v, m) : k * v o"
let d_c47445b90cb3efe857a2ec8711f1ba65 = "module Tezos = struct\n  let get_contract (type a) (a : address) : (a contract) = [%external \"CONTRACT\"] a\n  let get_contract_opt (type a) (a : address) : (a contract) option = [%external \"CONTRACT_OPT\"] a\n  let get_contract_with_error (type a) ((a, s) : address * string) : a contract = [%external \"CONTRACT_WITH_ERROR\"] a s\n  (* let get_entrypoint_opt (type a) ((s, a) : string * address) : (a contract) option = [%external \"CONTRACT_ENTRYPOINT_OPT\"] s a *)\n  [@thunk]\n    let balance : tez = [%Michelson ({| { DROP ; BALANCE } |} : unit -> tez)] ()\n  [@thunk]\n    let amount : tez = [%Michelson ({| { DROP ; AMOUNT } |} : unit -> tez)] ()\n  [@thunk]\n    let now : timestamp = [%Michelson ({| { DROP ; NOW } |} : unit -> timestamp)] ()\n  [@thunk]\n    let sender : address = [%Michelson ({| { DROP ; SENDER } |} : unit -> address)] ()\n  [@thunk]\n    let source : address = [%Michelson ({| { DROP ; SOURCE } |} : unit -> address)] ()\n  [@thunk]\n    let level : nat = [%Michelson ({| { DROP ; LEVEL } |} : unit -> nat)] ()\n  [@thunk]\n    let self_address : address = [%external \"SELF_ADDRESS\"]\n  [@thunk]\n    let chain_id : chain_id = [%Michelson ({| { DROP ; CHAIN_ID } |} : unit -> chain_id)] ()\n  [@thunk]\n    let total_voting_power : nat = [%Michelson ({| { DROP ; TOTAL_VOTING_POWER } |} : unit -> nat)] ()\n  let min_block_time : unit -> nat = [%Michelson ({| { DROP; MIN_BLOCK_TIME } |} : unit -> nat) ]\n  (* [@thunk] let self (type a) (s : string) : a contract = [%external \"SELF\"] s *)\n  let voting_power (kh : key_hash) : nat = [%Michelson ({| { VOTING_POWER } |} : key_hash -> nat)] kh\n  let address (type a) (c : a contract) : address = [%external \"ADDRESS\"] c\n  let implicit_account (kh : key_hash) : unit contract = [%external \"IMPLICIT_ACCOUNT\"] kh\n  let create_ticket (type a) ((v, n) : a * nat) : a ticket =\n    [%Michelson ({| { UNPAIR ; TICKET } |} : a * nat -> a ticket)] (v, n)\n  let join_tickets (type a) (t : a ticket * a ticket) : (a ticket) option = [%Michelson ({| { JOIN_TICKETS } |} : a ticket * a ticket -> a ticket option)] t\n  let split_ticket (type a) ((t, p) : (a ticket) * (nat * nat)) : (a ticket * a ticket) option =\n    [%Michelson ({| { UNPAIR ; SPLIT_TICKET } |} : a ticket * (nat * nat) -> (a ticket * a ticket) option)] (t, p)\n  let read_ticket (type a) (t : a ticket) : (address * (a * nat)) * a ticket = [%Michelson ({| { READ_TICKET ; PAIR } |} : a ticket -> (address * (a * nat)) * a ticket)] t\n  (* let create_contract (type a b) ((c, kh, mu, s) : (a * b -> operation list * b) * key_hash * tez * b) : operation * address = [%external \"CREATE_CONTRACT\"] c kh mu s *)\n  let never (type a) (n : never) : a = [%Michelson ({| { NEVER } |} : never -> a)] n\n  let pairing_check (l : (bls12_381_g1 * bls12_381_g2) list) : bool = [%Michelson ({| { PAIRING_CHECK } |} : (bls12_381_g1 * bls12_381_g2) list -> bool)] l\n  let open_chest ((ck, c, n) : chest_key * chest * nat) : chest_opening_result = [%external \"OPEN_CHEST\"] ck c n\n  let call_view (type a b) ((s, x, a) : string * a * address)  : b option = [%external \"VIEW\"] s x a\n  let constant (type a) (s : string) : a = [%external \"GLOBAL_CONSTANT\"] s\n  let transaction (type a) ((a, mu, c) : a * tez * a contract) : operation = [%external \"CALL\"] a mu c\n  let set_delegate (o : key_hash option) : operation = [%external \"SET_DELEGATE\"] o\nend\n\nmodule Bitwise = struct\n  (* let and (type a b) ((l, r) : (a, b)) : (a, b) external_and = [%external \"AND\"] l r *)\n  let xor ((l, r) : nat * nat) : nat = [%external \"XOR\"] l r\n  (* let or ((l, r) : nat * nat) : nat = [%external \"OR\"] l r *)\n  let shift_left ((l, r) : nat * nat) : nat = [%external \"LSL\"] l r\n  let shift_right ((l, r) : nat * nat) : nat = [%external \"LSR\"] l r\nend\n\nmodule Big_map = struct\n  let empty (type k v) : (k, v) big_map = [%external \"BIG_MAP_EMPTY\"]\n  let mem (type k v) ((k, m) : k * (k, v) big_map) : bool = [%Michelson ({| { UNPAIR ; MEM } |} : k * (k, v) big_map -> bool)] (k, m)\n  let add (type k v) ((k, v, m) : k * v * (k, v) big_map) : (k, v) big_map = [%external \"MAP_ADD\"] k v m\n  let remove (type k v) ((k, m) : k * (k, v) big"
let d_cf779c7eb1c984fc36f2670e93496971 = "DELEGATE\"] kh\n  let register_constant (m : michelson_program) : string = [%external \"TEST_REGISTER_CONSTANT\"] m\n  let cast_address (type a b) (a : address) : (a, b) typed_address = [%external \"TEST_CAST_ADDRESS\"] a\n  let to_typed_address (type a b) (c : a contract) : (a, b) typed_address = [%external \"TEST_TO_TYPED_ADDRESS\"] c\n  let to_entrypoint (type a b c) ((s, t) : string * (a, b) typed_address) : c contract = [%external \"TEST_TO_ENTRYPOINT\"] s t\n  let set_big_map (type a b) ((i, m) : int * (a, b) big_map) : unit = [%external \"TEST_SET_BIG_MAP\"] i m\n  let create_chest ((b, n) : bytes * nat) : chest * chest_key = [%external \"TEST_CREATE_CHEST\"] b n\n  let create_chest_key ((c, n) : chest * nat) : chest_key = [%external \"TEST_CREATE_CHEST_KEY\"] c n\n  let constant_to_michelson_program (s : string) : michelson_program = [%external \"TEST_CONSTANT_TO_MICHELSON\"] s\n  let restore_context (u : unit) : unit = [%external \"TEST_POP_CONTEXT\"] u\n  let save_context (u : unit) : unit = [%external \"TEST_PUSH_CONTEXT\"] u\nend\n"
let d_e83d6d5ffa52a96f47127cea0fd9be4d = "ption * (k, v) big_map) : (k, v) big_map = [%external \"MAP_UPDATE\"] k v m\n  let get_and_update (type k v) ((k, v, m) : k * v option * (k, v) big_map) : v option * (k, v) big_map = [%external \"BIG_MAP_GET_AND_UPDATE\"] k v m\n  let find_opt (type k v) ((k, m) : k * (k, v) big_map) : v option = [%external \"MAP_FIND_OPT\"] k m\n  let find (type k v) ((k, m) : k * (k, v) big_map) : v = [%external \"MAP_FIND\"] k m\nend\n\nmodule Map = struct\n  let empty (type k v) : (k, v) map = [%external \"MAP_EMPTY\"]\n  let size (type k v) (m : (k, v) map) : nat = [%Michelson ({| { SIZE } |} : (k, v) map -> nat)] m\n  let mem (type k v) ((k, m) : k * (k, v) map) : bool = [%Michelson ({| { UNPAIR ; MEM } |} : k * (k, v) map -> bool)] (k, m)\n  let add (type k v) ((k, v, m) : k * v * (k, v) map) : (k, v) map = [%external \"MAP_ADD\"] k v m\n  let remove (type k v) ((k, m) : k * (k, v) map) : (k, v) map = [%external \"MAP_REMOVE\"] k m\n  let update (type k v) ((k, v, m) : k * v option * (k, v) map) : (k, v) map = [%external \"MAP_UPDATE\"] k v m\n  let get_and_update (type k v) ((k, v, m) : k * v option * (k, v) map) : v option * (k, v) map = [%external \"MAP_GET_AND_UPDATE\"] k v m\n  let find_opt (type k v) ((k, m) : k * (k, v) map) : v option = [%external \"MAP_FIND_OPT\"] k m\n  let find (type k v) ((k, m) : k * (k, v) map) : v = [%external \"MAP_FIND\"] k m\n  let iter (type k v) ((f, m) : (k * v -> unit) * (k, v) map) : unit = [%external \"MAP_ITER\"] f m\n  let map (type k v w) ((f, m) : (k * v -> w) * (k, v) map) : (k, w) map = [%external \"MAP_MAP\"] f m\n  let fold (type k v c) ((f, m, i) : (c * (k * v) -> c) * (k, v) map * c) : c = [%external \"MAP_FOLD\"] f m i\nend\n\nmodule Set = struct\n  let empty (type a) : a set = [%external \"SET_EMPTY\"]\n  let mem (type a) ((x, s) : a * a set) : bool = [%external \"SET_MEM\"] x s\n  let add (type a) ((x, s) : a * a set) : a set = [%external \"SET_ADD\"] x s\n  let remove (type a) ((x, s) : a * a set) : a set = [%external \"SET_REMOVE\"] x s\n  let update (type a) ((x, b, s) : a * bool * a set) = [%external \"SET_UPDATE\"] x b s\n  let iter (type a) ((f, s) : (a -> unit) * a set) : unit = [%external \"SET_ITER\"] f s\n  let fold (type a b) ((f, s, i) : (b * a -> b) * a set * b) : b = [%external \"SET_FOLD\"] f s i\n  let fold_desc (type a b) ((f, s, i) : (a * b -> b) * a set * b) : b = [%external \"SET_FOLD_DESC\"] f s i\n  let size (type a) (s : a set) : nat = [%Michelson ({| { SIZE } |} : a set -> nat)]  s\n  let cardinal (type a) (s : a set) : nat = [%Michelson ({| { SIZE } |} : a set -> nat)]  s\nend\n\nmodule List = struct\n  let length (type a) (xs : a list) : nat = [%Michelson ({| { SIZE } |} : a list -> nat)]  xs\n  let size (type a) (xs : a list) : nat = [%Michelson ({| { SIZE } |} : a list -> nat)]  xs\n  let head_opt (type a) (xs : a list) : a option = [%external \"LIST_HEAD_OPT\"] xs\n  let tail_opt (type a) (xs : a list) : (a list) option = [%external \"LIST_TAIL_OPT\"] xs\n  let map (type a b) ((f, xs) : (a -> b) * a list) : b list = [%external \"LIST_MAP\"] f xs\n  let iter (type a) ((f, xs) : (a -> unit) * a list): unit = [%external \"LIST_ITER\"] f xs\n  let fold (type a b) ((f, xs, i) : (b * a -> b) * a list * b) : b = [%external \"LIST_FOLD\"] f xs i\n  let fold_left (type a b) ((f, i, xs) : (b * a -> b) * b * a list) : b = [%external \"LIST_FOLD_LEFT\"] f i xs\n  let fold_right (type a b) ((f, xs, i) : (a * b -> b) * a list * b) : b = [%external \"LIST_FOLD_RIGHT\"] f xs i\n  let cons (type a) ((x, xs) : a * a list) : a list = [%external \"CONS\"] x xs\nend\n\nmodule String = struct\n  let concat ((b1, b2) : string * string) : string = [%Michelson ({| { UNPAIR ; CONCAT } |} : string * string -> string)] (b1, b2)\n  let sub ((s, l, b) : nat * nat * string) : string = [%Michelson ({| { UNPAIR ; UNPAIR ; SLICE ; IF_NONE { PUSH string \"SLICE\" ; FAILWITH } {} } |} : nat * nat * string -> string)] (s, l, b)\n  let length (b : string) : nat = [%Michelson ({| { SIZE } |} : string -> nat)] b\nend\n\nmodule Option = struct\n  let unopt (type a) (v : a option) : a = [%external \"UNOPT\"] v\n  let unopt_with_error (type a) ((v, s) : (a option) * string) : a = [%external \"UNOPT_WITH_ERROR"
let d_ea3e944956c1257cb9a8db7d0737e574 = "_map) : (k, v) big_map = [%external \"MAP_REMOVE\"] k m\n  let update (type k v) ((k, v, m) : k * v option * (k, v) big_map) : (k, v) big_map = [%external \"MAP_UPDATE\"] k v m\n  let get_and_update (type k v) ((k, v, m) : k * v option * (k, v) big_map) : v option * (k, v) big_map = [%external \"BIG_MAP_GET_AND_UPDATE\"] k v m\n  let find_opt (type k v) ((k, m) : k * (k, v) big_map) : v option = [%external \"MAP_FIND_OPT\"] k m\n  let find (type k v) ((k, m) : k * (k, v) big_map) : v = [%external \"MAP_FIND\"] k m\nend\n\nmodule Map = struct\n  let empty (type k v) : (k, v) map = [%external \"MAP_EMPTY\"]\n  let size (type k v) (m : (k, v) map) : nat = [%Michelson ({| { SIZE } |} : (k, v) map -> nat)] m\n  let mem (type k v) ((k, m) : k * (k, v) map) : bool = [%Michelson ({| { UNPAIR ; MEM } |} : k * (k, v) map -> bool)] (k, m)\n  let add (type k v) ((k, v, m) : k * v * (k, v) map) : (k, v) map = [%external \"MAP_ADD\"] k v m\n  let remove (type k v) ((k, m) : k * (k, v) map) : (k, v) map = [%external \"MAP_REMOVE\"] k m\n  let update (type k v) ((k, v, m) : k * v option * (k, v) map) : (k, v) map = [%external \"MAP_UPDATE\"] k v m\n  let get_and_update (type k v) ((k, v, m) : k * v option * (k, v) map) : v option * (k, v) map = [%external \"MAP_GET_AND_UPDATE\"] k v m\n  let find_opt (type k v) ((k, m) : k * (k, v) map) : v option = [%external \"MAP_FIND_OPT\"] k m\n  let find (type k v) ((k, m) : k * (k, v) map) : v = [%external \"MAP_FIND\"] k m\n  let iter (type k v) ((f, m) : (k * v -> unit) * (k, v) map) : unit = [%external \"MAP_ITER\"] f m\n  let map (type k v w) ((f, m) : (k * v -> w) * (k, v) map) : (k, w) map = [%external \"MAP_MAP\"] f m\n  let fold (type k v c) ((f, m, i) : (c * (k * v) -> c) * (k, v) map * c) : c = [%external \"MAP_FOLD\"] f m i\nend\n\nmodule Set = struct\n  let empty (type a) : a set = [%external \"SET_EMPTY\"]\n  let mem (type a) ((x, s) : a * a set) : bool = [%external \"SET_MEM\"] x s\n  let add (type a) ((x, s) : a * a set) : a set = [%external \"SET_ADD\"] x s\n  let remove (type a) ((x, s) : a * a set) : a set = [%external \"SET_REMOVE\"] x s\n  let update (type a) ((x, b, s) : a * bool * a set) = [%external \"SET_UPDATE\"] x b s\n  let iter (type a) ((f, s) : (a -> unit) * a set) : unit = [%external \"SET_ITER\"] f s\n  let fold (type a b) ((f, s, i) : (b * a -> b) * a set * b) : b = [%external \"SET_FOLD\"] f s i\n  let fold_desc (type a b) ((f, s, i) : (a * b -> b) * a set * b) : b = [%external \"SET_FOLD_DESC\"] f s i\n  let size (type a) (s : a set) : nat = [%Michelson ({| { SIZE } |} : a set -> nat)]  s\n  let cardinal (type a) (s : a set) : nat = [%Michelson ({| { SIZE } |} : a set -> nat)]  s\nend\n\nmodule List = struct\n  let length (type a) (xs : a list) : nat = [%Michelson ({| { SIZE } |} : a list -> nat)]  xs\n  let size (type a) (xs : a list) : nat = [%Michelson ({| { SIZE } |} : a list -> nat)]  xs\n  let head_opt (type a) (xs : a list) : a option = [%external \"LIST_HEAD_OPT\"] xs\n  let tail_opt (type a) (xs : a list) : (a list) option = [%external \"LIST_TAIL_OPT\"] xs\n  let map (type a b) ((f, xs) : (a -> b) * a list) : b list = [%external \"LIST_MAP\"] f xs\n  let iter (type a) ((f, xs) : (a -> unit) * a list): unit = [%external \"LIST_ITER\"] f xs\n  let fold (type a b) ((f, xs, i) : (b * a -> b) * a list * b) : b = [%external \"LIST_FOLD\"] f xs i\n  let fold_left (type a b) ((f, i, xs) : (b * a -> b) * b * a list) : b = [%external \"LIST_FOLD_LEFT\"] f i xs\n  let fold_right (type a b) ((f, xs, i) : (a * b -> b) * a list * b) : b = [%external \"LIST_FOLD_RIGHT\"] f xs i\n  let cons (type a) ((x, xs) : a * a list) : a list = [%external \"CONS\"] x xs\nend\n\nmodule String = struct\n  let concat ((b1, b2) : string * string) : string = [%Michelson ({| { UNPAIR ; CONCAT } |} : string * string -> string)] (b1, b2)\n  let sub ((s, l, b) : nat * nat * string) : string = [%Michelson ({| { UNPAIR ; UNPAIR ; SLICE ; IF_NONE { PUSH string \"SLICE\" ; FAILWITH } {} } |} : nat * nat * string -> string)] (s, l, b)\n  let length (b : string) : nat = [%Michelson ({| { SIZE } |} : string -> nat)] b\nend\n\nmodule Option = struct\n  let unopt (type a) (v : a option) : a = [%external \"UNOPT\"] v"
let d_f4c3e58921f52cae8d1301e41a1155e8 = "\"] v s\n  (* let map (type a b) ((f, v) : (a -> b) * (a option)) : b option = [%external \"OPTION_MAP\"] f v *)\nend\n\nmodule Bytes = struct\n  let concat ((b1, b2) : bytes * bytes) : bytes = [%Michelson ({| { UNPAIR ; CONCAT } |} : bytes * bytes -> bytes)] (b1, b2)\n  let sub ((s, l, b) : nat * nat * bytes) : bytes = [%Michelson ({| { UNPAIR ; UNPAIR ; SLICE ; IF_NONE { PUSH string \"SLICE\" ; FAILWITH } {} } |} : nat * nat * bytes -> bytes)] (s, l, b)\n  let pack (type a) (v : a) : bytes = [%Michelson ({| { PACK } |} : a -> bytes)] v\n  let unpack (type a) (b : bytes) : a option = [%external \"BYTES_UNPACK\"] b\n  let length (b : bytes) : nat = [%Michelson ({| { SIZE } |} : bytes -> nat)] b\nend\n\nmodule Crypto = struct\n  let blake2b (b : bytes) : bytes = [%Michelson ({| { BLAKE2B } |} : bytes -> bytes)] b\n  let sha256 (b : bytes) : bytes = [%Michelson ({| { SHA256 } |} : bytes -> bytes)] b\n  let sha512 (b : bytes) : bytes = [%Michelson ({| { SHA512 } |} : bytes -> bytes)] b\n  let sha3 (b : bytes) : bytes = [%Michelson ({| { SHA3 } |} : bytes -> bytes)] b\n  let keccak (b : bytes) : bytes = [%Michelson ({| { KECCAK } |} : bytes -> bytes)] b\n  let hash_key (k : key) : key_hash = [%Michelson ({| { HASH_KEY } |} : key -> key_hash)] k\n  let check ((k, s, b) : key * signature * bytes) : bool = [%Michelson ({| { UNPAIR ; UNPAIR ; CHECK_SIGNATURE } |} : key * signature * bytes -> bool)] (k, s, b)\nend\n\n[@private]\n  let assert (b : bool) : unit = [%Michelson ({| { IF { UNIT } { PUSH string \"failed assertion\" ; FAILWITH } } |} : bool -> unit)] b\n[@private]\n  let assert_with_error ((b, s) : bool * string) = [%Michelson ({| { UNPAIR ; IF { DROP ; UNIT } { FAILWITH } } |} : bool * string -> unit)] (b, s)\n[@private]\n  let assert_some (type a) (v : a option) : unit = [%Michelson ({| { IF_NONE { PUSH string \"failed assert some\" ; FAILWITH } { DROP ; UNIT } } |} : a option -> unit)] v\n[@private]\n  let assert_some_with_error (type a) ((v, s) : a option * string) : unit = [%Michelson ({| { UNPAIR ; IF_NONE { FAILWITH } { DROP 2 ; UNIT } } |} : a option * string -> unit)] (v, s)\n[@private]\n  let assert_none (type a) (v : a option) : unit = [%Michelson ({| { IF_NONE { UNIT } { PUSH string \"failed assert none\" ; FAILWITH } } |} : a option -> unit)] v\n[@private]\n  let assert_none_with_error (type a) ((v, s) : a option * string) : unit = [%Michelson ({| { UNPAIR ; IF_NONE { DROP ; UNIT } { DROP ; FAILWITH } } |} : a option * string -> unit)] (v, s)\n[@private]\n  let abs (i : int) : nat = [%Michelson ({| { ABS } |} : int -> nat)] i\n[@private]\n  let is_nat (i : int) : nat option = [%Michelson ({| { ISNAT } |} : int -> nat option)] i\n[@private]\n  let true : bool = [%external \"TRUE\"]\n[@private]\n  let false : bool = [%external \"FALSE\"]\n[@private]\n  let unit : unit = [%external \"UNIT\"]\n[@private]\n  let failwith (type a) (v : a) : a external_failwith = [%external \"FAILWITH\"] v\n[@private]\n  let int (type a) (v : a) : a external_int = [%Michelson ({| { INT } |} : a -> a external_int)] v\n[@private]\n  let ediv (type a b) ((l, r) : (a * b)) : (a, b) external_u_ediv = [%Michelson ({| { UNPAIR ; EDIV } |} : a * b -> (a, b) external_u_ediv)] (l, r)"
let d_f76d5e4141ccc16f2bb492f8513d5bdb = "t register_constant (m : michelson_program) : string = [%external \"TEST_REGISTER_CONSTANT\"] m\n  let cast_address (type a b) (a : address) : (a, b) typed_address = [%external \"TEST_CAST_ADDRESS\"] a\n  let to_typed_address (type a b) (c : a contract) : (a, b) typed_address = [%external \"TEST_TO_TYPED_ADDRESS\"] c\n  let to_entrypoint (type a b c) (s : string) (t : (a, b) typed_address) : c contract = [%external \"TEST_TO_ENTRYPOINT\"] s t\n  let set_big_map (type a b) (i : int) (m : (a, b) big_map) : unit = [%external \"TEST_SET_BIG_MAP\"] i m\n  let create_chest (b : bytes) (n : nat) : chest * chest_key = [%external \"TEST_CREATE_CHEST\"] b n\n  let create_chest_key (c : chest) (n : nat) : chest_key = [%external \"TEST_CREATE_CHEST_KEY\"] c n\n  let constant_to_michelson_program (s : string) : michelson_program = [%external \"TEST_CONSTANT_TO_MICHELSON\"] s\n  let restore_context (u : unit) : unit = [%external \"TEST_POP_CONTEXT\"] u\n  let save_context (u : unit) : unit = [%external \"TEST_PUSH_CONTEXT\"] u\nend"
let d_fa8906cf6c1026d8999151894434fd7c = "g_map) : (k, v) big_map = [%external \"MAP_UPDATE\"] k v m\n  let get_and_update (type k v) (k : k) (v : v option) (m : (k, v) big_map) : v option * (k, v) big_map = [%external \"BIG_MAP_GET_AND_UPDATE\"] k v m\n  let find_opt (type k v) (k : k) (m : (k, v) big_map) : v option = [%external \"MAP_FIND_OPT\"] k m\n  let find (type k v) (k : k) (m : (k, v) big_map) : v = [%external \"MAP_FIND\"] k m\nend\n\nmodule Map = struct\n  let empty (type k v) : (k, v) map = [%external \"MAP_EMPTY\"]\n  let size (type k v) (m : (k, v) map) : nat = [%Michelson ({| { SIZE } |} : (k, v) map -> nat)] m\n  let mem (type k v) (k : k) (m : (k, v) map) : bool = [%Michelson ({| { UNPAIR ; MEM } |} : k * (k, v) map -> bool)] (k, m)\n  let add (type k v) (k : k) (v : v) (m : (k, v) map) : (k, v) map = [%external \"MAP_ADD\"] k v m\n  let remove (type k v) (k : k) (m : (k, v) map) : (k, v) map = [%external \"MAP_REMOVE\"] k m\n  let update (type k v) (k : k) (v : v option) (m : (k, v) map) : (k, v) map = [%external \"MAP_UPDATE\"] k v m\n  let get_and_update (type k v) (k : k) (v : v option) (m : (k, v) map) : v option * (k, v) map = [%external \"MAP_GET_AND_UPDATE\"] k v m\n  let find (type k v) (k : k) (m : (k, v) map) : v = [%external \"MAP_FIND\"] k m\n  let find_opt (type k v) (k : k) (m : (k, v) map) : v option = [%external \"MAP_FIND_OPT\"] k m\n  let iter (type k v) (f : k * v -> unit) (m : (k, v) map) : unit = [%external \"MAP_ITER\"] f m\n  let map (type k v w) (f : k * v -> w) (m : (k, v) map) : (k, w) map = [%external \"MAP_MAP\"] f m\n  let fold (type k v c) (f : c * (k * v) -> c) (m : (k, v) map) (i : c) : c = [%external \"MAP_FOLD\"] f m i\nend\n\nmodule Set = struct\n  let empty (type a) : a set = [%external \"SET_EMPTY\"]\n  let mem (type a) (x : a) (s : a set) : bool = [%external \"SET_MEM\"] x s\n  let add (type a) (x : a) (s : a set) : a set = [%external \"SET_ADD\"] x s\n  let remove (type a) (x : a) (s : a set) : a set = [%external \"SET_REMOVE\"] x s\n  let update (type a) (x : a) (b : bool) (s : a set) = [%external \"SET_UPDATE\"] x b s\n  let iter (type a) (f : a -> unit) (s : a set) : unit = [%external \"SET_ITER\"] f s\n  let fold (type a b) (f : b * a -> b) (s : a set) (i : b) : b = [%external \"SET_FOLD\"] f s i\n  let fold_desc (type a b) (f : a * b -> b) (s : a set) (i : b) : b = [%external \"SET_FOLD_DESC\"] f s i\n  let size (type a) (s : a set) : nat = [%Michelson ({| { SIZE } |} : a set -> nat)]  s\n  let cardinal (type a) (s : a set) : nat = [%Michelson ({| { SIZE } |} : a set -> nat)] s\nend\n\nmodule List = struct\n  let length (type a) (xs : a list) : nat = [%Michelson ({| { SIZE } |} : a list -> nat)]  xs\n  let size (type a) (xs : a list) : nat = [%Michelson ({| { SIZE } |} : a list -> nat)]  xs\n  let head_opt (type a) (xs : a list) : a option = [%external \"LIST_HEAD_OPT\"] xs\n  let tail_opt (type a) (xs : a list) : (a list) option = [%external \"LIST_TAIL_OPT\"] xs\n  let map (type a b) (f : a -> b) (xs : a list) : b list = [%external \"LIST_MAP\"] f xs\n  let iter (type a) (f : a -> unit) (xs : a list): unit = [%external \"LIST_ITER\"] f xs\n  let fold (type a b) (f : b * a -> b) (xs : a list) (i : b) : b = [%external \"LIST_FOLD\"] f xs i\n  let fold_left (type a b) (f : b * a -> b) (i : b) (xs : a list) : b = [%external \"LIST_FOLD_LEFT\"] f i xs\n  let fold_right (type a b) (f : a * b -> b) (xs : a list) (i : b) : b = [%external \"LIST_FOLD_RIGHT\"] f xs i\n  let cons (type a) (x : a) (xs : a list) : a list = [%external \"CONS\"] x xs\nend\n\nmodule String = struct\n  let concat (b1 : string) (b2 : string) : string = [%Michelson ({| { UNPAIR ; CONCAT } |} : string * string -> string)] (b1, b2)\n  let sub (s : nat) (l : nat) (b : string) : string =\n    [%Michelson ({| { UNPAIR ; UNPAIR ; SLICE ; IF_NONE { PUSH string \"SLICE\" ; FAILWITH } {} } |} : nat * nat * string -> string)] (s, l, b)\n  let length (b : string) : nat = [%Michelson ({| { SIZE } |} : string -> nat)] b\nend\n\nmodule Option = struct\n  let unopt (type a) (v : a option) : a = [%external \"UNOPT\"] v\n  let unopt_with_error (type a) (v : a option) (s : string) : a = [%external \"UNOPT_WITH_ERROR\"] v s\n  (* let map (type a b) (f : a -> b) (v : a opti"
let d_fcbb6c9aae3541c7e1fbfd202347c4a8 = "type test_exec_error_balance_too_low =\n  { contract_too_low : address ; contract_balance : tez ; spend_request : tez }\n\ntype test_exec_error =\n  | Rejected of michelson_program * address\n  | Balance_too_low of test_exec_error_balance_too_low\n  | Other of string\n\ntype test_exec_result = Success of nat | Fail of test_exec_error\n\nmodule Test = struct\n  let to_contract (type p s) (t : (p, s) typed_address) : p contract = [%external \"TEST_TO_CONTRACT\"] t\n  let originate_from_file ((fn, e, v, s, t) : string * string * string list * michelson_program * tez) : address * michelson_program * int = [%external \"TEST_ORIGINATE_FROM_FILE\"] fn e v s t\n  let originate (type p s) ((f, s, t) : (p * s -> operation list * s) * s * tez) : ((p, s) typed_address * michelson_program * int) = [%external \"TEST_ORIGINATE\"] f s t\n  let set_source (a : address) : unit = [%external \"TEST_SET_SOURCE\"] a\n  let set_baker (a : address) : unit = [%external \"TEST_SET_BAKER\"] a\n  let transfer ((a, s, t) : address * michelson_program * tez) : test_exec_result = [%external \"TEST_EXTERNAL_CALL_TO_ADDRESS\"] a s t\n  let transfer_exn ((a, s, t) : address * michelson_program * tez) : nat = [%external \"TEST_EXTERNAL_CALL_TO_ADDRESS_EXN\"] a s t\n  let transfer_to_contract (type p) ((a, s, t) : p contract * p * tez) : test_exec_result = [%external \"TEST_EXTERNAL_CALL_TO_CONTRACT\"] a s t\n  let transfer_to_contract_exn (type p) ((a, s, t) : p contract * p * tez) : nat = [%external \"TEST_EXTERNAL_CALL_TO_CONTRACT_EXN\"] a s t\n  let get_storage (type a b) (t : (a, b) typed_address) : b = [%external \"TEST_GET_STORAGE\"] t\n  let get_storage_of_address (a : address) : michelson_program = [%external \"TEST_GET_STORAGE_OF_ADDRESS\"] a\n  let get_balance (a : address) : tez = [%external \"TEST_GET_BALANCE\"] a\n  let michelson_equal ((m1, m2) : michelson_program * michelson_program) : bool = [%external \"TEST_MICHELSON_EQUAL\"] m1 m2\n  let log (type a) (v : a) : unit = [%external \"TEST_LOG\"] v\n  let reset_state ((n, l) : nat * tez list) : unit = [%external \"TEST_STATE_RESET\"] n l\n  let get_voting_power (kh : key_hash) : nat = [%external \"TEST_GET_VOTING_POWER\"] kh\n  [@thunk]\n    let get_total_voting_power : nat = [%external \"TEST_GET_TOTAL_VOTING_POWER\"]\n  let bootstrap_contract (type p s) ((f, s, t) : (p * s -> operation list * s) * s * tez) : unit = [%external \"TEST_BOOTSTRAP_CONTRACT\"] f s t\n  let nth_bootstrap_contract (i : nat) : address = [%external \"TEST_NTH_BOOTSTRAP_CONTRACT\"] i\n  let nth_bootstrap_account (i : int) : address = [%external \"TEST_GET_NTH_BS\"] i\n  let nth_bootstrap_typed_address (type a b) (n : nat) : (a, b) typed_address = [%external \"TEST_NTH_BOOTSTRAP_TYPED_ADDRESS\"] n\n  let last_originations (u : unit) : (address, address list) map = [%external \"TEST_LAST_ORIGINATIONS\"] u\n  let compile_value (type a) (v : a) : michelson_program = [%external \"TEST_COMPILE_META_VALUE\"] v\n  let mutate_value (type a) ((n, v) : nat * a) : (a * mutation) option = [%external \"TEST_MUTATE_VALUE\"] n v\n  let save_mutation ((s, m) : string * mutation) : string option = [%external \"TEST_SAVE_MUTATION\"] s m\n  let mutation_test (type a b) ((v, f) : a * (a -> b)) : (b * mutation) option = [%external \"TEST_MUTATION_TEST\"] v f\n  let mutation_test_all (type a b) ((v, f) : a * (a -> b)) : (b * mutation) list = [%external \"TEST_MUTATION_TEST_ALL\"] v f\n  let run (type a b) ((f, v) : (a -> b) * a) : michelson_program = [%external \"TEST_RUN\"] f v\n  let eval (type a) (v : a) : michelson_program = [%external \"TEST_EVAL\"] v\n  let decompile (type a) (m : michelson_program) : a = [%external \"TEST_DECOMPILE\"] m\n  let random (type a) (u : unit) : a = [%external \"TEST_RANDOM\"] u\n  let add_account ((s, k) : string * key) : unit = [%external \"TEST_ADD_ACCOUNT\"] s k\n  let new_account (u : unit) : string * key = [%external \"TEST_NEW_ACCOUNT\"] u\n  let baker_account ((p, o) : (string * key) * tez option) : unit = [%external \"TEST_BAKER_ACCOUNT\"] p o\n  let bake_until_n_cycle_end (n : nat) : unit = [%external \"TEST_BAKE_UNTIL_N_CYCLE_END\"] n\n  let register_delegate (kh : key_hash) : unit = [%external \"TEST_REGISTER_"

let file_chunks = function
 | "std_curry_ithaca.mligo" | "/std_curry_ithaca.mligo" -> Some [  d_1b319111fd5b52a1ff5a524dcabb67b2;   d_fa8906cf6c1026d8999151894434fd7c;   d_b1d733fb76da185dec75be4a275041b7;   ]
 | "std_curry_jakarta.mligo" | "/std_curry_jakarta.mligo" -> Some [  d_a6dde8289f57cc12abaa8b7f5ca447a7;   d_5efba605c14daea6c0229fd63494d14c;   d_92a0c0d9aa552ce357610166c378698a;   ]
 | "std_uncurry_ithaca.mligo" | "/std_uncurry_ithaca.mligo" -> Some [  d_c13b3defbdcfef249fd5de6c5940bf4a;   d_e83d6d5ffa52a96f47127cea0fd9be4d;   d_f4c3e58921f52cae8d1301e41a1155e8;   ]
 | "std_uncurry_jakarta.mligo" | "/std_uncurry_jakarta.mligo" -> Some [  d_c47445b90cb3efe857a2ec8711f1ba65;   d_ea3e944956c1257cb9a8db7d0737e574;   d_9048e7429ed786680d770f7eb70c3d89;   ]
 | "test_curry.mligo" | "/test_curry.mligo" -> Some [  d_5eb13cdf86c3cfead85a9d7c868dcf74;   d_f76d5e4141ccc16f2bb492f8513d5bdb;   ]
 | "test_curry_stub.mligo" | "/test_curry_stub.mligo" -> Some [  d_9ccb85d53cd15605686f7c9899a0bc47;   d_616c2ac351ab2f5ad2983d2528ee3dd4;   ]
 | "test_uncurry.mligo" | "/test_uncurry.mligo" -> Some [  d_fcbb6c9aae3541c7e1fbfd202347c4a8;   d_cf779c7eb1c984fc36f2670e93496971;   ]
 | "test_uncurry_stub.mligo" | "/test_uncurry_stub.mligo" -> Some [  d_05823b0eacca75f2c915c180f4394332;   d_1ed171f3cf60d47cd2cc53196bdb6bcc;   ]
 | _ -> None

let file_list = ["std_curry_ithaca.mligo"; "std_curry_jakarta.mligo"; "std_uncurry_ithaca.mligo"; "std_uncurry_jakarta.mligo"; "test_curry.mligo"; "test_curry_stub.mligo"; "test_uncurry.mligo"; "test_uncurry_stub.mligo";  ]
end


let file_list = Internal.file_list

let read name =
  match Internal.file_chunks name with
  | None   -> None
  | Some c -> Some (String.concat "" c)