{-# LANGUAGE DeriveGeneric, DerivingVia, RecordWildCards #-}

-- | Module that handles ligo binary execution.
module Cli.Impl
  ( LigoError(..)
  , callLigo
  , getLigoDefinitions
  -- , parseLigoScopes
  -- , parseLigoTypesFor
  -- , getLigoScopesRaw
  -- , getLigoScopedDecls
  -- , getLigoTypesFor
  -- , parseScopedDecls
  ) where

import Control.Exception.Safe (Exception (..), SomeException, catchAny, throwIO)
-- import Control.Lens hiding ((<.>))
import Control.Monad.Catch (MonadThrow (throwM))
import Control.Monad.IO.Class (MonadIO (liftIO))
import Data.Aeson (eitherDecodeStrict')
-- import Data.Aeson.Lens (AsJSON (_JSON), AsPrimitive (_String), key, members)
-- import qualified Data.ByteString.Lazy.Char8 as C8
-- import qualified Data.HashMap.Strict as HM
import qualified Data.List as L
import Data.Text (Text, pack)
import Data.Text.Encoding (encodeUtf8)
import Duplo.Pretty (PP (PP), Pretty (..), (<+>), (<.>))
import System.Exit (ExitCode (..))
import System.Process (readProcessWithExitCode)

-- import AST.Scope.Common
import Cli.Json
import Cli.Types
import qualified Log
-- import Control.Monad.Reader (MonadIO)

----------------------------------------------------------------------------
-- Errors
----------------------------------------------------------------------------

data LigoError
  = -- | @ligo@ call unexpectedly failed (returned non-zero exit code).
    -- The error contains the error code, stdout and stderr contents.
    UnexpectedClientFailure
      Int -- ^ Exit code
      Text -- ^ stdout
      Text -- ^ stderr
  -- | -- Below are the errors which may fail due to some changes in ligo compiller.

  --   -- | Ligo compiller produced a type which we consider is malformed
  --   MalformedType
  --     Text
  | -- | Parse error occured during ligo output parsing.
    DefinitionParseError
      Text
  -- | -- | Parse error occured during scope parsing.
  --   ScopeParseError
  --     Text
  -- | -- | Scopes from which variables are failed to extract.
  --   VariableExtractError
  --     Value
  deriving (Show) via PP LigoError

instance Exception LigoError where
  displayException = show . pp

instance Pretty LigoError where
  pp = \case
    UnexpectedClientFailure errCode output errOutput ->
      "ligo binary unexpectedly failed with error code" <+> pp errCode
        <+> ".\nStdout:\n" <.> pp output <.> "\nStderr:\n" <.> pp errOutput
    -- MalformedType t ->
    --   "ligo binary produced type which we consider malformed:\n" <.> pp t
    -- ScopeParseError err ->
    --   "ligo binary produced scope which we consider malformed:\n" <.> pp err
    DefinitionParseError err ->
      "ligo binary produced output which we consider malformed:\n" <.> pp err
    -- VariableExtractError scopes ->
    --   "ligo produced scopes which we consider malformed since we cannot extract variables from it:\n" <.> text (show scopes)

----------------------------------------------------------------------------
-- Execution
----------------------------------------------------------------------------

-- | Call ligo binary.
callLigo
  :: HasLigoClient m => [String] -> m String
callLigo args = do
  LigoClientEnv {..} <- getLigoClientEnv
  Log.debug "CLI" $ "Running: " <> show _lceClientPath <> " " <> L.intercalate " " args
  liftIO $ readProcessWithExitCode' _lceClientPath args "" >>= \case
    (ExitSuccess, output, _errOutput) -> return output
    (ExitFailure errCode, pack -> output, pack -> errOutput) ->
      throwM $ UnexpectedClientFailure errCode output errOutput

-- output <$ logOutput output errOutput

-- | Variant of @readProcessWithExitCode@ that prints a better error in case of
-- an exception in the inner @readProcessWithExitCode@ call.
readProcessWithExitCode'
  :: FilePath
  -> [String]
  -> String
  -> IO (ExitCode, String, String)
readProcessWithExitCode' fp args inp =
    readProcessWithExitCode fp args inp `catchAny` handler
  where
    handler :: SomeException -> IO (ExitCode, String, String)
    handler e = do
      Log.err "CLI" errorMsg
      throwIO e

    errorMsg =
      mconcat
        [ "ERROR!! There was an error in executing `"
        , show fp
        , "` program. Is the executable available in PATH ?"
        ]

----------------------------------------------------------------------------
-- Execution
----------------------------------------------------------------------------

----------------------------------------------------------------------------
-- Parse from output file

-- | Parse scope from ligo output file generated by
-- ```
-- ligo get-scope contract --format=json --with-types
-- ```
-- and return a hashmap of scope name and its values.
-- parseLigoScopes
--   :: FilePath
--   -> IO (HM.HashMap Text LigoDefinitionScope)
-- parseLigoScopes contractPath =
--   let interpret :: Value -> HM.HashMap Text LigoDefinitionScope
--       interpret scopes =
--         scopes
--           ^?! key "definitions" -- TODO: may error here
--             . key "variables"
--           ^@.. members
--             . (_JSON :: Prism' Value LigoDefinitionScope)
--           ^. to HM.fromList
--    in do
--         output <- C8.readFile contractPath
--         case eitherDecodeStrict' @Value . encodeUtf8 . pack . C8.unpack $ output of
--           Left err -> throwM $ ScopeParseError (pack err)
--           Right scopes -> return $ interpret scopes

-- -- | Extract types from a ligo scope resolution file generated by
-- -- ```
-- -- ligo get-scope contract --format=json --with-types
-- -- ```
-- parseLigoTypesFor
--   :: FilePath -- ^ Ligo output file path
--   -> Text -- ^ Declaration name
--   -> IO [(Text, LigoTypeFull)]
-- parseLigoTypesFor contractPath name = do
--   output <- C8.readFile contractPath
--   case eitherDecodeStrict' @Value . encodeUtf8 . pack . C8.unpack $ output of
--     Left err -> throwM $ ScopeParseError (pack err)
--     Right scopes -> do
--       let variables = scopes ^? key "definitions" . key "variables"
--       case variables of
--         Nothing -> throwM $ VariableExtractError scopes
--         Just variables' -> return $ extractLigoTypesFrom name variables'

----------------------------------------------------------------------------
-- Execute ligo binary itself

getLigoDefinitions
  :: HasLigoClient m
  => FilePath
  -> m LigoDefinitions
getLigoDefinitions contractPath = do
  output <- callLigo ["get-scope", contractPath, "--format=json", "--with-types"]
  case eitherDecodeStrict' . encodeUtf8 . pack $ output of
    Left err -> throwM $ DefinitionParseError (pack err)
    Right definitions -> return definitions

-- | Extract a list of types in scopes from aeson @Value@ for some specific declaration under "name" field.
-- extractLigoTypesFrom :: Text -> Value -> [(Text, LigoTypeFull)]
-- extractLigoTypesFrom name context =
--   let current =
--         context
--           ^@.. members
--             <. filteredBy
--               (key "name"
--                  . _String
--                  . filtered (== name))
--               . key "t"
--               . (_JSON :: Prism' Value LigoTypeFull)
--    in -- TODO: needs research on nested scopes, currently we think that the list is
--       -- flat, but if it's not, you can simply uncomment code below
--       -- deeper =
--       --   context
--       --     ^. members
--       --       . members
--       --       . key "t"
--       --       . to (f name)
--       current -- <> deeper
