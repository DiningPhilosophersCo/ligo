{-# LANGUAGE DeriveGeneric, DerivingVia, RecordWildCards #-}

-- | Module that handles ligo binary execution.
module Cli.Impl
  ( LigoBinaryCallError(..)
  , callLigo
  , getLigoDefinitions
  , parseLigoDefinitions
  , parseLigoOutput
  , getLigoDefinitionsFrom
  ) where

import Control.Exception.Safe (Exception (..), try)
import Control.Monad
import Control.Monad.Catch (MonadThrow (throwM))
import Control.Monad.Reader
import Data.Aeson (eitherDecodeStrict')
import Data.Aeson.Types (FromJSON)
import qualified Data.ByteString.Lazy.Char8 as S8L
import Data.Text (Text, pack, unpack)
import Data.Text.Encoding (encodeUtf8)
import Duplo.Pretty (PP (PP), Pretty (..), text, (<+>), (<.>))
import System.Exit (ExitCode (..))
import System.Process
import Text.Regex.TDFA ((=~), getAllTextSubmatches)

import Cli.Json
import Cli.Types
import Extension (Lang (..), getExt)
import Log (i)
import qualified Log
import ParseTree (Source (..), srcToText)

----------------------------------------------------------------------------
-- Errors
----------------------------------------------------------------------------

data LigoBinaryCallError
  = -- | ligo call unexpectedly failed (returned non-zero exit code).
    -- The error contains the error code, stdout and stderr contents.
    UnexpectedClientFailure
      Int -- ^ Exit code
      Text -- ^ stdout
      Text -- ^ stderr

  | -- | Catch expected ligo failure to be able to restore from it.
    ExpectedClientFailure
      Text -- ^ stdout
      Text -- ^ stderr

  | -- | Expected ligo failure decoded from its JSON output.
    DecodedExpectedClientFailure
      LigoError -- ^ decoded JSON stderr

  -- Below are the errors which may fail due to some changes in ligo compiler.

  --   -- | Ligo compiller produced a type which we consider is malformed
  --   MalformedType
  --     Text
  | -- | Parse error occured during ligo output JSON decoding.
    DefinitionParseError
      Text
  | -- | Parse error occured during ligo stderr JSON decoding.
    LigoErrorNodeParseError
      Text
  | -- | Ligo has unexpectedly crashed.
    UnexpectedCrash
      Text -- ^ extracted failure message
  deriving stock (Eq)
  deriving (Show) via PP LigoBinaryCallError

instance Exception LigoBinaryCallError where
  displayException = show . pp

instance Pretty LigoBinaryCallError where
  pp = \case
    UnexpectedClientFailure errCode output errOutput ->
      "ligo binary unexpectedly failed with error code" <+> pp errCode
        <+> ".\nStdout:\n" <.> pp output <.> "\nStderr:\n" <.> pp errOutput
    ExpectedClientFailure output errOutput ->
      "ligo binary failed as expected with\nStdout:\n" <.> pp output
      <.> "\nStderr:\n" <.> pp errOutput
    DecodedExpectedClientFailure err ->
      "ligo binary produced expected error which we successfully decoded as:\n" <.> text (show err)
    LigoErrorNodeParseError err ->
      "ligo binary produced error JSON which we consider malformed:\n" <.> pp err <.> "[end]"
    DefinitionParseError err ->
      "ligo binary produced output which we consider malformed:\n" <.> pp err
    UnexpectedCrash err ->
      "ligo binary crashed with error: " <+> pp err

----------------------------------------------------------------------------
-- Execution
----------------------------------------------------------------------------

-- | Call ligo binary and return stdin and stderr accordingly.
callLigo
  :: HasLigoClient m => [String] -> Source -> m (Text, Text)
callLigo args con = do
  LigoClientEnv {..} <- getLigoClientEnv
  liftIO $ do
    raw <- srcToText con
    (ec, lo, le) <- readProcessWithExitCode _lceClientPath args (unpack raw)
    unless (ec == ExitSuccess && le == mempty) $ -- TODO: separate JSON errors and other ones
      throwM $ ExpectedClientFailure (pack lo) (pack le)
    unless (le == mempty) $
      throwM $ UnexpectedClientFailure 0 (pack lo) (pack le)
    Log.debug "LIGO" [i|Successfully exited with stdout:\n#{lo}\nand stderr:\n#{le}|]
    return (pack lo, pack le)

----------------------------------------------------------------------------
-- Execution
----------------------------------------------------------------------------

----------------------------------------------------------------------------
-- Parse from output file

-- | Parse ligo definitions from ligo output file generated by
-- ```
-- ligo get-scope `cat ${contract_path}` --format=json --with-types
-- ```
-- and return a hashmap of scope name and its values.
parseLigoDefinitions
  :: HasLigoClient m
  => FilePath
  -> m LigoDefinitions
parseLigoDefinitions contractPath = do
  output <- liftIO $ S8L.readFile contractPath
  case eitherDecodeStrict' . encodeUtf8 . pack . S8L.unpack $ output of
    Left err -> throwM $ DefinitionParseError (pack err)
    Right definitions -> return definitions

-- | Helper function used for parsing parts of ligo JSON output.
parseLigoOutput
  :: forall a . FromJSON a => FilePath -> IO a
parseLigoOutput contractPath = do
  output <- S8L.readFile contractPath
  case eitherDecodeStrict' @a . encodeUtf8 . pack . S8L.unpack $ output of
    Left err -> throwM $ DefinitionParseError (pack err)
    Right definitions -> return definitions

----------------------------------------------------------------------------
-- Execute ligo binary itself

-- | Get ligo definitions from a contract by calling ligo binary.
getLigoDefinitionsFrom
  :: HasLigoClient m
  => FilePath
  -> m (LigoDefinitions, Text)
getLigoDefinitionsFrom contractPath = do
  contents <- liftIO $ S8L.readFile contractPath
  getLigoDefinitions $ ByteString contractPath (S8L.toStrict contents)

-- | Get ligo definitions from raw contract.
getLigoDefinitions
  :: HasLigoClient m
  => Source
  -> m (LigoDefinitions, Text)
getLigoDefinitions contract = do
  Log.debug "LIGO.PARSE" [i|parsing the following contract:\n #{contract}|]
  ext <- getExt (srcPath contract)
  let
    syntax = case ext of
      Reason -> "reasonligo"
      Pascal -> "pascaligo"
      Caml   -> "cameligo"
  mbOut <- try $
    -- TODO: Use --typer=new, but currently it displays a lot of logging
    -- information together with the JSON which makes it difficult to reason
    -- about. It displays more errors than --typer=old (default).
    callLigo ["get-scope", "--format=json", "--with-types", "--syntax=" <> syntax, "/dev/stdin"] contract
  case mbOut of
    Right (output, errs) -> do
      Log.debug "LIGO.PARSE" [i|Successfully called ligo with #{output}|]
      case eitherDecodeStrict' @LigoDefinitions . encodeUtf8 $ output of
        Left err -> do
          Log.debug "LIGO.PARSE" [i|Unable to parse ligo definitions with: #{err}|]
          throwM $ DefinitionParseError (pack err)
        Right definitions -> return (definitions, errs)

    -- A middleware for processing `ExpectedClientFailure` error needed to pass it multiple levels up
    -- allowing us from restoring from expected ligo errors.
    Left (ExpectedClientFailure ligoStdOut ligoStdErr) -> do
      -- otherwise call ligo with `compile-contract` to extract more readable error message
      Log.debug "LIGO.PARSE" [i|decoding ligo error|]
      case eitherDecodeStrict' @LigoError . encodeUtf8 $ ligoStdErr of
        Left err -> do
          -- LIGO dumps its crash information on StdOut rather than StdErr.
          let failureRecovery = attemptToRecoverFromPossibleLigoCrash err $ unpack ligoStdOut
          case failureRecovery of
            Left failure -> do
              Log.debug "LIGO.PARSE" [i|ligo error decoding failure: #{failure}|]
              throwM $ LigoErrorNodeParseError $ pack failure
            Right recovered -> do
              -- LIGO doesn't dump any information we can extract to figure out
              -- where this error occurred, so we just log it for now. E.g.: a
              -- type-checker error just crashes with "Update an expression which is not a record"
              -- in the old typer. In the new typer, the error is the less
              -- intuitive "type error : break_ctor propagator".
              Log.debug "LIGO.PARSE" [i|ligo crashed with: #{recovered}|]
              throwM $ UnexpectedCrash $ pack recovered
        Right decodedError -> do
          Log.debug "LIGO.PARSE" [i|ligo error decoding successful with:\n#{decodedError}|]
          throwM $ DecodedExpectedClientFailure decodedError

    -- All other errors remain untouched
    Left err -> throwM err

-- | When LIGO fails to e.g. typecheck, it crashes. This function attempts to
-- extract the error message that was included with the crash.
-- Returns 'Left' if we failed to decode with the first parameter, otherwise
-- returns 'Right' with the recovered crash message.
attemptToRecoverFromPossibleLigoCrash :: String -> String -> Either String String
attemptToRecoverFromPossibleLigoCrash errDecoded stdErr = case getAllTextSubmatches (stdErr =~ regex) of
  [_, err] -> Right err
  _        -> Left errDecoded
  where
    regex :: String
    regex = "ligo: internal error, uncaught exception:\n      \\(Failure \"(.*)\"\\)"
