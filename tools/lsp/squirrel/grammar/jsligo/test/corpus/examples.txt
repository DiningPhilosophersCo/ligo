=========
modules
=========

namespace EURO {
    export type t = nat;
    export let one : t = 1 as nat;
    export namespace CONST {
        let zero : t = 0 as nat;
        let one : t = 1 as nat;
    };
};

import US_DOLLAR = EURO;

type storage = EURO.t;
let uno : storage = EURO.one;

---
(source_file
  (namespace_statement (ModuleName)
    (export_statement
      (type_decl (TypeName) (TypeName)))
    (export_statement
      (let_decl 
        (var_pattern (Name))
        (type_annotation (TypeName))
        (expr 
          (type_as_annotation (Int) (TypeName)))))
    (namespace_statement (ModuleName)
      (let_decl 
        (var_pattern (Name))
        (type_annotation (TypeName))
        (expr 
          (type_as_annotation (Int) (TypeName))))
      (let_decl
        (var_pattern (Name))
        (type_annotation (TypeName))
        (expr
         (type_as_annotation (Int) (TypeName))))))
  (import_statement (ModuleName) (ModuleName))
  (type_decl 
    (TypeName)
    (module_access_t
      (ModuleName) 
      (module_var_t (Name))))
  (let_decl
    (var_pattern (Name))
    (type_annotation (TypeName))
    (expr (module_access
          (ModuleName)
          (module_var (Name))))))

=========
module access function call
=========

let x : int = foo(bar(baz(1)))

----

(source_file
  (let_decl
    (var_pattern (Name))
    (type_annotation (TypeName))
    (expr
      (call_expr
        (lambda (Name))
        (expr
          (call_expr
            (lambda (Name))
            (expr
              (call_expr
                (lambda (Name))
                (expr (Int))))))))))

=========
module access function call
=========

let x : int = int(List.length(x)) 

---

// wrong