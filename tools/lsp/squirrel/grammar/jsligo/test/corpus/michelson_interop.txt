=========
michelson interop
=========

let michelson_add = (n: [nat, nat]): nat =>
  (Michelson`{ UNPAIR ; ADD }` as ((n: [nat, nat]) => nat))(n);

---

(source_file
  (let_decl
    (var_pattern (Name))
    (fun_expr
      (parameter
        (Name)
        (type_annotation
          (type_tuple (TypeName) (TypeName))))
      (type_annotation (TypeName))
      (body
        (call_expr
          (lambda
            (michelson_interop
              (michelson_code)
              (fun_type
                (fun_param
                  (Name)
                  (type_annotation
                    (type_tuple (TypeName) (TypeName))))
                (TypeName))))
          (arguments (Name)))))))

=========
michelson pair
=========

type x_and = michelson_pair<[string, "x", w_and_v, "other"]>;

---

(source_file
  (type_decl
    (TypeName)
      (type_ctor_app
        (TypeName)
        (type_tuple 
          (TypeName) 
          (string_type (String)) 
          (TypeName)
          (string_type (String))))))

=========
michelson or
=========

type y_or = michelson_or<[unit, "y", x_and, "other"]>;

---

(source_file
  (type_decl
    (TypeName)
      (type_ctor_app
        (TypeName)
        (type_tuple 
          (TypeName) 
          (string_type (String)) 
          (TypeName)
          (string_type (String))))))
